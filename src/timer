act_comm.cpp:	  return;    }    if (!IS_SET (ch->act2, PLR_NOEXP))    {
act_comm.cpp:        SET_BIT(ch->act2, PLR_NOEXP);
act_comm.cpp:        return;    }    else    {        REMOVE_BIT(ch->act2, PLR_NOEXP);
act_comm.cpp:    if (!str_cmp(ch->name,"Demandred")&& IS_IMMORTAL(ch))
act_comm.cpp:    if (ch->pcdata->confirm_delete)
act_comm.cpp:            ch->pcdata->confirm_delete = FALSE;
act_comm.cpp:            sprintf (strsave, "%s%s", PLAYER_DIR, capitalize (ch->name));
act_comm.cpp:            if (ch->clan > 0) 
act_comm.cpp:              remove_member(ch->name, ch->clan);
act_comm.cpp:    ch->pcdata->confirm_delete = TRUE;
act_comm.cpp:    if (!IS_SET (ch->comm, COMM_NOGOSSIP))
act_comm.cpp:    if (!IS_SET(ch->comm,COMM_NOWAR))
act_comm.cpp:    if (!IS_SET (ch->comm, COMM_NOAUCTION))
act_comm.cpp:    if (!IS_SET (ch->comm, COMM_NOBITCH))
act_comm.cpp:    if (IS_SET (ch->act2, PLR_MSP_MUSIC))
act_comm.cpp:    if (IS_SET (ch->act2, PLR_MSP_SOUND))
act_comm.cpp:    if (!IS_SET (ch->comm, COMM_NOMUSIC))
act_comm.cpp:    if (!IS_SET (ch->comm, COMM_NOOOC))
act_comm.cpp:    if (!IS_SET (ch->comm, COMM_NOQUOTE))
act_comm.cpp:    if (!IS_SET (ch->comm, COMM_NOGRATS))
act_comm.cpp:    if (!IS_SET (ch->comm, COMM_NOTOURNEY))
act_comm.cpp:    if (!IS_SET (ch->comm, COMM_NOTRIVIA))
act_comm.cpp:    if (!IS_SET (ch->comm, COMM_NORADIO))
act_comm.cpp:        if (!IS_SET (ch->comm, COMM_NOWIZ))
act_comm.cpp:    if (!IS_SET (ch->comm, COMM_SHOUTSOFF))
act_comm.cpp:    if (!IS_SET (ch->comm, COMM_DEAF))
act_comm.cpp:    if (IS_SET (ch->comm, COMM_QUIET))
act_comm.cpp:    if (IS_SET (ch->comm, COMM_AFK))
act_comm.cpp:    if (IS_SET (ch->comm, COMM_SNOOP_PROOF))
act_comm.cpp:    if (ch->lines != PAGELEN)
act_comm.cpp:        if (ch->lines)
act_comm.cpp:                     ch->lines + 2);
act_comm.cpp:    if (ch->prompt != NULL)
act_comm.cpp:        sprintf (buf, "Your current prompt is: %s\n\r", ch->prompt);
act_comm.cpp:    if (IS_SET (ch->comm, COMM_NOTELL))
act_comm.cpp:    if (IS_SET (ch->comm, COMM_NOCHANNELS))
act_comm.cpp:    if (IS_SET (ch->comm, COMM_NOEMOTE))
act_comm.cpp:    if (IS_SET (ch->comm, COMM_DEAF))
act_comm.cpp:        REMOVE_BIT (ch->comm, COMM_DEAF);
act_comm.cpp:        SET_BIT (ch->comm, COMM_DEAF);
act_comm.cpp:      if (IS_SET (ch->act2, PLR_MSP_MUSIC))
act_comm.cpp:        REMOVE_BIT (ch->act2, PLR_MSP_MUSIC);
act_comm.cpp:        REMOVE_BIT (ch->act2, PLR_MSP_PLAYING);
act_comm.cpp:        SET_BIT (ch->act2, PLR_MSP_MUSIC);
act_comm.cpp:      if (IS_SET (ch->act2, PLR_MSP_SOUND))
act_comm.cpp:        REMOVE_BIT (ch->act2, PLR_MSP_SOUND);
act_comm.cpp:        SET_BIT (ch->act2, PLR_MSP_SOUND);
act_comm.cpp:    if (IS_SET (ch->comm, COMM_QUIET))
act_comm.cpp:        REMOVE_BIT (ch->comm, COMM_QUIET);
act_comm.cpp:        SET_BIT (ch->comm, COMM_QUIET);
act_comm.cpp:    if (IS_SET (ch->comm, COMM_AFK))
act_comm.cpp:        REMOVE_BIT (ch->comm, COMM_AFK);
act_comm.cpp:        SET_BIT (ch->comm, COMM_AFK);
act_comm.cpp:    if (buf_string (ch->pcdata->buffer)[0] == '\0')
act_comm.cpp:    page_to_char (buf_string (ch->pcdata->buffer), ch);
act_comm.cpp:    clear_buf (ch->pcdata->buffer);
act_comm.cpp:   if (!IS_SET(ch->comm, COMM_NOVICE) && ch->clan != clan_lookup("Guide"))
act_comm.cpp:   if (ch->clan == clan_lookup("Guide"))
act_comm.cpp:		   clan_table[ch->clan].rank[ch->rank]);
act_comm.cpp:      if (IS_SET(ch->comm,COMM_NOOOC))
act_comm.cpp:        REMOVE_BIT(ch->comm,COMM_NOOOC);
act_comm.cpp:        SET_BIT(ch->comm,COMM_NOOOC);
act_comm.cpp:        if (IS_SET(ch->comm,COMM_QUIET))
act_comm.cpp:        if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.cpp:      REMOVE_BIT(ch->comm,COMM_NOOOC);
act_comm.cpp:    if (!IS_SET(ch->act, PLR_TOURNEY) || IS_NPC(ch))
act_comm.cpp:    if (!IS_SET(ch->act, PLR_QUESTING) || IS_NPC(ch))
act_comm.cpp:      if (IS_SET(ch->comm,COMM_NOBITCH))
act_comm.cpp:        REMOVE_BIT(ch->comm,COMM_NOBITCH);
act_comm.cpp:        SET_BIT(ch->comm,COMM_NOBITCH);
act_comm.cpp:        if (IS_SET(ch->comm,COMM_QUIET))
act_comm.cpp:        if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.cpp:      REMOVE_BIT(ch->comm,COMM_NOBITCH);
act_comm.cpp:          if (!str_cmp(ch->name, "Asmodeus"))
act_comm.cpp:          else if (!str_cmp(ch->name, "Dreyus"))
act_comm.cpp:	  else if (!str_cmp(ch->name, "Thom"))
act_comm.cpp:          else if (!str_cmp(ch->name, "Jasin"))
act_comm.cpp:    if (!IS_FORSAKEN(ch) && !ch->pcdata->isMinion)
act_comm.cpp:                !str_cmp(d->character->pcdata->forsaken_master, ch->name) ) 
act_comm.cpp:         sprintf( buf, "`1%s voice booms in your head.`*\n\r`8%s`*", ch->name,
act_comm.cpp:            !str_cmp(d->character->name, ch->pcdata->forsaken_master)) 
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOGOSSIP))
act_comm.cpp:            REMOVE_BIT (ch->comm, COMM_NOGOSSIP);
act_comm.cpp:            SET_BIT (ch->comm, COMM_NOGOSSIP);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_QUIET))
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOCHANNELS))
act_comm.cpp:        REMOVE_BIT (ch->comm, COMM_NOGOSSIP);
act_comm.cpp:                  ch->name,
act_comm.cpp:/*            if (IS_NULLSTR(ch->pretit) || !str_cmp(ch->pretit, "(null)") || IS_DISGUISED(ch))
act_comm.cpp:                            IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name,
act_comm.cpp:                  ch->pretit,
act_comm.cpp:                  ch->name,
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOTRIVIA))
act_comm.cpp:            REMOVE_BIT (ch->comm, COMM_NOTRIVIA);
act_comm.cpp:            SET_BIT (ch->comm, COMM_NOTRIVIA);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_QUIET))
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOCHANNELS))
act_comm.cpp:        REMOVE_BIT (ch->comm, COMM_NOTRIVIA);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NORADIO))
act_comm.cpp:            REMOVE_BIT (ch->comm, COMM_NORADIO);
act_comm.cpp:            SET_BIT (ch->comm, COMM_NORADIO);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_QUIET))
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOCHANNELS))
act_comm.cpp:        REMOVE_BIT (ch->comm, COMM_NORADIO);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOGRATS))
act_comm.cpp:            REMOVE_BIT (ch->comm, COMM_NOGRATS);
act_comm.cpp:            SET_BIT (ch->comm, COMM_NOGRATS);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_QUIET))
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOCHANNELS))
act_comm.cpp:        REMOVE_BIT (ch->comm, COMM_NOGRATS);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOQUOTE))
act_comm.cpp:            REMOVE_BIT (ch->comm, COMM_NOQUOTE);
act_comm.cpp:            SET_BIT (ch->comm, COMM_NOQUOTE);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_QUIET))
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOCHANNELS))
act_comm.cpp:        REMOVE_BIT (ch->comm, COMM_NOQUOTE);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOQUESTION))
act_comm.cpp:            REMOVE_BIT (ch->comm, COMM_NOQUESTION);
act_comm.cpp:            SET_BIT (ch->comm, COMM_NOQUESTION);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_QUIET))
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOCHANNELS))
act_comm.cpp:        REMOVE_BIT (ch->comm, COMM_NOQUESTION);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOQUESTION))
act_comm.cpp:            REMOVE_BIT (ch->comm, COMM_NOQUESTION);
act_comm.cpp:            SET_BIT (ch->comm, COMM_NOQUESTION);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_QUIET))
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOCHANNELS))
act_comm.cpp:        REMOVE_BIT (ch->comm, COMM_NOQUESTION);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOMUSIC))
act_comm.cpp:            REMOVE_BIT (ch->comm, COMM_NOMUSIC);
act_comm.cpp:            SET_BIT (ch->comm, COMM_NOMUSIC);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_QUIET))
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOCHANNELS))
act_comm.cpp:        REMOVE_BIT (ch->comm, COMM_NOMUSIC);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOCLAN))
act_comm.cpp:            REMOVE_BIT (ch->comm, COMM_NOCLAN);
act_comm.cpp:            SET_BIT (ch->comm, COMM_NOCLAN);
act_comm.cpp:    if (IS_SET (ch->comm, COMM_NOCHANNELS))
act_comm.cpp:    REMOVE_BIT (ch->comm, COMM_NOCLAN);
act_comm.cpp:                  clan_table[ch->clan].rank[ch->rank], 
act_comm.cpp:		  IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name, 
act_comm.cpp:    if (ch->clan == clan_lookup("warder") && (ch->sex == 1))
act_comm.cpp:    else if (ch->clan == clan_lookup("aessedai") && (ch->sex == 2))
act_comm.cpp:    if (IS_SET (ch->comm, COMM_NOCHANNELS))
act_comm.cpp:    REMOVE_BIT (ch->comm, COMM_NOCLAN);
act_comm.cpp:             clan_table[ch->clan].rank[ch->rank], 
act_comm.cpp:	     IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name, 
act_comm.cpp:    if (ch->clan == clan_lookup("ashaman"))
act_comm.cpp:    else if (ch->clan == clan_lookup("aiel"))
act_comm.cpp:    if (IS_SET (ch->comm, COMM_NOCHANNELS))
act_comm.cpp:    REMOVE_BIT (ch->comm, COMM_NOCLAN);
act_comm.cpp:             IS_DRAGON(ch) ? "Lord of the Morning" : clan_table[ch->clan].rank[ch->rank], 
act_comm.cpp:               IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name, color, argument);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOWIZ))
act_comm.cpp:            REMOVE_BIT (ch->comm, COMM_NOWIZ);
act_comm.cpp:            SET_BIT (ch->comm, COMM_NOWIZ);
act_comm.cpp:    REMOVE_BIT (ch->comm, COMM_NOWIZ);
act_comm.cpp:        if (IS_SET (ch->comm, COMM_NOWIZ))
act_comm.cpp:            REMOVE_BIT (ch->comm, COMM_NOWIZ);
act_comm.cpp:            SET_BIT (ch->comm, COMM_NOWIZ);
act_comm.cpp:    REMOVE_BIT (ch->comm, COMM_NOWIZ);
act_comm.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_NORP))
act_comm.cpp:	&& !IS_SET (ch->comm, COMM_AFK)
act_comm.cpp:     if (ch->level < LEVEL_IMMORTAL && !IS_NPC(ch))
act_comm.cpp:                        ch->name,
act_comm.cpp:			ch->in_room->name, 
act_comm.cpp:			ch->in_room->vnum);
act_comm.cpp:        for (mob = ch->in_room->people; mob != NULL; mob = mob_next)
act_comm.cpp:        for ( obj = ch->in_room->contents; obj; obj = obj_next )
act_comm.cpp:        if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_SPEECH ) )
act_comm.cpp:            p_act_trigger( argument, NULL, NULL, ch->in_room, ch, NULL, NULL, TRIG_SPEECH );
act_comm.cpp:        for (mob = ch->in_room->people; mob != NULL; mob = mob_next)
act_comm.cpp:        if (IS_SET (ch->comm, COMM_SHOUTSOFF))
act_comm.cpp:            REMOVE_BIT (ch->comm, COMM_SHOUTSOFF);
act_comm.cpp:            SET_BIT (ch->comm, COMM_SHOUTSOFF);
act_comm.cpp:    if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.cpp:    REMOVE_BIT (ch->comm, COMM_SHOUTSOFF);
act_comm.cpp:    if (IS_SET (ch->comm, COMM_NOTELL) || IS_SET (ch->comm, COMM_DEAF))
act_comm.cpp:    if (IS_SET (ch->comm, COMM_QUIET))
act_comm.cpp:    if (IS_SET (ch->comm, COMM_DEAF))
act_comm.cpp:        sprintf (buf, "%s tells you '2%s`*'`*\n\r", IS_DISGUISED(ch) ? ch->pcdata->disguise.orig_name : PERS (ch, victim, TRUE),
act_comm.cpp:    if ( !IS_NPC(victim) && !str_cmp(victim->pcdata->ignore, ch->name) && !IS_IMMORTAL (ch))
act_comm.cpp:        sprintf (buf, "%s tells you '`2%s`*'`*\n\r", IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:PERS (ch, victim, TRUE),
act_comm.cpp:    sprintf (buf, "%s tells you '`2%s`*'`*\n\r", IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:PERS (ch, victim, TRUE),
act_comm.cpp:    if (IS_SET (ch->comm, COMM_NOTELL) || IS_SET (ch->comm, COMM_DEAF))
act_comm.cpp:    if (IS_SET (ch->comm, COMM_QUIET))
act_comm.cpp:    if (IS_SET (ch->comm, COMM_DEAF))
act_comm.cpp:        sprintf (buf, "%s whispers to you '2%s`*'`*\n\r", IS_DISGUISED(ch) ? ch->pcdata->disguise.orig_name : PERS (ch, victim, TRUE),
act_comm.cpp:    if ( !IS_NPC(victim) && !str_cmp(victim->pcdata->ignore, ch->name) && !IS_IMMORTAL (ch))
act_comm.cpp:	&& !IS_SET (ch->comm, COMM_AFK)
act_comm.cpp:                if (ch->desc->incomm[0] != '!' && 
act_comm.cpp:                   strcmp (ch->desc->incomm, ch->desc->inlast))
act_comm.cpp:		  ch->desc->repeat = 0;
act_comm.cpp:		  if (++ch->desc->repeat >= 3 && ch->desc->character
act_comm.cpp:		     && ch->desc->connected == CON_PLAYING)
act_comm.cpp:		     xp=-xp*(ch->desc->repeat);
act_comm.cpp:                  ch->name,
act_comm.cpp:        sprintf (buf, "%s whispers to you '`2%s`*'`*\n\r", IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:PERS (ch, victim, FALSE),
act_comm.cpp:    sprintf (buf, "%s whispers to you '`2%s`*'`*\n\r", IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:PERS (ch, victim, FALSE),
act_comm.cpp:  free_string(ch->pcdata->ignore);
act_comm.cpp:  ch->pcdata->ignore = str_dup(argument);
act_comm.cpp:    if (IS_SET (ch->comm, COMM_NOTELL))
act_comm.cpp:    if ((victim = ch->ireply) == NULL || victim->in_room != ch->in_room)
act_comm.cpp:        sprintf (buf, "%s whispers to you '`2%s`*'`*\n\r", IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:PERS (ch, victim, FALSE),
act_comm.cpp:                  ch->name,
act_comm.cpp:          sprintf (buf, "%s whispers you '`2%s`*'`*\n\r", IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:PERS (ch, victim, FALSE),
act_comm.cpp:    sprintf (buf, "%s whispers to you '`2%s`*'`*\n\r", IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:PERS (ch, victim, FALSE),
act_comm.cpp:    if (IS_SET (ch->comm, COMM_NOTELL))
act_comm.cpp:    if ((victim = ch->oreply) == NULL)
act_comm.cpp:    if ( !IS_NPC(victim) && !str_cmp(victim->pcdata->ignore, ch->name) && !IS_IMMORTAL (ch))
act_comm.cpp:        sprintf (buf, "%s tells you '`2%s`*'`*\n\r", IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:PERS (ch, victim, TRUE),
act_comm.cpp:          sprintf (buf, "%s tells you '`2%s`*'`*\n\r", IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:PERS (ch, victim, TRUE),
act_comm.cpp:    sprintf (buf, "%s tells you '`2%s`*'`*\n\r", IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:PERS (ch, victim, TRUE),
act_comm.cpp:            && d->character->in_room->area == ch->in_room->area
act_comm.cpp:    if (!IS_NPC (ch) && IS_SET (ch->comm, COMM_NOEMOTE))
act_comm.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_NORP))
act_comm.cpp:		&& !IS_SET (ch->comm, COMM_AFK)
act_comm.cpp:			ch->name, 
act_comm.cpp:			ch->in_room->name, 
act_comm.cpp:			ch->in_room->vnum);
act_comm.cpp:    if (!IS_NPC (ch) && IS_SET (ch->comm, COMM_NOEMOTE))
act_comm.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_NORP))
act_comm.cpp:		&& !IS_SET (ch->comm, COMM_AFK))
act_comm.cpp:			ch->name, 
act_comm.cpp:			ch->in_room->name, 
act_comm.cpp:			ch->in_room->vnum);
act_comm.cpp:    if (!IS_NPC (ch) && IS_SET (ch->comm, COMM_NOEMOTE))
act_comm.cpp:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
act_comm.cpp:        if (vch->desc == NULL || vch == ch)
act_comm.cpp:        if ((letter = strstr (argument, vch->name)) == NULL)
act_comm.cpp:        name = vch->name;
act_comm.cpp:            if (*letter == '\'' && matches == int(strlen (vch->name)))
act_comm.cpp:            if (*letter == 's' && matches == int(strlen (vch->name)))
act_comm.cpp:            if (matches == int(strlen (vch->name)))
act_comm.cpp:                if (matches == int(strlen (vch->name)))
act_comm.cpp:                    name = vch->name;
act_comm.cpp:            name = vch->name;
act_comm.cpp:        UMIN (ch->level, int(sizeof (pose_table) / sizeof (pose_table[0])) - 1);
act_comm.cpp:    act (pose_table[pose].message[2 * ch->cClass + 0], ch, NULL, NULL,
act_comm.cpp:    act (pose_table[pose].message[2 * ch->cClass + 1], ch, NULL, NULL,
act_comm.cpp:    if (ch->position == POS_FIGHTING)
act_comm.cpp:    if (ch->pcdata->pk_timer > 0)
act_comm.cpp:    if IS_SET(ch->act, PLR_TOURNEY)
act_comm.cpp:     REMOVE_BIT(ch->act, PLR_TOURNEY);
act_comm.cpp:    if (IS_SET(ch->act, PLR_TAG))
act_comm.cpp:     REMOVE_BIT(ch->act, PLR_TAG);
act_comm.cpp:    if (IS_SET(ch->act, PLR_QUESTOR))
act_comm.cpp:     REMOVE_BIT(ch->act, PLR_QUESTOR);
act_comm.cpp:    if (IS_SET(ch->act, PLR_QUESTING))
act_comm.cpp:     REMOVE_BIT(ch->act, PLR_QUESTING);
act_comm.cpp:    if (IS_SET(ch->act, PLR_IT))
act_comm.cpp:     REMOVE_BIT(ch->act, PLR_IT);
act_comm.cpp:    if (IS_SET(ch->act2, PLR_TOURNAMENT_START))
act_comm.cpp:     REMOVE_BIT(ch->act2, PLR_TOURNAMENT_START);
act_comm.cpp:    if (ch->position < POS_STUNNED)
act_comm.cpp:    sprintf (log_buf, "%s has quit.", ch->name);
act_comm.cpp:    id = ch->id;
act_comm.cpp:    d = ch->desc;
act_comm.cpp:        if (tch && tch->id == id)
act_comm.cpp:    if (IS_AFFECTED (ch, AFF_CHARM) && ch->master != NULL)
act_comm.cpp:        act ("But you'd rather follow $N!", ch, NULL, ch->master, TO_CHAR);
act_comm.cpp:        if (ch->master == NULL)
act_comm.cpp:        ch->master = NULL;
act_comm.cpp:    REMOVE_BIT (ch->act, PLR_NOFOLLOW);
act_comm.cpp:    if (ch->master == NULL)
act_comm.cpp:      ch->master = victim;
act_comm.cpp:    if (ch->master != NULL)
act_comm.cpp:    if (ch->master != NULL)
act_comm.cpp:    ch->master = master;
act_comm.cpp:    ch->leader = NULL;
act_comm.cpp:    if (ch->master == NULL)
act_comm.cpp:        STR_REMOVE_BIT (ch->affected_by, AFF_CHARM);
act_comm.cpp:    if (can_see (ch->master, ch) && ch->in_room != NULL)
act_comm.cpp:        act ("$n stops following you.", ch, NULL, ch->master, TO_VICT);
act_comm.cpp:        act ("You stop following $N.", ch, NULL, ch->master, TO_CHAR);
act_comm.cpp:    if (ch->master->pet == ch)
act_comm.cpp:        ch->master->pet = NULL;
act_comm.cpp:    ch->master = NULL;
act_comm.cpp:    ch->leader = NULL;
act_comm.cpp:    ch->mount = NULL;
act_comm.cpp:    ch->is_mounted = FALSE;
act_comm.cpp:    for (fch = char_list; fch != NULL; fch = fch->next)
act_comm.cpp:        if (fch->mount == ch)
act_comm.cpp:          fch->mount = NULL;
act_comm.cpp:	  fch->is_mounted = FALSE;
act_comm.cpp:    if (ch->master != NULL)
act_comm.cpp:        if (ch->master->pet == ch)
act_comm.cpp:            ch->master->pet = NULL;
act_comm.cpp:    ch->leader = NULL;
act_comm.cpp:    for (fch = char_list; fch != NULL; fch = fch->next)
act_comm.cpp:        if (fch->master == ch)
act_comm.cpp:        if (fch->leader == ch)
act_comm.cpp:            fch->leader = fch;
act_comm.cpp:            || (IS_IMMORTAL (victim) && victim->trust >= ch->trust))
act_comm.cpp:    for (och = ch->in_room->people; och != NULL; och = och_next)
act_comm.cpp:        och_next = och->next_in_room;
act_comm.cpp:            && och->master == ch && (fAll || och == victim))
act_comm.cpp:  for (gch = char_list; gch != NULL; gch = gch->next)
act_comm.cpp:    if (IS_NPC(gch) && gch->master == ch)
act_comm.cpp:        leader = (ch->leader != NULL) ? ch->leader : ch;
act_comm.cpp:        for (gch = char_list; gch != NULL; gch = gch->next)
act_comm.cpp:                         gch->level,
act_comm.cpp:                         IS_NPC (gch) ? "Mob" : class_table[gch->cClass].who_name,
act_comm.cpp:                         capitalize (PERS (gch, ch, FALSE)), gch->hit, gch->max_hit,
act_comm.cpp:                         gch->mana, gch->max_mana, gch->move, gch->max_move,
act_comm.cpp:                         gch->exp);
act_comm.cpp:    if (ch->master != NULL || (ch->leader != NULL && ch->leader != ch))
act_comm.cpp:    if (ch->gold < amount_gold || ch->silver < amount_silver)
act_comm.cpp:    for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room)
act_comm.cpp:    ch->silver -= amount_silver;
act_comm.cpp:    ch->silver += share_silver + extra_silver;
act_comm.cpp:    ch->gold -= amount_gold;
act_comm.cpp:    ch->gold += share_gold + extra_gold;
act_comm.cpp:    for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room)
act_comm.cpp:            gch->gold += share_gold;
act_comm.cpp:            gch->silver += share_silver;
act_comm.cpp:    if (IS_SET (ch->comm, COMM_NOTELL))
act_comm.cpp:    for (gch = char_list; gch != NULL; gch = gch->next)
act_comm.cpp:    if (ach->leader != NULL)
act_comm.cpp:        ach = ach->leader;
act_comm.cpp:    if (bch->leader != NULL)
act_comm.cpp:        bch = bch->leader;
act_comm.cpp:        if (!IS_SET (ch->act, PLR_COLOUR))
act_comm.cpp:            SET_BIT (ch->act, PLR_COLOUR);
act_comm.cpp:            REMOVE_BIT (ch->act, PLR_COLOUR);
act_enter.cpp:                && (IS_NPC (ch) || IS_SET (ch->act, ACT_AGGRESSIVE)
act_enter.cpp:    if (ch->fighting != NULL)
act_enter.cpp:        old_room = ch->in_room;
act_enter.cpp:        portal = get_obj_list (ch, argument, ch->in_room->contents);
act_enter.cpp:		blood = get_obj_list (ch, argument, ch->in_room->contents);
act_enter.cpp:        if (!ch->is_mounted)
act_enter.cpp:        if (IS_NPC (ch) && IS_SET (ch->act, ACT_AGGRESSIVE)
act_enter.cpp:            && IS_SET (location->room_flags, ROOM_LAW) && !IS_SET(ch->act, ACT_MOUNT))
act_enter.cpp:            && IS_SET (location->room_flags, ROOM_NO_MOB) && !IS_SET(ch->act, ACT_MOUNT))
act_enter.cpp:        if (!ch->is_mounted)
act_enter.cpp:	   if (!ch->is_mounted)	
act_enter.cpp:	   if (!ch->is_mounted)	
act_enter.cpp:    if (!IS_NPC(ch) && IS_AFFECTED (ch, AFF_VEIL) && ch->pcdata->pk_timer == 0  && IS_SET (ch->in_room->room_flags, ROOM_SAFE))
act_enter.cpp:    if (!IS_NPC(ch) && IS_AFFECTED (ch, AFF_SHROUD) && ch->pcdata->pk_timer == 0  && IS_SET (ch->in_room->room_flags, ROOM_SAFE))
act_enter.cpp:	   if (!ch->is_mounted)
act_enter.cpp:             act ("$n has arrived riding $N.", ch, portal, ch->mount, TO_ROOM);
act_enter.cpp:	   if (!ch->is_mounted)   
act_enter.cpp:             act ("$n has arrived through $p riding $N.", ch, portal, ch->mount, TO_ROOM);
act_enter.cpp:            fch_next = fch->next_in_room;
act_enter.cpp:            if (IS_NPC(fch) && fch->mount == ch  
act_enter.cpp:                && fch->position < POS_STANDING)             
act_enter.cpp:            if (IS_NPC(fch) && fch->mount == ch && fch->position == POS_STANDING)
act_enter.cpp:            if (fch->master == ch && IS_AFFECTED (fch, AFF_CHARM)
act_enter.cpp:                && fch->position < POS_STANDING)
act_enter.cpp:            if (fch->master == ch && fch->position == POS_STANDING)
act_enter.cpp:                if (IS_SET (ch->in_room->room_flags, ROOM_LAW)
act_enter.cpp:                    && (IS_NPC (fch) && IS_SET (fch->act, ACT_AGGRESSIVE) 
act_enter.cpp:		    && !IS_SET(fch->act, ACT_MOUNT)))
act_enter.cpp:                if (IS_SET (ch->in_room->room_flags, ROOM_NO_MOB) &&
act_enter.cpp:            if (ch->in_room == old_room)
act_info.cpp:  if (IS_SET (ch->act2, PLR_NOEQ))
act_info.cpp:    REMOVE_BIT(ch->act2, PLR_NOEQ);
act_info.cpp:  SET_BIT(ch->act2, PLR_NOEQ);
act_info.cpp:  sprintf(response, "%s", com_main(argument, ch->name));
act_info.cpp:    if( IS_SET( ch->act, PLR_HOLYLIGHT ) )
act_info.cpp:    was_in_room = ch->in_room;
act_info.cpp:	if( ( pexit = ch->in_room->exit[door] ) != NULL
act_info.cpp:	    ch->in_room = pexit->u1.to_room;
act_info.cpp:	    list = ch->in_room->people;
act_info.cpp:	    for( rch = list; rch != NULL; rch = rch->next_in_room )
act_info.cpp:                  if (!IS_NPC(ch) && ch->pcdata->pk_timer > 0 && IS_NPC(rch))
act_info.cpp:    ch->in_room = was_in_room;
act_info.cpp:    	    if ( ( pexit   = ch->in_room->exit[dir] ) == NULL
act_info.cpp:    	if ( ( pexit   = ch->in_room->exit[dir] ) == NULL
act_info.cpp:           logf("%s turned in %d coupons for %s", ch->name, num, obj->short_descr);
act_info.cpp:           logf("%s turned in %d coupons for %s", ch->name, num, obj->short_descr);
act_info.cpp:           logf("%s turned in %d coupons for %s", ch->name, num, obj->short_descr);
act_info.cpp:           logf("%s turned in %d coupons for %s", ch->name, num, obj->short_descr);
act_info.cpp:  if (ch->pcdata->confirm_pkon)
act_info.cpp:      ch->pcdata->confirm_pkon = FALSE;
act_info.cpp:      REMOVE_BIT(ch->act, PLR_NOPK);
act_info.cpp:      ch->pcdata->confirm_pkon = FALSE;
act_info.cpp:      sprintf(buf, "%s turned on PK.", ch->name);
act_info.cpp:  ch->pcdata->confirm_pkon = TRUE;
act_info.cpp:    sprintf(buf, "RP Note font %s\n\r", ch->pcdata->fonts.rpnote);
act_info.cpp:    sprintf(buf, "Other Note font %s\n\r", ch->pcdata->fonts.notes);
act_info.cpp:    free_string(ch->pcdata->fonts.rpnote);
act_info.cpp:    ch->pcdata->fonts.rpnote = str_dup(argument);
act_info.cpp:    free_string(ch->pcdata->fonts.notes);
act_info.cpp:    ch->pcdata->fonts.notes = str_dup(argument);
act_info.cpp:  if (IS_SET(ch->act, PLR_QUESTING) || IS_SET(ch->act, PLR_TOURNEY))
act_info.cpp:  if (ch->pcdata->names == NULL)
act_info.cpp:  if (!IS_NULLSTR(ch->pcdata->names->name) && !str_cmp(argument, ch->pcdata->names->name))
act_info.cpp:    name = ch->pcdata->names;
act_info.cpp:    ch->pcdata->names = name->next;
act_info.cpp:  for (name = ch->pcdata->names; name != NULL; name = name_next)
act_info.cpp:  for ( cName = ch->pcdata->names; cName; cName = cName->next )
act_info.cpp:     cName->next = ch->pcdata->names;
act_info.cpp:     ch->pcdata->names = cName;
act_info.cpp:	ch->level >= LEVEL_IMMORTAL)
act_info.cpp:      return ch->name;
act_info.cpp:       if ( name->id == ch->id )
act_info.cpp:  return ch->name;
act_info.cpp:    return ch->short_descr;
act_info.cpp:    return IS_DISGUISED(ch) ? ch->pcdata->disguise.orig_name : ch->name;
act_info.cpp:  if ( IS_AFFECTED(ch, AFF_VEIL) && !furies_imm (ch,looker) && ch->clan != looker->clan)
act_info.cpp:  if ( IS_AFFECTED(ch, AFF_SHROUD) && !furies_imm (ch,looker) && (ch->clan != looker->clan ||
act_info.cpp:       (ch->clan == looker->clan && !IS_GUILDMASTER(looker))))
act_info.cpp:    if (IS_SET(ch->act, PLR_QUESTING) && IS_SET(looker->act, PLR_QUESTING))
act_info.cpp:      return ch->name;
act_info.cpp:    if (IS_SET(ch->act, PLR_TOURNEY) && IS_SET(looker->act, PLR_TOURNEY))
act_info.cpp:      return ch->name;
act_info.cpp:      return ch->short_descr;
act_info.cpp:      return ch->name;
act_info.cpp:    if (ch->level >= LEVEL_IMMORTAL)
act_info.cpp:      return ch->name;
act_info.cpp://      return ch->name;
act_info.cpp:              race_table[ch->race].name,
act_info.cpp:              ( ch->sex == SEX_FEMALE ) ? "woman" :
act_info.cpp:              ( ch->sex == SEX_MALE ) ? "man" : "person");
act_info.cpp:    return ch->short_descr;
act_info.cpp:    return ch->name;
act_info.cpp:    if (IS_SET(ch->act, PLR_QUESTING) && IS_SET(looker->act, PLR_QUESTING))
act_info.cpp:      return ch->name;
act_info.cpp:    if (IS_SET(ch->act, PLR_TOURNEY) && IS_SET(looker->act, PLR_TOURNEY))
act_info.cpp:      return ch->name;
act_info.cpp:      return ch->name;
act_info.cpp:    if (ch->level >= LEVEL_IMMORTAL || ch->clan == clan_lookup("Guide"))
act_info.cpp:      return ch->name;
act_info.cpp:      return ch->name;
act_info.cpp:      return ch->name;
act_info.cpp:         if ( name->id == ch->id )
act_info.cpp:              race_table[ch->race].name,
act_info.cpp:              ( ch->sex == SEX_FEMALE ) ? "woman" :
act_info.cpp:              ( ch->sex == SEX_MALE ) ? "man" : "");
act_info.cpp:  for ( vch = voteinfo.voters ; vch != NULL; vch = vch->next)
act_info.cpp:    if ( vch->id == id )
act_info.cpp:      vch->vote = vote;
act_info.cpp:      vch->host = str_dup(host);
act_info.cpp:      vch->reason = reason[0] != '\0' ? str_dup(reason) : str_dup("None");
act_info.cpp:  if (IS_SET(ch->act2, PLR_MXP))
act_info.cpp:    REMOVE_BIT(ch->act2, PLR_MXP);
act_info.cpp:  SET_BIT(ch->act2, PLR_MXP);
act_info.cpp://  if (!IS_SET(ch->enh, ENH_MXP))
act_info.cpp:  for ( vch = voteinfo.voters ; vch != NULL; vch = vch->next)
act_info.cpp:    if ( vch->id == ch->id )
act_info.cpp:      return vch->vote;
act_info.cpp:    if (!str_cmp(vch->host, dns_gethostname(ch->desc->Host)))
act_info.cpp:      for (vch = voteinfo.voters; vch != NULL; vch = vch->next)
act_info.cpp:        if (vch->vote == 0)
act_info.cpp:           sprintf(tmp, "%d - %s\n\r", i, vch->reason);
act_info.cpp:           sprintf(tmp, "%d - %s\n\r", j, vch->reason);
act_info.cpp:      change_vote(dns_gethostname(ch->desc->Host), ch->id, 0, argument);
act_info.cpp:    add_vote(dns_gethostname(ch->desc->Host), ch->id, 0, argument);
act_info.cpp:      change_vote(dns_gethostname(ch->desc->Host), ch->id, 1, argument);
act_info.cpp:    add_vote(dns_gethostname(ch->desc->Host), ch->id, 1, argument);
act_info.cpp:    if (ch->desc == NULL)
act_info.cpp:            if (IS_NPC (ch) || IS_SET (ch->comm, COMM_COMBINE))
act_info.cpp:        if (IS_SET(ch->act2, PLR_MXP))
act_info.cpp:        if (IS_NPC (ch) || IS_SET (ch->comm, COMM_COMBINE))
act_info.cpp:      if (IS_SET(ch->act2, PLR_MXP))
act_info.cpp:        if (IS_NPC (ch) || IS_SET (ch->comm, COMM_COMBINE))
act_info.cpp:    if (IS_NPC(victim) && ch->questmob > 0
act_info.cpp:    && victim->pIndexData->vnum == ch->questmob
act_info.cpp:    && (ch->rescuemob == 0
act_info.cpp:    if (IS_NPC(victim) && ch->questmob > 0 && victim->pIndexData->vnum == ch->questmob 
act_info.cpp:        && (ch->rescuemob == 0 || (victim->fighting && victim->fighting->attacker == victim)))
act_info.cpp:/*    if (!IS_NPC (victim) && !IS_DISGUISED(victim) && !IS_SET (ch->comm, COMM_BRIEF)
act_info.cpp:        && victim->position == POS_STANDING && ch->on == NULL && !IS_SET(ch->act2, PLR_NOTITLE))
act_info.cpp:    if (!IS_SET (victim->act2, PLR_NOEQ) || IS_IMMORTAL(ch) || IS_SET(ch->in_room->room_flags, ROOM_SAFE))
act_info.cpp:    for (rch = list; rch != NULL; rch = rch->next_in_room)
act_info.cpp:        if (get_trust (ch) < rch->invis_level)
act_info.cpp:        else if (room_is_dark (ch->in_room)
act_info.cpp:                if((ch->alignment < 0)
act_info.cpp:                        && (pexit = ch->in_room->exit[door+6] ) != NULL)
act_info.cpp:		was_in_room = ch->in_room;
act_info.cpp:                if( (pexit = ch->in_room->exit[outlet] ) != NULL
act_info.cpp:        for( fch = ch->in_room->people; fch; fch = fch->next_in_room )
act_info.cpp:    if (!IS_NPC (ch) && IS_SET (ch->act, PLR_HOLYLIGHT))
act_info.cpp:        if (ch->lines == 0)
act_info.cpp:                     ch->lines + 2);
act_info.cpp:        ch->lines = 0;
act_info.cpp:    ch->lines = lines - 2;
act_info.cpp:    if (IS_SET (ch->act, PLR_AUTOASSIST))
act_info.cpp:    if (IS_SET (ch->act, PLR_AUTOEXIT))
act_info.cpp:    if (IS_SET (ch->act, PLR_AUTOGOLD))
act_info.cpp:    if (IS_SET (ch->act, PLR_AUTOLOOT))
act_info.cpp:    if (IS_SET (ch->act, PLR_AUTOSAC))
act_info.cpp:    if (IS_SET (ch->act, PLR_AUTOSPLIT))
act_info.cpp:    if (ch->pcdata->barOn)
act_info.cpp:    if (IS_SET (ch->comm, COMM_COMPACT))
act_info.cpp:    if (!IS_SET (ch->act2, PLR_NODAMAGE))
act_info.cpp:    if (!IS_SET (ch->act2, PLR_NOWEAVE))
act_info.cpp:    if (IS_SET (ch->act, PLR_HUNGER_FLAG))
act_info.cpp:    if (IS_SET (ch->comm, COMM_PROMPT))
act_info.cpp:    if (!IS_SET (ch->act2, PLR_NOTITLE))
act_info.cpp:    if (IS_SET (ch->comm, COMM_COMBINE))
act_info.cpp:    if (IS_SET (ch->act, PLR_NOSUMMON))
act_info.cpp:    if (IS_SET (ch->act, PLR_NOFOLLOW))
act_info.cpp:  if (IS_SET(ch->act, PLR_HUNGER_FLAG))
act_info.cpp:    REMOVE_BIT(ch->act, PLR_HUNGER_FLAG);
act_info.cpp:  SET_BIT(ch->act, PLR_HUNGER_FLAG);
act_info.cpp:  if (ch->pcdata->barOn)
act_info.cpp:    ch->pcdata->barOn = FALSE;
act_info.cpp:    ch->pcdata->barOn = TRUE;
act_info.cpp:	if (IS_SET (ch->comm, COMM_TELNET_GA))
act_info.cpp:		REMOVE_BIT (ch->comm, COMM_TELNET_GA);
act_info.cpp:		SET_BIT (ch->comm, COMM_TELNET_GA);
act_info.cpp:    if (IS_SET (ch->act, PLR_AUTOASSIST))
act_info.cpp:        REMOVE_BIT (ch->act, PLR_AUTOASSIST);
act_info.cpp:        SET_BIT (ch->act, PLR_AUTOASSIST);
act_info.cpp:    if (IS_SET (ch->act, PLR_AUTOEXIT))
act_info.cpp:        REMOVE_BIT (ch->act, PLR_AUTOEXIT);
act_info.cpp:        SET_BIT (ch->act, PLR_AUTOEXIT);
act_info.cpp:    if (IS_SET (ch->act, PLR_AUTOGOLD))
act_info.cpp:        REMOVE_BIT (ch->act, PLR_AUTOGOLD);
act_info.cpp:        SET_BIT (ch->act, PLR_AUTOGOLD);
act_info.cpp:    if (IS_SET (ch->act, PLR_AUTOLOOT))
act_info.cpp:        REMOVE_BIT (ch->act, PLR_AUTOLOOT);
act_info.cpp:        SET_BIT (ch->act, PLR_AUTOLOOT);
act_info.cpp:    if (IS_SET (ch->act, PLR_AUTOSAC))
act_info.cpp:        REMOVE_BIT (ch->act, PLR_AUTOSAC);
act_info.cpp:        SET_BIT (ch->act, PLR_AUTOSAC);
act_info.cpp:    if (IS_SET (ch->act, PLR_AUTOSPLIT))
act_info.cpp:        REMOVE_BIT (ch->act, PLR_AUTOSPLIT);
act_info.cpp:        SET_BIT (ch->act, PLR_AUTOSPLIT);
act_info.cpp:        SET_BIT(ch->act,PLR_AUTOASSIST);
act_info.cpp:        SET_BIT(ch->act,PLR_AUTOEXIT);
act_info.cpp:        SET_BIT(ch->act,PLR_AUTOGOLD);
act_info.cpp:        SET_BIT(ch->act,PLR_AUTOLOOT);
act_info.cpp:        SET_BIT(ch->act,PLR_AUTOSAC);
act_info.cpp:        SET_BIT(ch->act,PLR_AUTOSPLIT);
act_info.cpp:        REMOVE_BIT (ch->act, PLR_AUTOASSIST);
act_info.cpp:        REMOVE_BIT (ch->act, PLR_AUTOEXIT);
act_info.cpp:        REMOVE_BIT (ch->act, PLR_AUTOGOLD);
act_info.cpp:        REMOVE_BIT (ch->act, PLR_AUTOLOOT);
act_info.cpp:        REMOVE_BIT (ch->act, PLR_AUTOSAC);
act_info.cpp:        REMOVE_BIT (ch->act, PLR_AUTOSPLIT);
act_info.cpp:    if (IS_SET (ch->comm, COMM_BRIEF))
act_info.cpp:        REMOVE_BIT (ch->comm, COMM_BRIEF);
act_info.cpp:        SET_BIT (ch->comm, COMM_BRIEF);
act_info.cpp:    if (IS_SET (ch->comm, COMM_COMPACT))
act_info.cpp:        REMOVE_BIT (ch->comm, COMM_COMPACT);
act_info.cpp:        SET_BIT (ch->comm, COMM_COMPACT);
act_info.cpp:    if (IS_SET (ch->comm, COMM_SHOW_AFFECTS))
act_info.cpp:        REMOVE_BIT (ch->comm, COMM_SHOW_AFFECTS);
act_info.cpp:        SET_BIT (ch->comm, COMM_SHOW_AFFECTS);
act_info.cpp:        if (IS_SET (ch->comm, COMM_PROMPT))
act_info.cpp:            REMOVE_BIT (ch->comm, COMM_PROMPT);
act_info.cpp:            SET_BIT (ch->comm, COMM_PROMPT);
act_info.cpp:    free_string (ch->prompt);
act_info.cpp:    ch->prompt = str_dup (buf);
act_info.cpp:    sprintf (buf, "Prompt set to %s\n\r", ch->prompt);
act_info.cpp:    if (IS_SET (ch->comm, COMM_COMBINE))
act_info.cpp:        REMOVE_BIT (ch->comm, COMM_COMBINE);
act_info.cpp:        SET_BIT (ch->comm, COMM_COMBINE);
act_info.cpp:    if (IS_SET (ch->act, PLR_NOFOLLOW))
act_info.cpp:        REMOVE_BIT (ch->act, PLR_NOFOLLOW);
act_info.cpp:        SET_BIT (ch->act, PLR_NOFOLLOW);
act_info.cpp:        if (IS_SET (ch->imm_flags, IMM_SUMMON))
act_info.cpp:            REMOVE_BIT (ch->imm_flags, IMM_SUMMON);
act_info.cpp:            SET_BIT (ch->imm_flags, IMM_SUMMON);
act_info.cpp:        if (IS_SET (ch->act, PLR_NOSUMMON))
act_info.cpp:            REMOVE_BIT (ch->act, PLR_NOSUMMON);
act_info.cpp:            SET_BIT (ch->act, PLR_NOSUMMON);
act_info.cpp:    if (ch->desc == NULL)
act_info.cpp:    if (ch->position < POS_SLEEPING)
act_info.cpp:    if (ch->position == POS_SLEEPING)
act_info.cpp:        && !IS_SET (ch->act, PLR_HOLYLIGHT) && room_is_dark (ch->in_room)
act_info.cpp:        && !IS_SET(ch->act2, PLR_DREAM))
act_info.cpp:        show_char_to_char (ch->in_room->people, ch);
act_info.cpp:       if(IS_SET(ch->in_room->room_flags, ROOM_WILDERNESS))
act_info.cpp:           send_to_char (ch->in_room->name, ch);
act_info.cpp:             && (IS_NPC (ch) || IS_SET (ch->act, PLR_HOLYLIGHT)))
act_info.cpp:            || IS_BUILDER (ch, ch->in_room->area))
act_info.cpp:            send_to_char (ch->in_room->name, ch);
act_info.cpp:            sprintf (buf, "`1 [`!Room %ld`1]`*\n\r", ch->in_room->vnum);
act_info.cpp:          if (IS_SET(ch->act2, PLR_MXP))
act_info.cpp:          send_to_char (ch->in_room->name, ch);
act_info.cpp:          if (IS_SET(ch->act2, PLR_MXP))
act_info.cpp:             && (IS_NPC (ch) || IS_SET (ch->act, PLR_HOLYLIGHT)))
act_info.cpp:            || IS_BUILDER (ch, ch->in_room->area))
act_info.cpp:            sprintf (buf, "`1 [`!Room %ld`1]`*", ch->in_room->vnum);
act_info.cpp:        cArea = ch->in_room->area;
act_info.cpp:            || (!IS_NPC (ch) && !IS_SET (ch->comm, COMM_BRIEF) && (str_cmp(arg1, "move")
act_info.cpp:            ||  (ch->desc->out_compress) || IS_IMMORTAL(ch)))
act_info.cpp:            || (IS_SWITCHED(ch) && !IS_SET(ch->desc->original->comm, COMM_BRIEF)))
act_info.cpp:          if (IS_SET(ch->act2, PLR_MXP))
act_info.cpp:          cArea = ch->in_room->area;
act_info.cpp:            sprintf(buf, "`*%s", ch->in_room->description);
act_info.cpp:          if (IS_SET(ch->act2, PLR_MXP))
act_info.cpp:            send_to_char (ch->in_room->description, ch);
act_info.cpp:           || (!IS_NPC(ch) && !IS_SET(ch->comm, COMM_BRIEF)))
act_info.cpp:        if (!IS_NPC (ch) && IS_SET (ch->act, PLR_AUTOEXIT))
act_info.cpp:        if (IS_SWITCHED(ch)  && IS_SET(ch->desc->original->act, PLR_AUTOEXIT))
act_info.cpp:        show_list_to_char (ch->in_room->contents, ch, FALSE, FALSE, ON_GROUND);
act_info.cpp:        show_char_to_char (ch->in_room->people, ch);
act_info.cpp:                   && (IS_NPC (ch) || IS_SET (ch->act, PLR_HOLYLIGHT)))
act_info.cpp:                  || (!IS_NPC (ch) && !IS_SET (ch->comm, COMM_BRIEF))
act_info.cpp:                  || (IS_SWITCHED(ch) && !IS_SET(ch->desc->original->comm, COMM_BRIEF)) )
act_info.cpp:                    || (!IS_NPC(ch) && !IS_SET(ch->comm, COMM_BRIEF)))
act_info.cpp:                     || (!IS_NPC(ch) && !IS_SET(ch->comm, COMM_BRIEF)))
act_info.cpp:                 if (!IS_NPC (ch) && IS_SET (ch->act, PLR_AUTOEXIT))
act_info.cpp:	for (obj = ch->in_room->contents; obj != NULL; obj = obj->next_content)
act_info.cpp:    for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
act_info.cpp:    pdesc = get_extra_descr (arg3, ch->in_room->extra_descr);
act_info.cpp:    if ((pexit = ch->in_room->exit[door]) == NULL)
act_info.cpp:        sprintf (buf, "Obvious exits from room %ld:\n\r", ch->in_room->vnum);
act_info.cpp:    if (IS_SET(ch->act2, PLR_MXP))
act_info.cpp:        if ((pexit = ch->in_room->exit[door]) != NULL
act_info.cpp:                if (IS_SET(ch->act2, PLR_MXP))
act_info.cpp:    if (IS_SET(ch->act2, PLR_MXP))
act_info.cpp:                 ch->gold, ch->silver);
act_info.cpp:    if (ch->level >= 75)
act_info.cpp:             ch->questpoints, ch->gold, ch->silver, ch->realexp);
act_info.cpp:             ch->questpoints, ch->gold, ch->silver, ch->exp,
act_info.cpp:             (ch->level + 1) * exp_per_level (ch,
act_info.cpp:                                              ch->pcdata->points) - ch->exp);
act_info.cpp:	int rptnl = 1000 + (ch->rplevel*100); /*If you change you must change in update.c -CAMM*/
act_info.cpp:             IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name,
act_info.cpp:             IS_DISGUISED(ch)?ch->pcdata->disguise.orig_title:ch->pcdata->title);
act_info.cpp:if (ch->clan != 0)
act_info.cpp:             clan_table[ch->clan].who_name,
act_info.cpp:             clan_table[ch->clan].rank[ch->rank]);
act_info.cpp:             ch->hit, ch->max_hit);
act_info.cpp:             ch->mana, ch->max_mana);
act_info.cpp:             ch->pcdata->tournament.kills,
act_info.cpp:             ch->pcdata->tournament.deaths);
act_info.cpp:             ch->move, ch->max_move);
act_info.cpp:             ch->pcdata->tournament.reputation);
act_info.cpp:             ch->level, ch->carry_number, can_carry_n (ch));
act_info.cpp:             ch->exp, (ch->level + 1) * exp_per_level (ch, ch->pcdata->points) - ch->exp);
act_info.cpp:             (ch->played + (int) (current_time - ch->logon)) / 3600,ch->rplevel);
act_info.cpp:             race_table[ch->race].name,ch->rpexp,rptnl);
act_info.cpp:             ch->sex == 0 ? "sexless" : ch->sex == 1 ? "male" : "female",
act_info.cpp:             ch->rp_points);
act_info.cpp:             IS_NPC (ch) ? "mobile" : class_table[ch->cClass].name,
act_info.cpp:             ch->alignment);
act_info.cpp:if (ch->alignment > 900)
act_info.cpp:    else if (ch->alignment > 700)
act_info.cpp:    else if (ch->alignment > 350)
act_info.cpp:    else if (ch->alignment > 100)
act_info.cpp:    else if (ch->alignment > -100)
act_info.cpp:    else if (ch->alignment > -350)
act_info.cpp:    else if (ch->alignment > -700)
act_info.cpp:    else if (ch->alignment > -900)
act_info.cpp:             ch->train,(double(roomcount(ch)) / top_room));
act_info.cpp:             ch->practice,(double(mobcount(ch)) / top_mob_index));
act_info.cpp:             ch->wimpy,ch->gold);
act_info.cpp:    case (ch->pcdata->pk_timer > 0)
act_info.cpp:        sprintf(buf, "`$PK Ticks   `4: `!$-15d`*", ch->pcdata->pk_timer);
act_info.cpp:             ch->questpoints,ch->silver);
act_info.cpp:             UMIN( ch->perm_stat[STAT_STR], 25),
act_info.cpp:             UMIN( ch->perm_stat[STAT_INT], 25),
act_info.cpp:             UMIN( ch->perm_stat[STAT_WIS], 25),
act_info.cpp:             UMIN( ch->perm_stat[STAT_DEX], 25),
act_info.cpp:             UMIN( ch->perm_stat[STAT_CON], 25),
act_info.cpp:             ch->saving_throw,GET_AC (ch, AC_SLASH));
act_info.cpp:        if (IS_SET (ch->act, PLR_HOLYLIGHT))
act_info.cpp:if (get_trust (ch) != ch->level)
act_info.cpp:if (!IS_NPC (ch) && ch->pcdata->condition[COND_DRUNK] > 10)
act_info.cpp:switch (ch->position)
act_info.cpp:if (ch->incog_level)
act_info.cpp:    sprintf (buf, "Incognito: level %d", ch->incog_level);
act_info.cpp:if (IS_SET (ch->comm, COMM_SHOW_AFFECTS))
act_info.cpp:    if (ch->affected != NULL)
act_info.cpp:        for (paf = ch->affected; paf != NULL; paf = paf->next)
act_info.cpp:                if (ch->level >= 0)
act_info.cpp:            if (ch->level >= 0)
act_info.cpp:            if (ch->desc != NULL && ch->desc->connected != CON_PLAYING
act_info.cpp:                && ch->desc->connected != CON_GEN_GROUPS)
act_info.cpp:            if (ch->desc != NULL && ch->desc->connected != CON_PLAYING
act_info.cpp:                && ch->desc->connected != CON_GEN_GROUPS)
act_info.cpp:if (wch->murd > 0)
act_info.cpp:  if (ch->level < 11)
act_info.cpp:  else if (ch->level < 16)
act_info.cpp:  else if (ch->level < 26)
act_info.cpp:  else if (ch->level < 36)
act_info.cpp:  else if (ch->level < 46)
act_info.cpp:  else if (ch->level < 56)
act_info.cpp:  else if (ch->level < 66)
act_info.cpp:  else if (ch->level < LEVEL_IMMORTAL)
act_info.cpp:  if (wch->level >= LEVEL_IMMORTAL)
act_info.cpp:  if (wch->clan == clan_lookup("tinker") || wch->clan == clan_lookup("tinker") || IS_SET(wch->act, PLR_NOPK))
act_info.cpp:  if (ch->level - wch->level > change)
act_info.cpp:				if(!str_prefix(arg, wch->name))
act_info.cpp:					        cClass = class_table[wch->cClass].who_name;
act_info.cpp:							switch (wch->level)
act_info.cpp:					if (strlen(wch->description) >1 && wch->description != NULL)
act_info.cpp:					 sprintf(buf, "                              `&%s`7", wch->name);
act_info.cpp:					 sprintf(buf, "%s", wch->description);
act_info.cpp:    if (wch->level > 77)
act_info.cpp:                 ((IS_IMMORTAL(ch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:                 || (IS_IMMORTAL(wch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:                 || (str_cmp(clan_table[wch->clan].who_name, "None")
act_info.cpp:                    && ((IS_GUILDED(wch) && IS_GUILDED(ch) && ch->clan == wch->clan)
act_info.cpp:                    || (ch->clan == clan_lookup("Warder") && wch->clan == clan_lookup("aessedai"))
act_info.cpp:                    || (ch->clan == clan_lookup("aessedai") && wch->clan == clan_lookup("Warder"))
act_info.cpp:                    || (wch->clan == clan_lookup("Furies"))))) ? clan_table[wch->clan].who_name : "",
act_info.cpp:                 IS_SET(wch->act, PLR_QUESTING) ? "`$(`&QUEST`$)`* " : "",
act_info.cpp:                 IS_SET(wch->act2, PLR_WAR) ? "`8(`&W`7A`&R`8)`* " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_TAG) ? "`8(`!TAG`8)`7 " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_IT) ? " `8(`$IT`8)`7 " : "",
act_info.cpp:                 wch->incog_level >= LEVEL_HERO ? "`7(`6Incog`7) " : "",
act_info.cpp:                 wch->invis_level >= LEVEL_HERO ? "`7(`5Wizi`7) " : "",
act_info.cpp:                 IS_SET (wch->comm, COMM_AFK) ? "`7(`^AFK`7) " : "",
act_info.cpp:				 IS_SET(wch->act, PLR_TOURNEY) ? "`&(`#TOURNEY`&)`* " : "",
act_info.cpp:                 wch->desc->editor > 0 && wch->desc->editor != ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$OLC`&)`* " : "" : "",
act_info.cpp:                 wch->desc->editor == ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$STORE`&)`* " : "" : "",
act_info.cpp:                 IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_name : wch->name,
act_info.cpp:		 IS_NPC (wch) ? "" : IS_SET(ch->act2, PLR_NOTITLE) ?
act_info.cpp:                              "" : IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_title:wch->pcdata->title);
act_info.cpp:      if (wch->level < 10)
act_info.cpp:                 ((IS_IMMORTAL(ch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:                 || (IS_IMMORTAL(wch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:                 || (str_cmp(clan_table[wch->clan].who_name, "None")
act_info.cpp:                    && ((IS_GUILDED(wch) && IS_GUILDED(ch) && ch->clan == wch->clan)
act_info.cpp:                    || (ch->clan == clan_lookup("Warder") && wch->clan == clan_lookup("aessedai"))
act_info.cpp:                    || (ch->clan == clan_lookup("aessedai") && wch->clan == clan_lookup("Warder"))
act_info.cpp:                    || (wch->clan == clan_lookup("Furies"))))) ? clan_table[wch->clan].who_name : "",
act_info.cpp:                 IS_SET(wch->act, PLR_QUESTING) ? "`$(`&QUEST`$)`* " : "",
act_info.cpp:                 IS_SET(wch->act2, PLR_WAR) ? "`8(`&W`7A`&R`8)`* " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_TAG) ? "`8(`!TAG`8)`7 " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_IT) ? " `8(`$IT`8)`7 " : "",
act_info.cpp:                 wch->incog_level >= LEVEL_HERO ? "`7(`6I`7) " : "",
act_info.cpp:                 wch->invis_level >= LEVEL_HERO ? "`7(`5W`7)`7 " : "",
act_info.cpp:                 IS_SET (wch->comm, COMM_AFK) ? "`7(`^AFK`7) " : "",
act_info.cpp:				 IS_SET(wch->act, PLR_TOURNEY) ? "`&(`#TOURNEY`&)`* " : "",
act_info.cpp:                 wch->desc->editor > 0 && wch->desc->editor != ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$OLC`&)`* " : "" : "",
act_info.cpp:                 wch->desc->editor == ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$STORE`&)`* " : "" : "",
act_info.cpp:                 IS_DISGUISED(wch)?wch->pcdata->disguise.orig_name:wch->name,
act_info.cpp:                 IS_NPC (wch) ? "" : IS_SET(ch->act2, PLR_NOTITLE) ?
act_info.cpp:                 "" : IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_title:wch->pcdata->title);
act_info.cpp:				if (wch->level == 76 || wch->level == 77)
act_info.cpp:					 ((IS_IMMORTAL(ch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:					 || (IS_IMMORTAL(wch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:					 || (str_cmp(clan_table[wch->clan].who_name, "None")
act_info.cpp:						&& ((IS_GUILDED(wch) && IS_GUILDED(ch) && ch->clan == wch->clan)
act_info.cpp:                    || (ch->clan == clan_lookup("Warder") && wch->clan == clan_lookup("aessedai"))
act_info.cpp:                    || (ch->clan == clan_lookup("aessedai") && wch->clan == clan_lookup("Warder"))
act_info.cpp:						|| (wch->clan == clan_lookup("Furies"))))) ? clan_table[wch->clan].who_name : "",
act_info.cpp:					 IS_SET(wch->act, PLR_QUESTING) ? "`$(`&QUEST`$)`* " : "",
act_info.cpp:					 IS_SET(wch->act2, PLR_WAR) ? "`8(`&W`7A`&R`8)`* " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_TAG) ? "`8(`!TAG`8)`7 " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_IT) ? " `8(`$IT`8)`7 " : "",
act_info.cpp:					 wch->incog_level >= LEVEL_HERO ? "`7(`6Incog`7) " : "",
act_info.cpp:					 wch->invis_level >= LEVEL_HERO ? "`7(`5Wizi`7) " : "",
act_info.cpp:					 IS_SET (wch->comm, COMM_AFK) ? "`7(`^AFK`7) " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_TOURNEY) ? "`&(`#TOURNEY`&)`* " : "",
act_info.cpp:					 wch->desc->editor > 0 && wch->desc->editor != ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$OLC`&)`* " : "" : "",
act_info.cpp:					 wch->desc->editor == ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$STORE`&)`* " : "" : "",
act_info.cpp:					 IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_name : wch->name,
act_info.cpp:					 IS_NPC (wch) ? "" : IS_SET(ch->act2, PLR_NOTITLE) ?
act_info.cpp:					 "" : IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_title:wch->pcdata->title);
act_info.cpp:		  		else if (wch->level == 75)
act_info.cpp:					 class_table[wch->cClass].who_name,
act_info.cpp:					 ((IS_IMMORTAL(ch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:					 || (IS_IMMORTAL(wch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:					 || (str_cmp(clan_table[wch->clan].who_name, "None")
act_info.cpp:						&& ((IS_GUILDED(wch) && IS_GUILDED(ch) && ch->clan == wch->clan)
act_info.cpp:                    || (ch->clan == clan_lookup("Warder") && wch->clan == clan_lookup("aessedai"))
act_info.cpp:                    || (ch->clan == clan_lookup("aessedai") && wch->clan == clan_lookup("Warder"))
act_info.cpp:						|| (wch->clan == clan_lookup("Furies"))))) ? clan_table[wch->clan].who_name : "",
act_info.cpp:					 IS_SET(wch->act, PLR_QUESTING) ? "`$(`&QUEST`$)`* " : "",
act_info.cpp:					 IS_SET(wch->act2, PLR_WAR) ? "`8(`&W`7A`&R`8)`* " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_TAG) ? "`8(`!TAG`8)`7 " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_IT) ? " `8(`$IT`8)`7 " : "",
act_info.cpp:					 wch->incog_level >= LEVEL_HERO ? "`7(`6I`7) " : "",
act_info.cpp:					 wch->invis_level >= LEVEL_HERO ? "`7(`5W`7)`7 " : "",
act_info.cpp:					 IS_SET (wch->comm, COMM_AFK) ? "`7(`^AFK`7) " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_TOURNEY) ? "`&(`#TOURNEY`&)`* " : "",
act_info.cpp:					 wch->desc->editor > 0 && wch->desc->editor != ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$OLC`&)`* " : "" : "",
act_info.cpp:					 wch->desc->editor == ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$STORE`&)`* " : "" : "",
act_info.cpp:					 IS_DISGUISED(wch)?wch->pcdata->disguise.orig_name:wch->name,
act_info.cpp:					 IS_NPC (wch) ? "" : IS_SET(ch->act2, PLR_NOTITLE) ?
act_info.cpp:					 "" : IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_title:wch->pcdata->title);
act_info.cpp:					 class_table[wch->cClass].who_name,
act_info.cpp:					 ((IS_IMMORTAL(ch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:					 || (IS_IMMORTAL(wch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:					 || (str_cmp(clan_table[wch->clan].who_name, "None")
act_info.cpp:						&& ((IS_GUILDED(wch) && IS_GUILDED(ch) && ch->clan == wch->clan)
act_info.cpp:                    || (ch->clan == clan_lookup("Warder") && wch->clan == clan_lookup("aessedai"))
act_info.cpp:                    || (ch->clan == clan_lookup("aessedai") && wch->clan == clan_lookup("Warder"))
act_info.cpp:						|| (wch->clan == clan_lookup("Furies"))))) ? clan_table[wch->clan].who_name : "",
act_info.cpp:					 IS_SET(wch->act, PLR_QUESTING) ? "`$(`&QUEST`$)`* " : "",
act_info.cpp:					 IS_SET(wch->act2, PLR_WAR) ? "`8(`&W`7A`&R`8)`* " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_TAG) ? "`8(`!TAG`8)`7 " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_IT) ? " `8(`$IT`8)`7 " : "",
act_info.cpp:					 wch->incog_level >= LEVEL_HERO ? "`7(`6I`7) " : "",
act_info.cpp:					 wch->invis_level >= LEVEL_HERO ? "`7(`5W`7)`7 " : "",
act_info.cpp:					 IS_SET (wch->comm, COMM_AFK) ? "`7(`^AFK`7) " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_TOURNEY) ? "`&(`#TOURNEY`&)`* " : "",
act_info.cpp:					 wch->desc->editor > 0 && wch->desc->editor != ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$OLC`&)`* " : "" : "",
act_info.cpp:					 wch->desc->editor == ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$STORE`&)`* " : "" : "",
act_info.cpp:					 IS_DISGUISED(wch)?wch->pcdata->disguise.orig_name:wch->name,
act_info.cpp:					 IS_NPC (wch) ? "" : IS_SET(ch->act2, PLR_NOTITLE) ?
act_info.cpp:					 "" : IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_title:wch->pcdata->title);
act_info.cpp:					 sprintf(buf, "\n\r`8[ `&Level `8] `7%d\n\r`8[ `&Class `8] `7%s\n\r`8[ `&Honor `8] `7%d\n\r", wch->level, class_table[wch->cClass].name,wch->honor);
act_info.cpp:        if (wch->level < iLevelLower
act_info.cpp:            || wch->level > iLevelUpper
act_info.cpp:            || (fImmortalOnly && wch->level < LEVEL_IMMORTAL)
act_info.cpp:            || (fClassRestrict && !rgfClass[wch->cClass])
act_info.cpp:            || (fRaceRestrict && !rgfRace[wch->race])
act_info.cpp:            || (grep && str_prefix(arg, wch->name))
act_info.cpp:            || (fClanRestrict && !rgfClan[wch->clan])
act_info.cpp:            || (fQuestRestrict && !IS_SET(wch->act, PLR_QUESTING))
act_info.cpp:            || (fTournRestrict && !IS_SET(wch->act, PLR_TOURNEY)))
act_info.cpp:        cClass = class_table[wch->cClass].who_name;
act_info.cpp:        switch (wch->level)
act_info.cpp:         if (wch->level >= LEVEL_IMMORTAL && !IS_NULLSTR(wch->pretit))
act_info.cpp:           preTitleLen = colorstrlen(wch->pretit);
act_info.cpp:           sprintf(temp, "%*s%s%*s", front, "", wch->pretit, back, "");
act_info.cpp:    if (wch->level > 77)
act_info.cpp:                 ((IS_IMMORTAL(ch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:                 || (IS_IMMORTAL(wch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:                 || (str_cmp(clan_table[wch->clan].who_name, "None")
act_info.cpp:                    && ((IS_GUILDED(wch) && IS_GUILDED(ch) && ch->clan == wch->clan)
act_info.cpp:                    || (ch->clan == clan_lookup("Warder") && wch->clan == clan_lookup("aessedai"))
act_info.cpp:                    || (ch->clan == clan_lookup("aessedai") && wch->clan == clan_lookup("Warder"))
act_info.cpp:                    || (wch->clan == clan_lookup("Furies"))))) ? clan_table[wch->clan].who_name : "",
act_info.cpp:                 IS_SET(wch->act, PLR_QUESTING) ? "`$(`&QUEST`$)`* " : "",
act_info.cpp:                 IS_SET(wch->act2, PLR_WAR) ? "`8(`&W`7A`&R`8)`* " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_TAG) ? "`8(`!TAG`8)`7 " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_IT) ? " `8(`$IT`8)`7 " : "",
act_info.cpp:                 wch->incog_level >= LEVEL_HERO ? "`7(`6Incog`7) " : "",
act_info.cpp:                 wch->invis_level >= LEVEL_HERO ? "`7(`5Wizi`7) " : "",
act_info.cpp:                 IS_SET (wch->comm, COMM_AFK) ? "`7(`^AFK`7) " : "",
act_info.cpp:				 IS_SET(wch->act, PLR_TOURNEY) ? "`&(`#TOURNEY`&)`* " : "",
act_info.cpp:                 wch->desc->editor > 0 && wch->desc->editor != ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$OLC`&)`* " : "" : "",
act_info.cpp:                 wch->desc->editor == ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$STORE`&)`* " : "" : "",
act_info.cpp:                 IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_name : wch->name,
act_info.cpp:		 IS_NPC (wch) ? "" : IS_SET(ch->act2, PLR_NOTITLE) ?
act_info.cpp:                              "" : IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_title:wch->pcdata->title);
act_info.cpp:      if (wch->level < 10)
act_info.cpp:                 ((IS_IMMORTAL(ch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:                 || (IS_IMMORTAL(wch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:                 || (str_cmp(clan_table[wch->clan].who_name, "None")
act_info.cpp:                    && ((IS_GUILDED(wch) && IS_GUILDED(ch) && ch->clan == wch->clan)
act_info.cpp:                    || (ch->clan == clan_lookup("Warder") && wch->clan == clan_lookup("aessedai"))
act_info.cpp:                    || (ch->clan == clan_lookup("aessedai") && wch->clan == clan_lookup("Warder"))
act_info.cpp:                    || (wch->clan == clan_lookup("Furies"))))) ? clan_table[wch->clan].who_name : "",
act_info.cpp:                 IS_SET(wch->act, PLR_QUESTING) ? "`$(`&QUEST`$)`* " : "",
act_info.cpp:                 IS_SET(wch->act2, PLR_WAR) ? "`8(`&W`7A`&R`8)`* " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_TAG) ? "`8(`!TAG`8)`7 " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_IT) ? " `8(`$IT`8)`7 " : "",
act_info.cpp:                 wch->incog_level >= LEVEL_HERO ? "`7(`6I`7) " : "",
act_info.cpp:                 wch->invis_level >= LEVEL_HERO ? "`7(`5W`7)`7 " : "",
act_info.cpp:                 IS_SET (wch->comm, COMM_AFK) ? "`7(`^AFK`7) " : "",
act_info.cpp:				 IS_SET(wch->act, PLR_TOURNEY) ? "`&(`#TOURNEY`&)`* " : "",
act_info.cpp:                 wch->desc->editor > 0 && wch->desc->editor != ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$OLC`&)`* " : "" : "",
act_info.cpp:                 wch->desc->editor == ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$STORE`&)`* " : "" : "",
act_info.cpp:                 IS_DISGUISED(wch)?wch->pcdata->disguise.orig_name:wch->name,
act_info.cpp:                 IS_NPC (wch) ? "" : IS_SET(ch->act2, PLR_NOTITLE) ?
act_info.cpp:                 "" : IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_title:wch->pcdata->title);
act_info.cpp:				if (wch->level == 76 || wch->level == 77)
act_info.cpp:					 ((IS_IMMORTAL(ch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:					 || (IS_IMMORTAL(wch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:					 || (str_cmp(clan_table[wch->clan].who_name, "None")
act_info.cpp:						&& ((IS_GUILDED(wch) && IS_GUILDED(ch) && ch->clan == wch->clan)
act_info.cpp:                    || (ch->clan == clan_lookup("Warder") && wch->clan == clan_lookup("aessedai"))
act_info.cpp:                    || (ch->clan == clan_lookup("aessedai") && wch->clan == clan_lookup("Warder"))
act_info.cpp:						|| (wch->clan == clan_lookup("Furies"))))) ? clan_table[wch->clan].who_name : "",
act_info.cpp:					 IS_SET(wch->act, PLR_QUESTING) ? "`$(`&QUEST`$)`* " : "",
act_info.cpp:					 IS_SET(wch->act2, PLR_WAR) ? "`8(`&W`7A`&R`8)`* " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_TAG) ? "`8(`!TAG`8)`7 " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_IT) ? " `8(`$IT`8)`7 " : "",
act_info.cpp:					 wch->incog_level >= LEVEL_HERO ? "`7(`6Incog`7) " : "",
act_info.cpp:					 wch->invis_level >= LEVEL_HERO ? "`7(`5Wizi`7) " : "",
act_info.cpp:					 IS_SET (wch->comm, COMM_AFK) ? "`7(`^AFK`7) " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_TOURNEY) ? "`&(`#TOURNEY`&)`* " : "",
act_info.cpp:					 wch->desc->editor > 0 && wch->desc->editor != ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$OLC`&)`* " : "" : "",
act_info.cpp:					 wch->desc->editor == ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$STORE`&)`* " : "" : "",
act_info.cpp:					 IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_name : wch->name,
act_info.cpp:					 IS_NPC (wch) ? "" : IS_SET(ch->act2, PLR_NOTITLE) ?
act_info.cpp:					 "" : IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_title:wch->pcdata->title);
act_info.cpp:		  		else if (wch->level == 75)
act_info.cpp:					 class_table[wch->cClass].who_name,
act_info.cpp:					 ((IS_IMMORTAL(ch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:					 || (IS_IMMORTAL(wch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:					 || (str_cmp(clan_table[wch->clan].who_name, "None")
act_info.cpp:						&& ((IS_GUILDED(wch) && IS_GUILDED(ch) && ch->clan == wch->clan)
act_info.cpp:                    || (ch->clan == clan_lookup("Warder") && wch->clan == clan_lookup("aessedai"))
act_info.cpp:                    || (ch->clan == clan_lookup("aessedai") && wch->clan == clan_lookup("Warder"))
act_info.cpp:						|| (wch->clan == clan_lookup("Furies"))))) ? clan_table[wch->clan].who_name : "",
act_info.cpp:					 IS_SET(wch->act, PLR_QUESTING) ? "`$(`&QUEST`$)`* " : "",
act_info.cpp:					 IS_SET(wch->act2, PLR_WAR) ? "`8(`&W`7A`&R`8)`* " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_TAG) ? "`8(`!TAG`8)`7 " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_IT) ? " `8(`$IT`8)`7 " : "",
act_info.cpp:					 wch->incog_level >= LEVEL_HERO ? "`7(`6I`7) " : "",
act_info.cpp:					 wch->invis_level >= LEVEL_HERO ? "`7(`5W`7)`7 " : "",
act_info.cpp:					 IS_SET (wch->comm, COMM_AFK) ? "`7(`^AFK`7) " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_TOURNEY) ? "`&(`#TOURNEY`&)`* " : "",
act_info.cpp:					 wch->desc->editor > 0 && wch->desc->editor != ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$OLC`&)`* " : "" : "",
act_info.cpp:					 wch->desc->editor == ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$STORE`&)`* " : "" : "",
act_info.cpp:					 IS_DISGUISED(wch)?wch->pcdata->disguise.orig_name:wch->name,
act_info.cpp:					 IS_NPC (wch) ? "" : IS_SET(ch->act2, PLR_NOTITLE) ?
act_info.cpp:					 "" : IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_title:wch->pcdata->title);
act_info.cpp:					 class_table[wch->cClass].who_name,
act_info.cpp:					 ((IS_IMMORTAL(ch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:					 || (IS_IMMORTAL(wch) && str_cmp(clan_table[wch->clan].who_name, "None"))
act_info.cpp:					 || (str_cmp(clan_table[wch->clan].who_name, "None")
act_info.cpp:						&& ((IS_GUILDED(wch) && IS_GUILDED(ch) && ch->clan == wch->clan)
act_info.cpp:                    || (ch->clan == clan_lookup("Warder") && wch->clan == clan_lookup("aessedai"))
act_info.cpp:                    || (ch->clan == clan_lookup("aessedai") && wch->clan == clan_lookup("Warder"))
act_info.cpp:						|| (wch->clan == clan_lookup("Furies"))))) ? clan_table[wch->clan].who_name : "",
act_info.cpp:					 IS_SET(wch->act, PLR_QUESTING) ? "`$(`&QUEST`$)`* " : "",
act_info.cpp:					 IS_SET(wch->act2, PLR_WAR) ? "`8(`&W`7A`&R`8)`* " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_TAG) ? "`8(`!TAG`8)`7 " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_IT) ? " `8(`$IT`8)`7 " : "",
act_info.cpp:					 wch->incog_level >= LEVEL_HERO ? "`7(`6I`7) " : "",
act_info.cpp:					 wch->invis_level >= LEVEL_HERO ? "`7(`5W`7)`7 " : "",
act_info.cpp:					 IS_SET (wch->comm, COMM_AFK) ? "`7(`^AFK`7) " : "",
act_info.cpp:					 IS_SET(wch->act, PLR_TOURNEY) ? "`&(`#TOURNEY`&)`* " : "",
act_info.cpp:					 wch->desc->editor > 0 && wch->desc->editor != ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$OLC`&)`* " : "" : "",
act_info.cpp:					 wch->desc->editor == ED_STORE ? IS_IMMORTAL(ch) ? "`&(`$STORE`&)`* " : "" : "",
act_info.cpp:					 IS_DISGUISED(wch)?wch->pcdata->disguise.orig_name:wch->name,
act_info.cpp:					 IS_NPC (wch) ? "" : IS_SET(ch->act2, PLR_NOTITLE) ?
act_info.cpp:					 "" : IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_title:wch->pcdata->title);
act_info.cpp:        if (wch->level < iLevelLower
act_info.cpp:            || wch->level > iLevelUpper
act_info.cpp:            || (fImmortalOnly && wch->level < LEVEL_IMMORTAL)
act_info.cpp:            || (fClassRestrict && !rgfClass[wch->cClass])
act_info.cpp:            || (grep && str_prefix(arg, wch->name))
act_info.cpp:            || (fClanRestrict && !rgfClan[wch->clan]))
act_info.cpp:        cClass = class_table[wch->cClass].who_name;
act_info.cpp:        switch (wch->level)
act_info.cpp:if (ch->level < 11)
act_info.cpp:else if (ch->level < 16)
act_info.cpp:else if (ch->level < 26)
act_info.cpp:else if (ch->level < 36)
act_info.cpp:else if (ch->level < 46)
act_info.cpp:else if (ch->level < 56)
act_info.cpp:else if (ch->level < 66)
act_info.cpp:else if (ch->level <= 76)
act_info.cpp:  if (ch->level - wch->level > change || wch->level < 11)
act_info.cpp:  if (wch->level > 75)
act_info.cpp: if (wch->clan == clan_lookup("tinker"))
act_info.cpp: if (wch->clan == clan_lookup("jenn"))
act_info.cpp:  if (wch->clan != 0)
act_info.cpp:    length = (15 - colorstrlen(clan_table[wch->clan].who_name)) / 2;
act_info.cpp:  if ((15 - colorstrlen(clan_table[wch->clan].who_name)) % 2 != 0)
act_info.cpp:if (wch->level > 75)
act_info.cpp:                 wch->clan == 0 ? "" : clan_table[wch->clan].who_name,
act_info.cpp:                 IS_SET(wch->act, PLR_QUESTING) ? "`$(`&QUEST`$)`* " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_TOURNEY) ? "`&(`#TOURNEY`&)`* " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_TAG) ? "`8(`!TAG`8)`7 " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_IT) ? " `8(`$IT`8)`7 " : "",
act_info.cpp:                 wch->incog_level >= LEVEL_HERO ? "`7(`6I`7) " : "",
act_info.cpp:                 wch->invis_level >= LEVEL_HERO ? "`7(`5W`7) " : "",
act_info.cpp:                 IS_SET (wch->comm, COMM_AFK) ? "`7(`^AFK`7) " : "",
act_info.cpp:                 wch->desc->editor > 0 ? IS_IMMORTAL(ch) ? "`&(`$OLC`&)`* " : "" : "", */
act_info.cpp:                 IS_DISGUISED(wch)?wch->pcdata->disguise.orig_name:wch->name, IS_NPC (wch) ? "" : IS_SET(ch->act2, PLR_NOTITLE) ?
act_info.cpp:                              "" : IS_DISGUISED(wch)?wch->pcdata->disguise.orig_title:wch->pcdata->title);
act_info.cpp:else if (wch->level <= 75)
act_info.cpp:                 wch->level,
act_info.cpp:                 wch->rplevel,
act_info.cpp:                 wch->clan == 0 ? "" : clan_table[wch->clan].who_name,
act_info.cpp:                 IS_SET(wch->act, PLR_QUESTING) ? "`$(`&QUEST`$)`* " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_TOURNEY) ? "`&(`#TOURNEY`&)`* " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_TAG) ? "`8(`!TAG`8)`7 " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_IT) ? " `8(`$IT`8)`7 " : "",
act_info.cpp:                 wch->incog_level >= LEVEL_HERO ? "`7(`6I`7) " : "",
act_info.cpp:                 wch->invis_level >= LEVEL_HERO ? "`7(`5W`7)`7 " : "",
act_info.cpp:                 IS_SET (wch->comm, COMM_AFK) ? "`7(`^AFK`7) " : "",
act_info.cpp:                 wch->desc->editor > 0 ? IS_IMMORTAL(ch) ? "`&(`$OLC`&)`* " : "" : "", */
act_info.cpp:                 wch->name, IS_NPC (wch) ? "" : IS_SET(ch->act2, PLR_NOTITLE) ?
act_info.cpp:                              "" : wch->pcdata->title);
act_info.cpp:                 wch->level,
act_info.cpp:                 wch->rplevel,
act_info.cpp:                 IS_SET(wch->act, PLR_QUESTING) ? "`$(`&QUEST`$)`* " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_TOURNEY) ? "`&(`#TOURNEY`&)`* " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_WAR) ? "`8(`&W`7A`&R`8)`* " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_TAG) ? "`8(`!TAG`8)`7 " : "",
act_info.cpp:                 IS_SET(wch->act, PLR_IT) ? " `8(`$IT`8)`7 " : "",
act_info.cpp:                 wch->incog_level >= LEVEL_HERO ? "`7(`6I`7) " : "",
act_info.cpp:                 wch->invis_level >= LEVEL_HERO ? "`7(`5W`7)`7 " : "",
act_info.cpp:                 IS_SET (wch->comm, COMM_AFK) ? "`7(`^AFK`7) " : "",
act_info.cpp:                 wch->desc->editor > 0 ? IS_IMMORTAL(ch) ? "`&(`$OLC`&)`* " : "" : "",
act_info.cpp:                 wch->name, IS_NPC (wch) ? "" : IS_SET(ch->act2, PLR_NOTITLE) ?
act_info.cpp:                              "" : wch->pcdata->title);
act_info.cpp:    show_list_to_char (ch->carrying, ch, TRUE, TRUE, ON_INVENTORY);
act_info.cpp:        for (obj2 = ch->carrying; obj2 != NULL; obj2 = obj2->next_content)
act_info.cpp:    sprintf(buf, "You are currently in %s\n\r", ch->in_room->area->name);
act_info.cpp:                && victim->in_room->area == ch->in_room->area
act_info.cpp:                && victim->in_room->area == ch->in_room->area
act_info.cpp:    diff = victim->level - ch->level;
act_info.cpp:    free_string (ch->pcdata->title);
act_info.cpp:    ch->pcdata->title = str_dup (buf);
act_info.cpp:    if IS_SET(ch->comm, COMM_NOEMOTE)
act_info.cpp:      string_append(ch, &ch->description);
act_info.cpp:      if (strlen(ch->description) > 2048)
act_info.cpp:        ch->description[1025] = '\0';
act_info.cpp:      ch->description = format_string(ch->description);
act_info.cpp:            if (ch->description == NULL || ch->description[0] == '\0')
act_info.cpp:            strcpy (buf, ch->description);
act_info.cpp:                        free_string (ch->description);
act_info.cpp:                        ch->description = str_dup (buf);
act_info.cpp:                        send_to_char (ch->description ? ch->description :
act_info.cpp:            free_string (ch->description);
act_info.cpp:            ch->description = str_dup (buf);
act_info.cpp:            if (ch->description != NULL)
act_info.cpp:                strcat (buf, ch->description);
act_info.cpp:        free_string (ch->description);
act_info.cpp:        ch->description = str_dup (buf);
act_info.cpp:    send_to_char (ch->description ? ch->description : "(None).\n\r", ch);
act_info.cpp:             ch->hit, ch->max_hit,
act_info.cpp:             ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp);
act_info.cpp:             ch->hit, ch->max_hit,
act_info.cpp:             ch->mana, ch->max_mana, ch->move, ch->max_move, ch->exp);
act_info.cpp:            if (ch->level < skill_table[sn].skill_level[ch->cClass]
act_info.cpp:               || ch->pcdata->learned[sn] < 1 /* skill is not known */
act_info.cpp:	       || skill_table[sn].rating[ch->cClass] == 0)
act_info.cpp:                     skill_table[sn].name, ch->pcdata->learned[sn]);
act_info.cpp:                 ch->practice);
act_info.cpp:            if (ch->level < skill_table[sn].skill_level[ch->cClass]
act_info.cpp:               || ch->pcdata->learned[sn] < 1 /* skill is not known */
act_info.cpp:		   || skill_table[sn].rating[ch->cClass] == 0)
act_info.cpp:                     skill_table[sn].name, ch->pcdata->learned[sn]);
act_info.cpp:                 ch->practice);
act_info.cpp:            if (ch->level < skill_table[sn].skill_level[ch->cClass]
act_info.cpp:             || ch->pcdata->learned[sn] < 1 /* skill is not known */
act_info.cpp:		 || skill_table[sn].rating[ch->cClass] == 0)
act_info.cpp:                     skill_table[sn].name, ch->pcdata->learned[sn]);
act_info.cpp:                 ch->practice);
act_info.cpp:        for (mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room)
act_info.cpp:         && (ch->level < skill_table[sn].skill_level[ch->cClass]
act_info.cpp:          || ch->pcdata->learned[sn] < 1 /* skill is not known */
act_info.cpp:          || skill_table[sn].rating[ch->cClass] == 0)))
act_info.cpp:        adept = IS_NPC (ch) ? 100 : class_table[ch->cClass].skill_adept;
act_info.cpp:        if (ch->pcdata->learned[sn] >= adept)
act_info.cpp:            if(ch->pcdata->learned[sn] >= 100)
act_info.cpp:            if(ch->gold < ch->pcdata->learned[sn]/2)
act_info.cpp:                     ch->pcdata->learned[sn], skill_table[sn].name);
act_info.cpp:            ch->gold -= ch->pcdata->learned[sn]/2;
act_info.cpp:            ch->pcdata->learned[sn]++;
act_info.cpp:            if (ch->practice <= 0)
act_info.cpp:            if (skill_table[sn].rating[ch->cClass] < 0)
act_info.cpp:              div = skill_table[sn].rating[ch->cClass] * -1;
act_info.cpp:              div = skill_table[sn].rating[ch->cClass];
act_info.cpp:                int iprac = ((adept - ch->pcdata->learned[sn]) / (int_app[get_curr_stat(ch, STAT_INT)].learn / div));
act_info.cpp:                if(iprac > ch->practice)
act_info.cpp:                    iprac = ch->practice;
act_info.cpp:                ch->pcdata->learned[sn] += (iprac * (
act_info.cpp:                ch->practice -= iprac;
act_info.cpp:            ch->practice--;
act_info.cpp:            ch->pcdata->learned[sn] +=
act_info.cpp:            if (ch->pcdata->learned[sn] < adept)
act_info.cpp:                ch->pcdata->learned[sn] = adept;
act_info.cpp:        wimpy = ch->max_hit / 5;
act_info.cpp:    if (wimpy > ch->max_hit / 2)
act_info.cpp:    ch->wimpy = wimpy;
act_info.cpp:    if (strcmp (crypt ((const char *) arg1, (const char *) ch->pcdata->pwd), ch->pcdata->pwd))
act_info.cpp:    pwdnew = crypt (arg2, ch->name);
act_info.cpp:    free_string (ch->pcdata->pwd);
act_info.cpp:    ch->pcdata->pwd = str_dup (pwdnew);
act_info.cpp:		 ch->name,
act_info.cpp:		 IS_NPC(ch) ? "" : ch->pcdata->title,
act_info.cpp:		 ch->level, get_age(ch),
act_info.cpp:		 ( ch->played + (int) (current_time - ch->logon) ) / 3600);
act_info.cpp:  if ( get_trust( ch ) != ch->level )
act_info.cpp:		 race_table[ch->race].name,
act_info.cpp:		 ch->sex == 0 ? "sexless" : ch->sex == 1 ? "male" : "female",
act_info.cpp:		 IS_NPC(ch) ? "mobile" : class_table[ch->cClass].name);
act_info.cpp:		 ch->perm_stat[STAT_STR],
act_info.cpp:		 ch->perm_stat[STAT_INT],
act_info.cpp:		 ch->perm_stat[STAT_WIS],
act_info.cpp:		 ch->perm_stat[STAT_DEX],
act_info.cpp:		 ch->perm_stat[STAT_CON],
act_info.cpp:  if ( ch->level >= 15 )
act_info.cpp:		 ch->hit,  ch->max_hit,
act_info.cpp:		 ch->practice);
act_info.cpp:		 ch->mana, ch->max_mana,
act_info.cpp:		 ch->train);
act_info.cpp:		 ch->move, ch->max_move,
act_info.cpp:		 ch->carry_number, can_carry_n(ch));
act_info.cpp:		 ch->questpoints,
act_info.cpp:		     ch->exp,  ch->gold );
act_info.cpp:		     ch->exp,IS_HERO(ch) ? (1) : (ch->level + 1) *
act_info.cpp:		     exp_per_level(ch,ch->pcdata->points) - ch->exp,
act_info.cpp:		     ch->wimpy);
act_info.cpp:		     ch->gold, ch->silver);
act_info.cpp:  if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]   > 10 )
act_info.cpp:  if ( !IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] ==  0 )
act_info.cpp:  if ( !IS_NPC(ch) && ch->pcdata->condition[COND_HUNGER]   ==  0 )
act_info.cpp:  if ( !IS_NPC(ch) && ch->pcdata->condition[COND_BLEEDING] != 0 )
act_info.cpp:  switch ( ch->position )
act_info.cpp:  if (ch->level >= 25)
act_info.cpp:      if (IS_SET(ch->act,PLR_HOLYLIGHT))
act_info.cpp:      if (ch->invis_level)
act_info.cpp:	  sprintf(buf, " `7 Invisible: level `&%d",ch->invis_level);
act_info.cpp:      if (ch->incog_level)
act_info.cpp:	  sprintf(buf,"  `7Incognito: level `&%d",ch->incog_level);
act_info.cpp:  if ( ch->level >= 10 )
act_info.cpp:      printf_to_char(ch, "`7Alignment: `&%d.  ", ch->alignment );
act_info.cpp:  if ( ch->alignment >  900 ) send_to_char( "angelic.\n\r", ch );
act_info.cpp:  else if ( ch->alignment >  700 ) send_to_char( "saintly.\n\r", ch );
act_info.cpp:  else if ( ch->alignment >  350 ) send_to_char( "good.\n\r",    ch );
act_info.cpp:  else if ( ch->alignment >  100 ) send_to_char( "kind.\n\r",    ch );
act_info.cpp:  else if ( ch->alignment > -100 ) send_to_char( "neutral.\n\r", ch );
act_info.cpp:  else if ( ch->alignment > -350 ) send_to_char( "mean.\n\r",    ch );
act_info.cpp:  else if ( ch->alignment > -700 ) send_to_char( "evil.\n\r",    ch );
act_info.cpp:  else if ( ch->alignment > -900 ) send_to_char( "demonic.\n\r", ch );
act_info.cpp:  if (IS_SET(ch->comm,COMM_SHOW_AFFECTS)) {
act_info.cpp:                      if (IS_IMMORTAL(ch) || ch->clan == clan_lookup("Guide"))
act_info.cpp:	  if(is_exact_name(arg,wch->name))
act_info.cpp:  if (IS_SET(ch->act2, PLR_NOTITLE))
act_info.cpp:    REMOVE_BIT(ch->act2, PLR_NOTITLE);
act_info.cpp:  SET_BIT(ch->act2, PLR_NOTITLE);
act_info.cpp:  if (IS_SET(ch->act2, PLR_NORP))
act_info.cpp:    REMOVE_BIT(ch->act2, PLR_NORP);
act_info.cpp:  SET_BIT(ch->act2, PLR_NORP);
act_info.cpp:  if (IS_SET(ch->act2, PLR_NODAMAGE))
act_info.cpp:    REMOVE_BIT(ch->act2, PLR_NODAMAGE);
act_info.cpp:  SET_BIT(ch->act2, PLR_NODAMAGE);
act_info.cpp:  if (IS_SET(ch->act2, PLR_NOWEAVE))
act_info.cpp:    REMOVE_BIT(ch->act2, PLR_NOWEAVE);
act_info.cpp:  SET_BIT(ch->act2, PLR_NOWEAVE);
act_info.cpp:  if (IS_SET(ch->act2, PLR_WORLDMAP))
act_info.cpp:    REMOVE_BIT(ch->act2, PLR_WORLDMAP);
act_info.cpp:  SET_BIT(ch->act2, PLR_WORLDMAP);
act_move.cpp:    if (ch->position == POS_MEDITATING)
act_move.cpp:    if (IS_MOUNTED(ch) && ch->mount && IS_AFFECTED(ch->mount, AFF_FEAR)) 
act_move.cpp:      act("Your $N is too afraid to move any further.", ch, NULL, ch->mount, TO_CHAR);
act_move.cpp:      act("$N tries to leave, but is too frightened to move.", ch, NULL, ch->mount, TO_ROOM);
act_move.cpp:    in_room = ch->in_room;
act_move.cpp:    if ((IS_MOUNTED(ch) && IS_AFFECTED(ch->mount, AFF_GALLOPING)) ||
act_move.cpp:       if(IS_SET(ch->in_room->room_flags, ROOM_WILDERNESS))
act_move.cpp:    	if (IS_SET(to_room->room_flags, ROOM_NO_MOB) && !IS_SET(ch->act, ACT_MOUNT))
act_move.cpp:            sprintf (buf, "The %s cowers in fear of entering that room!",ch->short_descr);
act_move.cpp:        && ch->master != NULL && in_room == ch->master->in_room)
act_move.cpp:     if ( ch->pcdata->rentroom != to_room->vnum  && IS_SET(to_room->room_flags, ROOM_RENTED))
act_move.cpp:                if (iClass != ch->cClass
act_move.cpp:            for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
act_move.cpp:        if ((IS_MOUNTED(ch) && IS_AFFECTED(ch->mount, AFF_GALLOPING))
act_move.cpp:        ch->move -= move;
act_move.cpp:        if (ch->move < move)
act_move.cpp:    if (ch->is_mounted)
act_move.cpp:      if (!IS_NPC(ch) && ch->mount)
act_move.cpp:        act ("$n leaves the room riding $N to $t.", ch, dir_name[door], ch->mount, TO_ROOM);
act_move.cpp:      && ch->invis_level < LEVEL_HERO)
act_move.cpp:    else if ((ch->invis_level < LEVEL_HERO))
act_move.cpp:      for (fch = ch->in_room->people; fch != NULL; fch = fch_next)
act_move.cpp:        fch_next = fch->next_in_room;
act_move.cpp:    if (!IS_NPC(ch) && IS_AFFECTED (ch, AFF_VEIL) && ch->pcdata->pk_timer == 0 && IS_SET (ch->in_room->room_flags, ROOM_SAFE))
act_move.cpp:    if (!IS_NPC(ch) && IS_AFFECTED (ch, AFF_SHROUD) && ch->pcdata->pk_timer == 0 && IS_SET (ch->in_room->room_flags, ROOM_SAFE))
act_move.cpp:    if (ch->is_mounted)
act_move.cpp:      if (!IS_NPC(ch) && ch->mount)
act_move.cpp:        act ("$n comes riding into the room on $N from $t.", ch, rev_move[door], ch->mount, TO_ROOM);
act_move.cpp:      && ch->invis_level < LEVEL_HERO)
act_move.cpp:    else if ((ch->invis_level < LEVEL_HERO))
act_move.cpp:      for (fch = ch->in_room->people; fch != NULL; fch = fch_next)
act_move.cpp:        fch_next = fch->next_in_room;
act_move.cpp:    if( !IS_SET(ch->act, PLR_HOLYLIGHT)
act_move.cpp:                && (IS_AFFECTED(ch, AFF_BLIND) || room_is_dark(ch->in_room))
act_move.cpp:        fch_next = fch->next_in_room;
act_move.cpp:        if (fch->master == ch && IS_AFFECTED (fch, AFF_CHARM)
act_move.cpp:            && fch->position < POS_STANDING)
act_move.cpp:        if (fch->mount == ch
act_move.cpp:            && fch->position < POS_STANDING)
act_move.cpp:        if (fch->mount == ch && fch->position == POS_STANDING)
act_move.cpp:        if (fch->master == ch && fch->position == POS_STANDING
act_move.cpp:            if (IS_SET (ch->in_room->room_flags, ROOM_LAW)
act_move.cpp:                && (IS_NPC (fch) && IS_SET (fch->act, ACT_AGGRESSIVE)) &&
act_move.cpp:                !IS_SET(fch->act, ACT_MOUNT))
act_move.cpp:    if (ch->in_room->entry_bomb)
act_move.cpp:      bomb_room = ch->in_room;
act_move.cpp:            if ((pexit = ch->in_room->exit[door]) != NULL
act_move.cpp:    if ((pexit = ch->in_room->exit[door]) == NULL)
act_move.cpp:        pexit = ch->in_room->exit[door];
act_move.cpp:            && pexit_rev->u1.to_room == ch->in_room)
act_move.cpp:            for (rch = to_room->people; rch != NULL; rch = rch->next_in_room)
act_move.cpp:        pexit = ch->in_room->exit[door];
act_move.cpp:            && pexit_rev->u1.to_room == ch->in_room)
act_move.cpp:            for (rch = to_room->people; rch != NULL; rch = rch->next_in_room)
act_move.cpp:    for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
act_move.cpp:        pexit = ch->in_room->exit[door];
act_move.cpp:            && pexit_rev->u1.to_room == ch->in_room)
act_move.cpp:        pexit = ch->in_room->exit[door];
act_move.cpp:            && pexit_rev->u1.to_room == ch->in_room)
act_move.cpp:    for (gch = ch->in_room->people; gch; gch = gch->next_in_room)
act_move.cpp:        if (IS_NPC (gch) && IS_AWAKE (gch) && ch->level + 5 < gch->level)
act_move.cpp:        pexit = ch->in_room->exit[door];
act_move.cpp:            && pexit_rev->u1.to_room == ch->in_room)
act_move.cpp:        if (ch->position == POS_FIGHTING)
act_move.cpp:        obj = get_obj_list (ch, argument, ch->in_room->contents);
act_move.cpp:        if (ch->on != obj && count_users (obj) >= obj->value[0])
act_move.cpp:        ch->on = obj;
act_move.cpp:    switch (ch->position)
act_move.cpp:                ch->on = NULL;
act_move.cpp:            ch->position = POS_STANDING;
act_move.cpp:                ch->on = NULL;
act_move.cpp:            ch->position = POS_STANDING;
act_move.cpp:    if (ch->position == POS_FIGHTING)
act_move.cpp:        obj = get_obj_list (ch, argument, ch->in_room->contents);
act_move.cpp:        obj = ch->on;
act_move.cpp:        if (obj != NULL && ch->on != obj
act_move.cpp:        ch->on = obj;
act_move.cpp:    switch (ch->position)
act_move.cpp:            ch->position = POS_RESTING;
act_move.cpp:            ch->position = POS_RESTING;
act_move.cpp:            ch->position = POS_RESTING;
act_move.cpp:    if (ch->position == POS_FIGHTING)
act_move.cpp:        obj = get_obj_list (ch, argument, ch->in_room->contents);
act_move.cpp:        obj = ch->on;
act_move.cpp:        if (obj != NULL && ch->on != obj
act_move.cpp:        ch->on = obj;
act_move.cpp:    switch (ch->position)
act_move.cpp:            ch->position = POS_SITTING;
act_move.cpp:            ch->position = POS_SITTING;
act_move.cpp:            ch->position = POS_SITTING;
act_move.cpp:    switch (ch->position)
act_move.cpp:            if (argument[0] == '\0' && ch->on == NULL)
act_move.cpp:                ch->position = POS_SLEEPING;
act_move.cpp:                    obj = ch->on;
act_move.cpp:                    obj = get_obj_list (ch, argument, ch->in_room->contents);
act_move.cpp:                if (ch->on != obj && count_users (obj) >= obj->value[0])
act_move.cpp:                ch->on = obj;
act_move.cpp:                ch->position = POS_SLEEPING;
act_move.cpp:        af.level = ch->level;
act_move.cpp:        af.duration = ch->level;
act_move.cpp:       STR_REMOVE_BIT(ch->affected_by, AFF_DIEMCLOAK);
act_move.cpp:    if (str_cmp(ch->name, "stigmata"))
act_move.cpp:    af.level = ch->level;
act_move.cpp:        af.level = ch->level;
act_move.cpp:        af.duration = int(ch->level * 1.5);
act_move.cpp:    STR_REMOVE_BIT (ch->affected_by, AFF_HIDE);
act_move.cpp:    STR_REMOVE_BIT (ch->affected_by, AFF_INVISIBLE);
act_move.cpp:    STR_REMOVE_BIT (ch->affected_by, AFF_SNEAK);
act_move.cpp:    STR_REMOVE_BIT (ch->affected_by, AFF_SHROUD);
act_move.cpp:    STR_REMOVE_BIT (ch->affected_by, AFF_STEALTH);
act_move.cpp:    if (IS_NPC (ch) && !IS_SET (ch->act, ACT_PET))
act_move.cpp:    if (ch->level > 10)
act_move.cpp:    if (ch->in_room == location)
act_move.cpp:    if (IS_SET (ch->in_room->room_flags, ROOM_NO_RECALL)
act_move.cpp:    if ((victim = ch->fighting) != NULL)
act_move.cpp:        lose = (ch->desc == NULL) ? 15 : 25;
act_move.cpp:    ch->move = int(ch->move*.67);
act_move.cpp:    if (ch->pet != NULL)
act_move.cpp:        do_function (ch->pet, &do_recall, "");
act_move.cpp:    permhp = ch->pcdata->perm_hit;
act_move.cpp:    permmana = ch->pcdata->perm_mana;
act_move.cpp:    for (mob = ch->in_room->people; mob; mob = mob->next_in_room)
act_move.cpp:        sprintf (buf, "You have %d training sessions.\n\r", ch->train);
act_move.cpp:        if (class_table[ch->cClass].attr_prime == STAT_STR)
act_move.cpp:        if (class_table[ch->cClass].attr_prime == STAT_INT)
act_move.cpp:        if (class_table[ch->cClass].attr_prime == STAT_WIS)
act_move.cpp:        if (class_table[ch->cClass].attr_prime == STAT_DEX)
act_move.cpp:        if (class_table[ch->cClass].attr_prime == STAT_CON)
act_move.cpp:        if (ch->perm_stat[STAT_STR] < get_max_train (ch, STAT_STR))
act_move.cpp:        if (ch->perm_stat[STAT_INT] < get_max_train (ch, STAT_INT))
act_move.cpp:        if (ch->perm_stat[STAT_WIS] < get_max_train (ch, STAT_WIS))
act_move.cpp:        if (ch->perm_stat[STAT_DEX] < get_max_train (ch, STAT_DEX))
act_move.cpp:        if (ch->perm_stat[STAT_CON] < get_max_train (ch, STAT_CON))
act_move.cpp:	if (ch->max_move < 1500)
act_move.cpp:                 ch->sex == SEX_MALE ? "big stud" :
act_move.cpp:                 ch->sex == SEX_FEMALE ? "hot babe" : "wild thing", TO_CHAR);
act_move.cpp:        if (cost > ch->train)
act_move.cpp:         ch->train -= cost;
act_move.cpp:	   ch->pcdata->perm_hit += newhp;
act_move.cpp:	   ch->max_hit += newhp;
act_move.cpp:	   ch->hit += newhp;	  
act_move.cpp:	   ch->practice += pgain;
act_move.cpp:	 /*  sprintf(buf, "CURRENT:%ld MAX:%d\n\r", ch->pcdata->perm_hit, max_natural_hp(ch));
act_move.cpp:        ch->train -= cost;
act_move.cpp:        ch->pcdata->perm_hit += 10;
act_move.cpp:        ch->max_hit += 10;
act_move.cpp:        ch->hit += 10;
act_move.cpp:        if (cost > ch->train)
act_move.cpp:        ch->train -= cost;
act_move.cpp:        ch->pcdata->perm_mana += 10;
act_move.cpp:        ch->max_mana += 10;
act_move.cpp:        ch->mana += 10;
act_move.cpp:	if (cost > ch->train)
act_move.cpp:        ch->train -=cost;
act_move.cpp:        ch->pcdata->perm_move += 10;
act_move.cpp:        ch->max_move += 10;
act_move.cpp:        ch->move += 10;
act_move.cpp:    if (ch->perm_stat[stat] >= get_max_train (ch, stat))
act_move.cpp:    if (cost > ch->train)
act_move.cpp:    ch->train -= cost;
act_move.cpp:    ch->perm_stat[stat] += 1;
act_note.cpp:		              && str_cmp( ch->name, pnote->sender )
act_note.cpp:		              && ch->last_note_special < pnote->date_stamp 
act_note.cpp:		          ch->last_note_special = UMAX( ch->last_note_special, pnote->date_stamp );
act_note.cpp:		          ch->desc->writing_note = NOTING_QUESTION_READ_NEXT_SPECIAL;
act_note.cpp:		        ch->desc->writing_note = NOTING_CONTINUE;
act_note.cpp:	   	    ch->desc->writing_note = NOTING_QUESTION_READ_NEXT;
act_note.cpp:		    ch->desc->writing_note = NOTING_READ_PREVIOUS;
act_note.cpp:                  if ( ch->level < 2 )
act_note.cpp:	          write_to_buffer( ch->desc, HWHITE, 0 );
act_note.cpp:	          write_to_buffer( ch->desc, "-------------==============>******************<=============--------------\n\r\n\r", 0 );
act_note.cpp:	          write_to_buffer( ch->desc, NTXT, 0 );
act_note.cpp:		  ch->desc->writing_note = NOTING_TO_QUESTION;  
act_note.cpp:		  ch->desc->writing_note = NOTING_QUESTION_DELETE_NOTE;
act_note.cpp:		         && str_cmp( ch->name, pnote->sender )
act_note.cpp:		         && ch->last_note_bulletin < pnote->date_stamp 
act_note.cpp:		          ch->last_note_bulletin = UMAX( ch->last_note_bulletin, pnote->date_stamp );
act_note.cpp:		          ch->desc->writing_note = NOTING_QUESTION_READ_NEXT_BULLETIN;
act_note.cpp:			ch->desc->writing_note = NOTING_CONTINUE;
act_note.cpp:		  ch->desc->writing_note = NOTING_CONFIG_NO_ARGUMENT;
act_note.cpp:		  ch->desc->writing_note = NOTING_LIST_BULLETIN_QUESTION;
act_note.cpp:		  ch->desc->writing_note = NOTING_BULLETIN_SUBJECT;  
act_note.cpp:		  ch->desc->writing_note = NOTING_HELP_QUESTION;
act_note.cpp:		  ch->desc->writing_note = NOTING_LIST_QUESTION;
act_note.cpp:		  ch->desc->writing_note = 0;
act_note.cpp:		  ch->desc->connected = CON_PLAYING;
act_note.cpp:		  REMOVE_BIT( ch->note_config, NOTE_CONFIG_CURRENTLY_NOTING );
act_note.cpp:		  ch->desc->writing_note = NOTING_NO_ARGUMENT;
act_note.cpp:		    ch->desc->writing_note = NOTING_READ_PREVIOUS;
act_note.cpp:		  ch->desc->writing_note = NOTING_QUESTION_DELETE_NOTE;
act_note.cpp:		    write_to_buffer( ch->desc, CLR, 0 );
act_note.cpp:		    write_to_buffer( ch->desc, "Resuming regular game play.\n\r", 0 );
act_note.cpp:		  if ( strcmp( ch->pcdata->buffer->string, "" ) )
act_note.cpp:		     write_to_buffer( ch->desc, "\n\rInformation from the MUD has been saved while you were noting:\n\r--------------------------------------------------------------\n\r", 0 );	
act_note.cpp:		    ch->desc->writing_note = 0;
act_note.cpp:		    ch->desc->connected = CON_PLAYING;
act_note.cpp:		    REMOVE_BIT(ch->note_config, NOTE_CONFIG_CURRENTLY_NOTING );
act_note.cpp:		  ch->desc->writing_note = NOTING_CONTINUE;
act_note.cpp:		  ch->desc->writing_note = NOTING_HELP_QUESTION;
act_note.cpp:		 ch->desc->writing_note = NOTING_HELP_CONTINUE;
act_note.cpp:		    ch->desc->writing_note = NOTING_READ_BULLETIN_PREVIOUS;
act_note.cpp:		   sprintf( buf, "%s", board_name( ch->board_config) );
act_note.cpp:		   /* More ch->level qualifiers here */
act_note.cpp:		    { if ( ch->board_config < (1+2+4+8+16+32+64+128+256) )
act_note.cpp:		       if (ch->board_config < 1+2+4 )
act_note.cpp:		   ch->desc->writing_note = NOTING_CONFIG_QUESTION_CHANGE;
act_note.cpp:		   write_to_buffer( ch->desc, "---------------===============> Note System <==============---------------\n\r\n\r", 0 );
act_note.cpp:		   ch->desc->writing_note = NOTING_CONFIG_QUESTION_ECHO;
act_note.cpp:		   ch->desc->writing_note = 0;
act_note.cpp:		   ch->desc->connected = CON_PLAYING;
act_note.cpp:		SET_BIT( ch->note_config, NOTE_CONFIG_CLIENT );
act_note.cpp:		ch->desc->writing_note = NOTING_CONTINUE;
act_note.cpp:		REMOVE_BIT( ch->note_config, NOTE_CONFIG_CLIENT );
act_note.cpp:		ch->desc->writing_note = NOTING_CONTINUE;
act_note.cpp:		ch->desc->writing_note = NOTING_CONFIG_QUESTION_ECHO;
act_note.cpp:		ch->desc->writing_note = NOTING_CONFIG_QUESTION_ADD_REMOVE;
act_note.cpp:		ch->desc->writing_note = NOTING_CONFIG_QUESTION_CHANGE;
act_note.cpp:		   /* More ch->level qualifying here */
act_note.cpp:		   ch->desc->writing_note = NOTING_CONFIG_WHICH_ADD;
act_note.cpp:		   ch->desc->writing_note = NOTING_CONFIG_WHICH_REMOVE;
act_note.cpp:		   ch->desc->writing_note = NOTING_CONFIG_QUESTION_ADD_REMOVE;
act_note.cpp:		    ch->board_config += BOARD_GENERAL;
act_note.cpp:		    ch->board_config += BOARD_PERSONAL;
act_note.cpp:		    ch->board_config += BOARD_QUEST;
act_note.cpp:		    ch->board_config += BOARD_CREATIVITY;		
act_note.cpp:		       ch->board_config += BOARD_IMMORTAL;
act_note.cpp:		     write_to_buffer( ch->desc, "\n\rYou cannot subscribe to an immortal board.\n\rPress <return> to continue.", 0 );
act_note.cpp:		     ch->desc->writing_note = NOTING_CONFIG_NO_ARGUMENT; }
act_note.cpp:		       ch->board_config += BOARD_BUILDER;
act_note.cpp:		     write_to_buffer( ch->desc, "\n\rYou cannot subscribe to an immortal board.\n\rPress <return> to continue.", 0 );
act_note.cpp:		     ch->desc->writing_note = NOTING_CONFIG_NO_ARGUMENT; }
act_note.cpp:		       ch->board_config += BOARD_CODER;
act_note.cpp:		     write_to_buffer( ch->desc, "\n\rYou cannot subscribe to an immortal board.\n\rPress <return> to continue.", 0 );
act_note.cpp:		     ch->desc->writing_note = NOTING_CONFIG_NO_ARGUMENT; }
act_note.cpp:		       ch->board_config += BOARD_SENIOR;
act_note.cpp:		     write_to_buffer( ch->desc, "\n\rYou cannot subscribe to an immortal board.\n\rPress <return> to continue.", 0 );
act_note.cpp:		     ch->desc->writing_note = NOTING_CONFIG_NO_ARGUMENT; }
act_note.cpp:		       ch->board_config += BOARD_EXEC;
act_note.cpp:		     write_to_buffer( ch->desc, "\n\rYou cannot subscribe to an immortal board.\n\rPress <return> to continue.", 0 );
act_note.cpp:		     ch->desc->writing_note = NOTING_CONFIG_NO_ARGUMENT; }
act_note.cpp:		    ch->desc->writing_note = NOTING_CONFIG_WHICH_ADD;
act_note.cpp:	ch->desc->writing_note = NOTING_CONFIG_NO_ARGUMENT;
act_note.cpp:	      ch->desc->writing_note = NOTING_CONTINUE;
act_note.cpp:	  ch->board_config -= board_value( argument );
act_note.cpp:	  ch->desc->writing_note = NOTING_CONTINUE;
act_note.cpp:	     ch->desc->writing_note = NOTING_QUESTION_DELETE_NOTE;
act_note.cpp:	      ch->desc->writing_note = NOTING_CONTINUE;
act_note.cpp:	    ch->desc->writing_note = NOTING_READ_BULLETIN_PREVIOUS;
act_note.cpp:	     ch->desc->writing_note = NOTING_CONTINUE;
act_note.cpp:	    ch->desc->writing_note = NOTING_READ_PREVIOUS;
act_note.cpp:	     ch->desc->writing_note = NOTING_CONTINUE;
act_note.cpp:		   ch->desc->writing_note = NOTING_QUESTION_READ_NEXT;
act_note.cpp:		    	&& str_cmp( ch->name, pnote->sender )
act_note.cpp:		    	&& ch->last_note_special < pnote->date_stamp 
act_note.cpp:			ch->last_note_special = UMAX( ch->last_note_special, pnote->date_stamp );
act_note.cpp:		ch->desc->writing_note = NOTING_QUESTION_READ_NEXT_SPECIAL;
act_note.cpp:		    	&& str_cmp( ch->name, pnote->sender )
act_note.cpp:		    	&& ch->last_note_bulletin < pnote->date_stamp 
act_note.cpp:			ch->last_note_bulletin = UMAX( ch->last_note_bulletin, pnote->date_stamp );
act_note.cpp:		ch->desc->writing_note = NOTING_QUESTION_READ_NEXT_BULLETIN;
act_note.cpp:		   SET_BIT( ch->pnote->special, NOTE_SPECIAL_PERSON_TO_PERSON);
act_note.cpp:                   ch->desc->writing_note = NOTING_TO;
act_note.cpp:                  ch->desc->writing_note = NOTING_TO;
act_note.cpp:		  ch->desc->writing_note = NOTING_TO_QUESTION;
act_note.cpp:          	free_string( ch->pnote->to_list );
act_note.cpp:		if ( IS_SET(ch->pnote->special, NOTE_SPECIAL_PERSON_TO_PERSON) )
act_note.cpp:		   ch->desc->writing_note = NOTING_TO;
act_note.cpp:	        ch->pnote->to_list = str_dup( "all");
act_note.cpp:		write_to_buffer( d, board_name(ch->board_config), 0 );
act_note.cpp:	free_string( ch->pnote->to_list );
act_note.cpp:	ch->pnote->to_list = str_dup( argument );	
act_note.cpp:	write_to_buffer( d, board_name(ch->board_config), 0 );
act_note.cpp:	     ch->pnote->board = BOARD_GENERAL;
act_note.cpp:	      write_to_buffer( d, board_name(ch->board_config), 0 );
act_note.cpp:	  if ( !str_cmp( ch->pnote->to_list, "all" ) 
act_note.cpp:	      write_to_buffer( d, board_name(ch->board_config), 0 );
act_note.cpp:	     ch->pnote->board = board_value( argument );
act_note.cpp:	     free_string( ch->pnote->subject );
act_note.cpp:	     ch->pnote->subject = str_dup( "<no subject>" );
act_note.cpp:	     string_append( ch, &ch->pnote->text );
act_note.cpp:	     free_string( ch->pnote->subject );
act_note.cpp:	     ch->pnote->subject = str_dup( argument );
act_note.cpp:	     string_append( ch, &ch->pnote->text );
act_note.cpp:			ch->pnote->next			= NULL;
act_note.cpp:			free_string( ch->pnote->date );
act_note.cpp:			ch->pnote->date			= str_dup( strtime );
act_note.cpp:			ch->pnote->date_stamp           = current_time;
act_note.cpp:		       if (strchr(ch->pnote->to_list, '@')!=NULL)
act_note.cpp:         		  imc_post_mail(ch, ch->pnote->sender,
act_note.cpp:                          ch->pnote->to_list,
act_note.cpp:                          ch->pnote->date,
act_note.cpp:                          ch->pnote->subject,
act_note.cpp:			  ch->pnote->text );
act_note.cpp:	    		   note_list	= ch->pnote;
act_note.cpp:			    pnote->next	= ch->pnote;
act_note.cpp:			pnote		= ch->pnote;
act_note.cpp:			ch->pnote       = NULL;
act_note.cpp:			write_to_buffer( ch->desc, CLR, 0 );
act_note.cpp:		        REMOVE_BIT( ch->note_config, NOTE_CONFIG_CURRENTLY_NOTING );
act_note.cpp:		        free_string( ch->pnote->text    );
act_note.cpp:	    		free_string( ch->pnote->subject );
act_note.cpp:	    		free_string( ch->pnote->to_list );
act_note.cpp:	    		free_string( ch->pnote->date    );
act_note.cpp:	    		free_string( ch->pnote->sender  );
act_note.cpp:	    		ch->pnote->next	= note_free;
act_note.cpp:	    		note_free		= ch->pnote;
act_note.cpp:	    		ch->pnote		= NULL;
act_note.cpp:			write_to_buffer( ch->desc, CLR, 0 );			
act_note.cpp:			write_to_buffer( ch->desc, "\n\rNote Cleared.  Resuming regular game play.\n\r", 0 );
act_note.cpp:			REMOVE_BIT( ch->note_config, NOTE_CONFIG_CURRENTLY_NOTING );
act_note.cpp:		        free_string( ch->pnote->text    );
act_note.cpp:	    		free_string( ch->pnote->subject );
act_note.cpp:	    		free_string( ch->pnote->to_list );
act_note.cpp:	    		free_string( ch->pnote->date    );
act_note.cpp:	    		free_string( ch->pnote->sender  );
act_note.cpp:	    		ch->pnote->next	= note_free;
act_note.cpp:	    		note_free		= ch->pnote;
act_note.cpp:	    		ch->pnote		= NULL;
act_note.cpp:			REMOVE_BIT( ch->note_config, NOTE_CONFIG_CURRENTLY_NOTING );
act_note.cpp:	     free_string( ch->pnote->subject );
act_note.cpp:	     ch->pnote->subject = str_dup( "<no subject>" );
act_note.cpp:	     string_append( ch, &ch->pnote->text );
act_note.cpp:	     free_string( ch->pnote->subject );
act_note.cpp:	     ch->pnote->to_list = str_dup( "all" );
act_note.cpp:	     ch->pnote->subject = str_dup( argument );
act_note.cpp:	     ch->pnote->board = 1;
act_note.cpp:	     SET_BIT( ch->pnote->special, NOTE_SPECIAL_IS_BULLETIN );
act_note.cpp:	     string_append( ch, &ch->pnote->text );
act_note.cpp:    if ( !str_cmp( ch->name, pnote->sender ) )
act_note.cpp:    if ( is_name( ch->name, pnote->to_list ) )
act_note.cpp:    if ( ch->pnote )
act_note.cpp:	pnote	  = alloc_perm( sizeof( *ch->pnote ) );
act_note.cpp:    pnote->sender	= str_dup( ch->name );
act_note.cpp:    ch->pnote		= pnote;
act_note.cpp:	if ( to_one[0] != '\0' && str_cmp( ch->name, to_one ) )
act_note.cpp:    if ( str_cmp( ch->name, pnote->sender ) && to_new[0] != '\0' )
act_note.cpp:	if ( ch->pnote )
act_note.cpp:	    free_string( ch->pnote->text    );
act_note.cpp:	    free_string( ch->pnote->subject );
act_note.cpp:	    free_string( ch->pnote->to_list );
act_note.cpp:	    free_string( ch->pnote->date    );
act_note.cpp:	    free_string( ch->pnote->sender  );
act_note.cpp:	    ch->pnote->special = 0;
act_note.cpp:	    ch->pnote->board = 0;
act_note.cpp:	    ch->pnote->next	= note_free;
act_note.cpp:	    note_free		= ch->pnote;
act_note.cpp:	    ch->pnote		= NULL;
act_note.cpp:         if ( IS_SET( ch->note_config, NOTE_CONFIG_FIRST_TIME) )
act_note.cpp:             	SET_BIT( ch->note_config, NOTE_CONFIG_CURRENTLY_NOTING );
act_note.cpp:		write_to_buffer( ch->desc, CLR, 0 );
act_note.cpp:		REMOVE_BIT( ch->note_config, NOTE_CONFIG_FIRST_TIME );
act_note.cpp:	        ch->desc->connected = CON_NOTING;
act_note.cpp:		ch->desc->writing_note = NOTING_CONTINUE;
act_note.cpp:	write_to_buffer( ch->desc, CLR, 0 );
act_note.cpp:	write_to_buffer( ch->desc, HWHITE, 0 );
act_note.cpp:	write_to_buffer( ch->desc, "---------=========> Maestro Noting System -- Main Menu <=========---------\n\r\n\r", 0 ); 
act_note.cpp:	write_to_buffer( ch->desc, NTXT, 0 );
act_note.cpp:	write_to_buffer( ch->desc, "Would you like to:\n\r", 0 );
act_note.cpp:	write_to_buffer( ch->desc, "                   1 - Read unread notes written directly to you.\n\r", 0 );
act_note.cpp:	write_to_buffer( ch->desc, "                   2 - <R>ead unread notes on subscribed boards.\n\r", 0 );
act_note.cpp:	write_to_buffer( ch->desc, "                   3 - Read a <p>reviously read note\n\r", 0 );
act_note.cpp:	write_to_buffer( ch->desc, "                   4 - <W>rite a new note\n\r", 0 );
act_note.cpp:	write_to_buffer( ch->desc, "                   5 - <D>elete a note from your list\n\r", 0 );
act_note.cpp:	write_to_buffer( ch->desc, "                   L - List notes posted on subscribed boards\n\r\n\r", 0 );
act_note.cpp:	write_to_buffer( ch->desc, HWHITE, 0 );
act_note.cpp:	write_to_buffer( ch->desc, "--------------=============> System Bulletins <=============--------------\n\r", 0 ); 
act_note.cpp:	write_to_buffer( ch->desc, NTXT, 0 );
act_note.cpp:	write_to_buffer( ch->desc, "System Bulletins are special announcements posted by the administrators.\n\rThey", 0 );	
act_note.cpp:	write_to_buffer( ch->desc, " are considered priority, and should not be missed by any player.\n\r\n\r", 0 );
act_note.cpp:	write_to_buffer( ch->desc, "                   B - Read unread system bulletins.\n\r", 0 );
act_note.cpp:	write_to_buffer( ch->desc, "                   6 - List system bulletins\n\r", 0 );
act_note.cpp:   	  write_to_buffer( ch->desc, "                   7 - Post a new system bulletin\n\r\n\r", 0 );
act_note.cpp:	  write_to_buffer( ch->desc, HWHITE, 0 );
act_note.cpp:	  write_to_buffer( ch->desc, "--------------=============>******************<=============--------------\n\r\n\r", 0 );
act_note.cpp:	  write_to_buffer( ch->desc, NTXT, 0 );
act_note.cpp: 	  write_to_buffer( ch->desc, "                   C - Configure your note/bulletin system preferences\n\r", 0 );
act_note.cpp:	  write_to_buffer( ch->desc, "                   H - Get HELP using the system.\n\r", 0 );
act_note.cpp:	  write_to_buffer( ch->desc, "                   X - Exit the note/bulletin system.\n\r\n\r", 0 );
act_note.cpp:	  write_to_buffer( ch->desc, HWHITE, 0 );
act_note.cpp:	  write_to_buffer( ch->desc, "--------------=============>******************<==============--------------\n\r\n\r", 0 );
act_note.cpp:	  write_to_buffer( ch->desc, NTXT, 0 );
act_note.cpp:          write_to_buffer( ch->desc, "                   C - Configure your note/bulletin system preferences\n\r", 0 );
act_note.cpp:	  write_to_buffer( ch->desc, "                   H - Get HELP using the system.\n\r", 0 );
act_note.cpp:          write_to_buffer( ch->desc, "                   X - Exit the note/bulletin system.\n\r\n\r", 0 );
act_note.cpp:	  write_to_buffer( ch->desc, HWHITE, 0 );
act_note.cpp:	  write_to_buffer( ch->desc, "    [1-7, B, C, H, L, or X]: ", 0 );
act_note.cpp:	  write_to_buffer( ch->desc, NTXT, 0 );
act_note.cpp:	  write_to_buffer( ch->desc, HWHITE, 0 );
act_note.cpp:	  write_to_buffer( ch->desc, "    [1-6, B, C, H, L, or X]: ", 0 );
act_note.cpp:	  write_to_buffer( ch->desc, NTXT, 0 );
act_note.cpp:	ch->desc->writing_note = NOTING_NO_ARGUMENT;
act_note.cpp:	SET_BIT( ch->note_config, NOTE_CONFIG_CURRENTLY_NOTING );
act_note.cpp:	ch->desc->connected = CON_NOTING;
act_note.cpp:		  write_to_buffer( ch->desc, CLR, 0 );
act_note.cpp:		  write_to_buffer( ch->desc, HWHITE, 0 );
act_note.cpp:	          write_to_buffer( ch->desc, "----------------================> Note System <================----------------\n\r\n\r", 0 );
act_note.cpp:		  write_to_buffer( ch->desc, NTXT, 0 );
act_note.cpp:		  write_to_buffer( ch->desc, "Would you like to obtain:\n\r", 0 );
act_note.cpp:		  write_to_buffer( ch->desc, "               1.  Help with understanding BOARDS.\n\r", 0 );
act_note.cpp:		  write_to_buffer( ch->desc, "               2.  Help with understanding PERSON-TO-PERSON notes.\n\r", 0 );
act_note.cpp:		  write_to_buffer( ch->desc, "               3.  Help with CONFIGURING your note system.\n\r", 0 );
act_note.cpp:		  write_to_buffer( ch->desc, "               4.  Help with understanding BULLETINS.\n\r", 0 );
act_note.cpp:		  write_to_buffer( ch->desc, "               5.  Help on how to use the note EDITOR.\n\r\n\r", 0 );
act_note.cpp:		  write_to_buffer( ch->desc, "               6.  Information about the different boards,\n\r", 0 );
act_note.cpp:		  write_to_buffer( ch->desc, "                   and which ones to which you should subscribe\n\r", 0 );
act_note.cpp:		  write_to_buffer( ch->desc, "               7.  Common problems/troubleshooting solutions\n\r", 0 );
act_note.cpp:		  write_to_buffer( ch->desc, "               8.  General Information ABOUT AVATAR's Note System.\n\r\n\r", 0 );
act_note.cpp:		  write_to_buffer( ch->desc, "   [1-8, <Q>uit, or <S>tart note system]: ", 0 );
act_note.cpp:		  ch->desc->writing_note = NOTING_HELP_QUESTION;
act_note.cpp:	          SET_BIT( ch->note_config, NOTE_CONFIG_CURRENTLY_NOTING );
act_note.cpp:	          ch->desc->connected = CON_NOTING;
act_note.cpp:		    && str_cmp( ch->name, pnote->sender )
act_note.cpp:		    && ch->last_note < pnote->date_stamp 
act_note.cpp:	 	ch->last_note = UMAX( ch->last_note, pnote->date_stamp );
act_note.cpp:		    ch->last_note = UMAX( ch->last_note, pnote->date_stamp );
act_note.cpp:		    && str_cmp( ch->name, pnote->sender )
act_note.cpp:		    && ch->last_note < pnote->date_stamp 
act_note.cpp:	 	ch->last_note = UMAX( ch->last_note, pnote->date_stamp );
act_note.cpp:		    ch->last_note = UMAX( ch->last_note, pnote->date_stamp );
act_note.cpp:	if ( ch->pnote )
act_note.cpp:	    free_string( ch->pnote->text    );
act_note.cpp:	    free_string( ch->pnote->subject );
act_note.cpp:	    free_string( ch->pnote->to_list );
act_note.cpp:	    free_string( ch->pnote->date    );
act_note.cpp:	    free_string( ch->pnote->sender  );
act_note.cpp:	    ch->pnote->special = 0;
act_note.cpp:	    ch->pnote->board = 0;
act_note.cpp:	    ch->pnote->next	= note_free;
act_note.cpp:	    note_free		= ch->pnote;
act_note.cpp:	    ch->pnote		= NULL;
act_note.cpp:	if ( IS_SET( ch->note_config, NOTE_CONFIG_CURRENTLY_NOTING ))
act_note.cpp:	   REMOVE_BIT(ch->note_config, NOTE_CONFIG_CURRENTLY_NOTING );
act_note.cpp:	if ( !ch->pnote )
act_note.cpp:		ch->pnote->sender,
act_note.cpp:		ch->pnote->subject,
act_note.cpp:		ch->pnote->to_list );
act_note.cpp:	send_to_char( ch->pnote->text, ch );
act_note.h: *  Special Note System Configuration bits ( ch->note_config )
act_obj.cpp:  if ( !IS_NPC(ch) && ch->pcdata->condition[COND_HORNY] >= 40 && ch->pcdata->condition[COND_GOBLIND] == 0)
act_obj.cpp:        ch->pcdata->condition[COND_GOBLIND] = 1;
act_obj.cpp:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_HORNY] >= 40)
act_obj.cpp:              ch->pcdata->condition[COND_GOBLIND] = 0;
act_obj.cpp:        af.level     = ch->level;
act_obj.cpp:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_HORNY] != 0)
act_obj.cpp:    condition = ch->pcdata->condition[COND_HORNY];
act_obj.cpp:      condition = ch->pcdata->condition[COND_HORNY];
act_obj.cpp:      else if ( ch->pcdata->condition[COND_HORNY] >= 9 && ch->pcdata->condition[COND_HORNY] < 18)
act_obj.cpp:      else if ( ch->pcdata->condition[COND_HORNY] >= 18 && ch->pcdata->condition[COND_HORNY] < 27)
act_obj.cpp:      else if ( ch->pcdata->condition[COND_HORNY] >= 27 && ch->pcdata->condition[COND_HORNY] < 36)
act_obj.cpp:    else if ( ch->pcdata->condition[COND_HORNY] >= 45 )
act_obj.cpp:    ch->pcdata->condition[COND_GOBLIND] = 0;
act_obj.cpp:  wealth = ch->gold + (ch->silver / 100);
act_obj.cpp:  if (ch->silver > figure)
act_obj.cpp:    ch->silver -= figure;
act_obj.cpp:    sprintf(buf, "You have been taxed %ld silver and %ld gold.\n\r", ch->silver, (figure - ch->silver) / 100);
act_obj.cpp:    ch->gold -= (figure - ch->silver) / 100;
act_obj.cpp:    ch->silver = 0;
act_obj.cpp:    if (!str_cmp (ch->name, obj->owner))
act_obj.cpp:    for (wch = char_list; wch != NULL; wch = wch->next)
act_obj.cpp:        if (!str_cmp (wch->name, obj->owner))
act_obj.cpp:      if (!str_cmp(ch->name, obj->lastKilled) && obj->lootsLeft > 0)
act_obj.cpp:     if (ch->fighting)
act_obj.cpp:    for (bag = ch->carrying; bag != NULL; bag = bag->next)
act_obj.cpp:    victim = ch->fighting;
act_obj.cpp:    chance -= ch->level - victim->level;
act_obj.cpp:  if (!IS_NPC(ch) && str_cmp(class_table[ch->cClass].name, "illuminator"))
act_obj.cpp:       obj->owner = str_dup(ch->name);
act_obj.cpp:      obj_to_room(obj, ch->in_room);
act_obj.cpp:       if (ch->cClass != class_lookup("Illuminator") && number_bits(2) == 0)
act_obj.cpp:         obj->owner = str_dup(ch->name);
act_obj.cpp:      obj_to_room(obj, ch->in_room);
act_obj.cpp:  sprintf(buf, "%s turned in %s for a restring.\n\r", ch->name, tempshort);
act_obj.cpp:    if (ch->carry_number + get_obj_number (obj) > can_carry_n (ch))
act_obj.cpp:    if (IS_OBJ_STAT(obj, ITEM_QUEST) && obj->owner && str_cmp(obj->owner, ch->name) &&
act_obj.cpp:    if (ch->clan == clan_lookup("Tinker") && obj->pk)
act_obj.cpp:        for (gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room)
act_obj.cpp:            if (gch->on == obj)
act_obj.cpp:      if (str_cmp(ch->name, obj->owner) && !IS_IMMORTAL(ch))
act_obj.cpp:        if (container->item_type == ITEM_CORPSE_PC && str_cmp(container->owner, ch->name))
act_obj.cpp:			ch->name, obj->short_descr, obj->id, container->owner);
act_obj.cpp:        ch->silver += obj->value[0];
act_obj.cpp:        ch->gold += obj->value[1];
act_obj.cpp:        if (IS_SET (ch->act, PLR_AUTOSPLIT))
act_obj.cpp:            for (gch = ch->in_room->people; gch != NULL;
act_obj.cpp:                 gch = gch->next_in_room)
act_obj.cpp:        if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_GET ) )
act_obj.cpp:            p_give_trigger( NULL, NULL, ch->in_room, ch, obj, TRIG_GET );
act_obj.cpp:            obj = get_obj_list (ch, arg1, ch->in_room->contents);
act_obj.cpp:            for (obj = ch->in_room->contents; obj != NULL; obj = obj_next)
act_obj.cpp:         for (obj = ch->carrying; obj != NULL; obj = obj_next)
act_obj.cpp:    	    for (obj = ch->carrying; obj != NULL; obj=obj_next)
act_obj.cpp:        for (obj = ch->carrying; obj != NULL; obj = obj_next)
act_obj.cpp:        if (!IS_NPC(ch) && ch->pcdata->pk_timer > 0)
act_obj.cpp:            if (ch->silver < amount)
act_obj.cpp:            ch->silver -= amount;
act_obj.cpp:            if (ch->gold < amount)
act_obj.cpp:            ch->gold -= amount;
act_obj.cpp:        for (obj = ch->in_room->contents; obj != NULL; obj = obj_next)
act_obj.cpp:        obj_to_room (create_money (gold, silver), ch->in_room);
act_obj.cpp:        if (!IS_NPC(ch) && ch->pcdata->pk_timer > 0 &&
act_obj.cpp:          for (bomb = ch->in_room->contents; bomb != NULL; bomb = bomb_next)
act_obj.cpp:             ch->in_room->entry_bomb = TRUE;
act_obj.cpp:        obj_to_room (obj, ch->in_room);
act_obj.cpp:        if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_DROP ) )
act_obj.cpp:            p_give_trigger( NULL, NULL, ch->in_room, ch, obj, TRIG_DROP );
act_obj.cpp:        if (!IS_NPC(ch) && ch->pcdata->pk_timer > 0)
act_obj.cpp:        for (obj = ch->carrying; obj != NULL; obj = obj_next)
act_obj.cpp:               for (bomb = ch->in_room->contents; bomb != NULL; bomb = bomb_next)
act_obj.cpp:                    ch->in_room->entry_bomb = TRUE;
act_obj.cpp:                obj_to_room (obj, ch->in_room);
act_obj.cpp:	        if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_DROP ) )
act_obj.cpp:        	    p_give_trigger( NULL, NULL, ch->in_room, ch, obj, TRIG_DROP );
act_obj.cpp:    if (!IS_NPC(ch) && ch->pcdata->pk_timer > 0)
act_obj.cpp:        if ((!silver && ch->gold < amount) || (silver && ch->silver < amount))
act_obj.cpp:            ch->silver -= amount;
act_obj.cpp:            ch->gold -= amount;
act_obj.cpp:                ch->oreply = victim;
act_obj.cpp:                         amount, silver ? "silver" : "gold", ch->name);
act_obj.cpp:                         change, silver ? "gold" : "silver", ch->name);
act_obj.cpp:                             (95 * amount / 100 - change * 100), ch->name);
act_obj.cpp:                ch->oreply = victim;
act_obj.cpp:        ch->oreply = victim;
act_obj.cpp:    if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_GIVE ) )
act_obj.cpp:        p_give_trigger( NULL, NULL, ch->in_room, ch, obj, TRIG_GIVE );
act_obj.cpp:    obj =  get_obj_list(ch,argument,ch->carrying);
act_obj.cpp:            af.level     = ch->level * percent / 100;
act_obj.cpp:            af.duration  = ch->level * percent / 100;
act_obj.cpp:    for (fountain = ch->in_room->contents; fountain != NULL;
act_obj.cpp:        for (obj = ch->in_room->contents; obj; obj = obj->next_content)
act_obj.cpp:    if (!IS_NPC (ch) && ch->pcdata->condition[COND_DRUNK] > 10)
act_obj.cpp:        && ch->pcdata->condition[COND_FULL] > 45)
act_obj.cpp:    if (!IS_NPC (ch) && ch->pcdata->condition[COND_DRUNK] > 10)
act_obj.cpp:    if (!IS_NPC (ch) && ch->pcdata->condition[COND_FULL] > 60)
act_obj.cpp:    if (!IS_NPC (ch) && ch->pcdata->condition[COND_THIRST] > 60)
act_obj.cpp:		if (obj->pIndexData->vnum == OBJ_VNUM_BERRY && ch->hit < ch->max_hit)
act_obj.cpp:		    ch->hit += obj->value[1];
act_obj.cpp:		    if (ch->hit > ch->max_hit) ch->hit = ch->max_hit;
act_obj.cpp:                condition = ch->pcdata->condition[COND_HUNGER];
act_obj.cpp:                if (condition == 0 && ch->pcdata->condition[COND_HUNGER] > 0)
act_obj.cpp:                else if (ch->pcdata->condition[COND_FULL] > 40)
act_obj.cpp:	      ch->pcdata->condition[COND_FULL] += 2;
act_obj.cpp:	      ch->pcdata->condition[COND_HUNGER] += 2;
act_obj.cpp:        if (weapon != NULL && ch->size < SIZE_LARGE
act_obj.cpp:        if (!IS_NPC (ch) && ch->size < SIZE_LARGE
act_obj.cpp:        for (obj = ch->carrying; obj != NULL; obj = obj_next)
act_obj.cpp:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.cpp:    if (ch->questpoints < 0)
act_obj.cpp:    if (donation > ch->questpoints || donation < 0 || donation > 30000)
act_obj.cpp:    clan_table[ch->clan].roster.questpoints += donation;
act_obj.cpp:    ch->questpoints -= donation;
act_obj.cpp:    save_one_roster(ch->clan);
act_obj.cpp:    if ((obj = get_obj_list(ch, arg, ch->in_room->contents)) == NULL)
act_obj.cpp:    for (obj = ch->in_room->contents; obj != NULL ; obj = obj_next)
act_obj.cpp:    if (arg[0] == '\0' || !str_cmp (arg, ch->name))
act_obj.cpp:    obj = get_obj_list (ch, arg, ch->in_room->contents);
act_obj.cpp:        for (gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room)
act_obj.cpp:            if (gch->on == obj)
act_obj.cpp:    if (obj->item_type == ITEM_CORPSE_PC && str_cmp(ch->name, obj->owner))
act_obj.cpp:    ch->silver += silver;
act_obj.cpp:    if (IS_SET (ch->act, PLR_AUTOSPLIT))
act_obj.cpp:        for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room)
act_obj.cpp:    if (ch->level < obj->level)
act_obj.cpp:      ch->pcdata->condition[COND_FULL] += 4;
act_obj.cpp:      ch->pcdata->condition[COND_THIRST] +=4;
act_obj.cpp:    if (ch->level < scroll->level)
act_obj.cpp:        if (ch->level < staff->level
act_obj.cpp:            for (vch = ch->in_room->people; vch; vch = vch_next)
act_obj.cpp:                vch_next = vch->next_in_room;
act_obj.cpp:    if (arg[0] == '\0' && ch->fighting == NULL)
act_obj.cpp:        if (ch->fighting != NULL)
act_obj.cpp:            victim = ch->fighting;
act_obj.cpp:        if (ch->level < wand->level
act_obj.cpp:    if (GET_HITROLL(ch) < (ch->level + 20) || GET_DAMROLL(ch) < (ch->level + 20))
act_obj.cpp:       sprintf(buf, "H - %d D - %d", ch->hitroll, ch->damroll);    
act_obj.cpp:    if (!IS_NPC(victim) && IS_SET(ch->act, PLR_QUESTING))
act_obj.cpp:    if (!IS_NPC(victim) && IS_SET(ch->act, PLR_TOURNEY))
act_obj.cpp:    if (ch->pcdata->wait_timer > 0)
act_obj.cpp:      ch->pcdata->wait_timer = 0;  
act_obj.cpp:    percent += ch->level > victim->level ? (ch->level - victim->level) :
act_obj.cpp:               (ch->level - victim->level) * 2;
act_obj.cpp:    if (!str_cmp("assassin", class_table[ch->cClass].name))
act_obj.cpp:    if (!str_cmp("rogue", class_table[ch->cClass].name))
act_obj.cpp:        sprintf(buf, "%s tried to steal from %s, but failed.\n\r", ch->name, victim->name);
act_obj.cpp:        STR_REMOVE_BIT (ch->affected_by, AFF_SNEAK);
act_obj.cpp:        STR_REMOVE_BIT (ch->affected_by, AFF_HIDE);
act_obj.cpp:        STR_REMOVE_BIT (ch->affected_by, AFF_SHROUD);
act_obj.cpp:                         can_see(victim,ch)?PERS(ch,victim,FALSE):"Someone", (ch->sex == 2) ? "her" : "his");
act_obj.cpp:		ch->name,ch->level,victim->name,victim->level);
act_obj.cpp:        gold = victim->gold * number_range (1, ch->level) / MAX_LEVEL;
act_obj.cpp:        silver = victim->silver * number_range (1, ch->level) / MAX_LEVEL;
act_obj.cpp:              ch->name,ch->level,victim->name,victim->level);
act_obj.cpp:          ch->pcdata->pk_timer = 120;
act_obj.cpp:	  ch->pcdata->safe_timer = 0;        
act_obj.cpp:        ch->gold += gold;
act_obj.cpp:        ch->silver += silver;
act_obj.cpp:  	 	    ch->name,ch->level,gold,silver,victim->name,victim->level);
act_obj.cpp:        || ((ch->level < 70)
act_obj.cpp:            && ch->level <= obj->level))
act_obj.cpp:    if (ch->carry_number + get_obj_number (obj) > can_carry_n (ch))
act_obj.cpp:    if (ch->carry_weight + get_obj_weight (obj) > can_carry_w (ch))
act_obj.cpp:		ch->name,ch->level,obj->name,victim->name,victim->level);
act_obj.cpp:          ch->pcdata->pk_timer = 120;
act_obj.cpp:	  ch->pcdata->safe_timer = 0;
act_obj.cpp:    for (keeper = ch->in_room->people; keeper; keeper = keeper->next_in_room)
act_obj.cpp:     if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_KILLER) )
act_obj.cpp:     sprintf(buf, "%s the KILLER is over here!\n\r", ch->name);
act_obj.cpp:     if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_THIEF) )
act_obj.cpp:     sprintf(buf, "%s the THIEF is over here!\n\r", ch->name);
act_obj.cpp:    for (t_obj = ch->carrying; t_obj != NULL; t_obj = t_obj_next)
act_obj.cpp:        obj->next_content = ch->carrying;
act_obj.cpp:        ch->carrying = obj;
act_obj.cpp:    ch->carry_number += get_obj_number (obj);
act_obj.cpp:    ch->carry_weight += get_obj_weight (obj);
act_obj.cpp:    if (ch->in_room->store != NULL)
act_obj.cpp:    if (IS_SET (ch->in_room->room_flags, ROOM_PET_SHOP))
act_obj.cpp:        if (ch->in_room->vnum == 9621)
act_obj.cpp:            pRoomIndexNext = get_room_index (ch->in_room->vnum + 1);
act_obj.cpp:            bug ("Do_buy: bad pet shop at vnum %d.", ch->in_room->vnum);
act_obj.cpp:        in_room = ch->in_room;
act_obj.cpp:        ch->in_room = pRoomIndexNext;
act_obj.cpp:        ch->in_room = in_room;
act_obj.cpp:        if (ch->pet != NULL)
act_obj.cpp:        if ((ch->silver + 100 * ch->gold) < cost)
act_obj.cpp:        if (ch->level < pet->level)
act_obj.cpp:          char_to_room(pet, ch->in_room);
act_obj.cpp:                 pet->description, ch->name);
act_obj.cpp:        char_to_room (pet, ch->in_room);
act_obj.cpp:        ch->pet = pet;
act_obj.cpp:            ch->oreply = keeper;
act_obj.cpp:                ch->oreply = keeper;
act_obj.cpp:        if ((ch->silver + ch->gold * 100) < cost * number)
act_obj.cpp:            ch->oreply = keeper;
act_obj.cpp:            ch->oreply = keeper;
act_obj.cpp:        if (ch->carry_number + number * get_obj_number (obj) >
act_obj.cpp:        if (ch->carry_weight + number * get_obj_weight (obj) >
act_obj.cpp:    if (ch->in_room->store != NULL)
act_obj.cpp:    if (IS_SET (ch->in_room->room_flags, ROOM_PET_SHOP))
act_obj.cpp:        if (ch->in_room->vnum == 9621)
act_obj.cpp:            pRoomIndexNext = get_room_index (ch->in_room->vnum + 1);
act_obj.cpp:            bug ("Do_list: bad pet shop at vnum %d.", ch->in_room->vnum);
act_obj.cpp:        ch->oreply = keeper;
act_obj.cpp:    ch->gold += cost / 100;
act_obj.cpp:    ch->silver += cost - (cost / 100) * 100;
act_obj.cpp:        ch->oreply = keeper;
act_obj.cpp:    ch->oreply = keeper;
act_obj.cpp:    if (ch->clan != clan_lookup("Furies"))
act_obj.cpp:    obj = get_obj_list (ch, argument, ch->carrying);
act_obj.cpp:        if (ch->mana > 50)
act_obj.cpp:            af.level = (ch->level);
act_obj.cpp:            af.duration = (ch->level / 3);
act_obj.cpp:    obj->level = ch->level / 3;
act_obj.cpp:    obj->cost = ch->level * 3;
act_obj.cpp:    obj->value[0] = ch->level * 20;
act_obj.cpp:    obj->value[3] = ch->level * 3;
act_obj.cpp:            obj_to_room( obj, ch->in_room );
act_obj.cpp:	    ch->move -= 50;
act_skills.cpp:    if (ch->pcdata->couple[i].cast == cast)
act_skills.cpp:  if (ch->pcdata->couple[i].cast == skill_lookup("gas breath"))
act_skills.cpp:  sn = ch->pcdata->couple[i].couple;
act_skills.cpp:                     100 / (2 + ch->level -
act_skills.cpp:                            skill_table[sn].skill_level[ch->cClass]));
act_skills.cpp:  if (ch->mana < mana)
act_skills.cpp:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, vo, target);
act_skills.cpp:    ch->mana -= mana;
act_skills.cpp:           skill_table[ch->pcdata->couple[i].cast].name, 
act_skills.cpp:           skill_table[ch->pcdata->couple[i].couple].name);
act_skills.cpp:    ch->pcdata->couple[number].cast = 0;
act_skills.cpp:    ch->pcdata->couple[number].couple = 0;
act_skills.cpp:  if (ch->pcdata->learned[sn1] < 1)
act_skills.cpp:  if (ch->pcdata->learned[sn2] < 1)
act_skills.cpp:  ch->pcdata->couple[number].cast = sn1;
act_skills.cpp:  ch->pcdata->couple[number].couple = sn2;
act_skills.cpp:	if (ch->fighting != NULL)
act_skills.cpp:      if (victim->pcdata->pk_timer >= 1 || ch->pcdata->pk_timer >= 1)
act_skills.cpp:    if (IS_SET(ch->in_room->room_flags, ROOM_SAFE) && !PK && !IS_IMMORTAL(ch))
act_skills.cpp:    if (ch->fighting != NULL || victim->fighting != NULL)
act_skills.cpp:    af.level     = ch->level;
act_skills.cpp:    af.duration  = ch->level / 10;
act_skills.cpp:    af.level     = ch->level;
act_skills.cpp:    af.duration  = ch->level / 10;
act_skills.cpp:    obj = get_obj_list( ch, arg1, ch->in_room->contents );
act_skills.cpp:    if (IS_SET(ch->in_room->room_flags, ROOM_NOPUSH))
act_skills.cpp:    ||   IS_SET(ch->in_room->room_flags, ROOM_SAFE)
act_skills.cpp:    ||   IS_SET(ch->in_room->room_flags, ROOM_PRIVATE)
act_skills.cpp:    ||   IS_SET(ch->in_room->room_flags, ROOM_SOLITARY)
act_skills.cpp:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
act_skills.cpp:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
act_skills.cpp:    if ( ch->move > 10 )
act_skills.cpp:	ch->move -= 10;
act_skills.cpp:    ||     (number_percent() < (victim->size - ch->size) * 17))
act_skills.cpp:    if ( ch->move > 10 )
act_skills.cpp:	ch->move -= 10;
act_skills.cpp:    &&   ch->level < skill_table[gsn_lore].skill_level[ch->cClass] )
act_skills.cpp:  chance -= (victim->level - ch->level) / 2;
act_skills.cpp:    STR_REMOVE_BIT(ch->affected_by, AFF_SNEAK);
act_skills.cpp:    sprintf(buf, "%s tried to open your bag.\n\r", can_see(victim, ch)? ch->name : "Someone");
act_skills.cpp:    sprintf(buf, "%s tried to open $N's bag.\n\r", can_see(victim, ch)? ch->name : "Someone");
act_skills.cpp:    percent += (ch->level - victim->level);
act_skills.cpp:    if (!str_cmp("assassin", class_table[ch->cClass].name))
act_skills.cpp:    if (!str_cmp("rogue", class_table[ch->cClass].name))
act_skills.cpp:        STR_REMOVE_BIT (ch->affected_by, AFF_SNEAK);
act_skills.cpp:                         can_see(victim,ch)?PERS(ch,victim,FALSE):"Someone", (ch->sex == 2) ? "her" : "his");
act_skills.cpp:        || ((ch->level < 70)
act_skills.cpp:            && ch->level <= obj->level))
act_skills.cpp:    if (ch->carry_number + get_obj_number (obj) > can_carry_n (ch))
act_skills.cpp:    if (ch->carry_weight + get_obj_weight (obj) > can_carry_w (ch))
act_skills.cpp:      if (victim->pcdata->pk_timer >= 1 || ch->pcdata->pk_timer >= 1)
act_skills.cpp:    if (IS_SET(ch->in_room->room_flags, ROOM_SAFE) && !PK && !IS_IMMORTAL(ch))
act_skills.cpp:    if (ch->fighting != NULL || victim->fighting != NULL)
act_skills.cpp:     if (ch->silver < 100)
act_skills.cpp:     ch->silver -= 100;
act_skills.cpp:  if ( ch->level < skill_table[sn].skill_level[ch->cClass])
act_skills.cpp:  if ( ch->pcdata->learned[sn])
act_skills.cpp:  ch->pcdata->learned[sn] = 75;
act_skills.cpp:    from_room = ch->in_room;
act_skills.cpp:    ||   (ch->level + 10 < victim->level )
act_skills.cpp:           IS_SET(ch->act,PLR_HOLYLIGHT))) )
act_skills.cpp:   if ( !IS_NPC(ch) && !IS_SET(ch->comm, COMM_BRIEF) )
act_skills.cpp:   if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOEXIT) )
act_wiz.cpp:    pArea = ch->in_room->area;
act_wiz.cpp:    pArea = ch->in_room->area;
act_wiz.cpp:    pArea = ch->in_room->area;
act_wiz.cpp:    for ( questman = ch->in_room->people; questman != NULL; questman = questman->next_in_room )
act_wiz.cpp:  if (ch->clan != clan_lookup("Guide") && !IS_IMMORTAL(ch))
act_wiz.cpp:    if (IS_SET(ch->comm, COMM_NOVICE))
act_wiz.cpp:       REMOVE_BIT(ch->comm, COMM_NOVICE);
act_wiz.cpp:       vch_next = vch->next;
act_wiz.cpp:       voteinfo.voters = vch->next;
act_wiz.cpp:       level = ch ? ch->level : 200;
act_wiz.cpp:     (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vo, target);
act_wiz.cpp:  if (ch->level < 81)
act_wiz.cpp:    if (  ( ch->pcdata->pwd != '\0' )
act_wiz.cpp:    if ((victim->level >= ch->level)/* && !IS_OWNER(ch) */)
act_wiz.cpp:        if (IS_SET (ch->wiznet, WIZ_ON))
act_wiz.cpp:            REMOVE_BIT (ch->wiznet, WIZ_ON);
act_wiz.cpp:            SET_BIT (ch->wiznet, WIZ_ON);
act_wiz.cpp:        SET_BIT (ch->wiznet, WIZ_ON);
act_wiz.cpp:        REMOVE_BIT (ch->wiznet, WIZ_ON);
act_wiz.cpp:        if (!IS_SET (ch->wiznet, WIZ_ON))
act_wiz.cpp:            if (IS_SET (ch->wiznet, wiznet_table[flag].flag))
act_wiz.cpp:    if (IS_SET (ch->wiznet, wiznet_table[flag].flag))
act_wiz.cpp:        REMOVE_BIT (ch->wiznet, wiznet_table[flag].flag);
act_wiz.cpp:        SET_BIT (ch->wiznet, wiznet_table[flag].flag);
act_wiz.cpp:    if (!IS_HIIMMORTAL(ch) && ch->rank < 8)
act_wiz.cpp:    if (clan != ch->clan && !IS_IMMORTAL(ch)) 
act_wiz.cpp:      if (!str_prefix(arg2, "none") && victim->clan == ch->clan)
act_wiz.cpp:	      if (ch->pcdata->learned[*weapon_table[i].gsn] == 40)
act_wiz.cpp:	paf.level	= ch->level;
act_wiz.cpp:    if (!IS_NPC (ch) && IS_SET (ch->comm, COMM_NOEMOTE))
act_wiz.cpp:    if (strstr (argument, ch->name) == NULL)
act_wiz.cpp:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
act_wiz.cpp:        if (vch->desc == NULL || vch == ch)
act_wiz.cpp:        if ((letter = strstr (argument, vch->name)) == NULL)
act_wiz.cpp:        name = vch->name;
act_wiz.cpp:            if (*letter == '\'' && matches == int(strlen (vch->name)))
act_wiz.cpp:            if (*letter == 's' && matches == int(strlen (vch->name)))
act_wiz.cpp:            if (matches == int(strlen (vch->name)))
act_wiz.cpp:                if (matches == int(strlen (vch->name)))
act_wiz.cpp:                    name = vch->name;
act_wiz.cpp:            name = vch->name;
act_wiz.cpp:            sprintf (buf, "Your poofin is %s\n\r", ch->pcdata->bamfin);
act_wiz.cpp:        if (strstr (tempbuf, ch->name) == NULL)
act_wiz.cpp:        free_string (ch->pcdata->bamfin);
act_wiz.cpp:        ch->pcdata->bamfin = str_dup (argument);
act_wiz.cpp:        sprintf (buf, "Your poofin is now %s\n\r", ch->pcdata->bamfin);
act_wiz.cpp:            sprintf (buf, "Your poofout is %s\n\r", ch->pcdata->bamfout);
act_wiz.cpp:        if (strstr (tempbuf, ch->name) == NULL)
act_wiz.cpp:        free_string (ch->pcdata->bamfout);
act_wiz.cpp:        ch->pcdata->bamfout = str_dup (argument);
act_wiz.cpp:        sprintf (buf, "Your poofout is now %s\n\r", ch->pcdata->bamfout);
act_wiz.cpp:            && d->character->in_room == ch->in_room)
act_wiz.cpp:            && d->character->in_room != NULL && ch->in_room != NULL
act_wiz.cpp:            && d->character->in_room->area == ch->in_room->area)
act_wiz.cpp:                && d->character->in_room == ch->in_room 
act_wiz.cpp:        location = ch->in_room;
act_wiz.cpp:    original = ch->in_room;
act_wiz.cpp:    on = ch->on;
act_wiz.cpp:    for (wch = char_list; wch != NULL; wch = wch->next)
act_wiz.cpp:            ch->on = on;
act_wiz.cpp:    for (rch = location->people; rch != NULL; rch = rch->next_in_room)
act_wiz.cpp:    if (ch->fighting != NULL)
act_wiz.cpp:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.cpp:        if (get_trust (rch) >= ch->invis_level)
act_wiz.cpp:            if (ch->pcdata != NULL && ch->pcdata->bamfout[0] != '\0')
act_wiz.cpp:                act ("$t", ch, ch->pcdata->bamfout, rch, TO_VICT);
act_wiz.cpp:    if (ch->is_mounted && ch->mount)
act_wiz.cpp:      char_from_room (ch->mount);
act_wiz.cpp:      char_to_room (ch->mount, location);
act_wiz.cpp:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.cpp:        if (get_trust (rch) >= ch->invis_level)
act_wiz.cpp:            if (ch->pcdata != NULL && ch->pcdata->bamfin[0] != '\0')
act_wiz.cpp:                act ("$t", ch, ch->pcdata->bamfin, rch, TO_VICT);
act_wiz.cpp:    if (ch->fighting != NULL)
act_wiz.cpp:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.cpp:        if (get_trust (rch) >= ch->invis_level)
act_wiz.cpp:            if (ch->pcdata != NULL && ch->pcdata->bamfout[0] != '\0')
act_wiz.cpp:                act ("$t", ch, ch->pcdata->bamfout, rch, TO_VICT);
act_wiz.cpp:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.cpp:        if (get_trust (rch) >= ch->invis_level)
act_wiz.cpp:            if (ch->pcdata != NULL && ch->pcdata->bamfin[0] != '\0')
act_wiz.cpp:                act ("$t", ch, ch->pcdata->bamfin, rch, TO_VICT);
act_wiz.cpp:    location = (arg[0] == '\0') ? ch->in_room : find_location (ch, arg);
act_wiz.cpp:    if (!is_room_owner (ch, location) && ch->in_room != location
act_wiz.cpp:    for (rch = location->people; rch; rch = rch->next_in_room)
act_wiz.cpp:            one_argument (rch->name, buf);
act_wiz.cpp:             pc_race_table[ch->race].stats[STAT_STR],
act_wiz.cpp:             pc_race_table[ch->race].stats[STAT_INT],
act_wiz.cpp:             pc_race_table[ch->race].stats[STAT_WIS],
act_wiz.cpp:             pc_race_table[ch->race].stats[STAT_DEX],
act_wiz.cpp:             pc_race_table[ch->race].stats[STAT_CON], get_curr_stat (victim, STAT_CON));
act_wiz.cpp:            || (ch->level < obj->level && ch->level != MAX_LEVEL &&
act_wiz.cpp:                !strstr(obj->pIndexData->area->builders, ch->name)))
act_wiz.cpp:    if (ch->invis_level < LEVEL_HERO)
act_wiz.cpp:        sprintf (buf, "Reboot by %s.", ch->name);
act_wiz.cpp:    if (ch->invis_level < LEVEL_HERO)
act_wiz.cpp:        sprintf (buf, "Shutdown by %s.", ch->name);
act_wiz.cpp:    if (ch->invis_level < LEVEL_HERO)
act_wiz.cpp:            if (d->snoop_by == ch->desc)
act_wiz.cpp:    if (!is_room_owner (ch, victim->in_room) && ch->in_room != victim->in_room
act_wiz.cpp:    if (ch->desc != NULL)
act_wiz.cpp:        for (d = ch->desc->snoop_by; d != NULL; d = d->snoop_by)
act_wiz.cpp:    victim->desc->snoop_by = ch->desc;
act_wiz.cpp:    if (ch->desc->editor != 0)
act_wiz.cpp:    if (ch->desc == NULL)
act_wiz.cpp:    if (ch->desc->original != NULL)
act_wiz.cpp:    if (!is_room_owner (ch, victim->in_room) && ch->in_room != victim->in_room
act_wiz.cpp:    ch->desc->character = victim;
act_wiz.cpp:    ch->desc->original = ch;
act_wiz.cpp:    victim->desc = ch->desc;
act_wiz.cpp:    ch->desc = NULL;
act_wiz.cpp:    if (ch->prompt != NULL)
act_wiz.cpp:        victim->prompt = str_dup (ch->prompt);
act_wiz.cpp:    victim->comm = ch->comm;
act_wiz.cpp:    victim->lines = ch->lines;
act_wiz.cpp:    if (ch->desc == NULL)
act_wiz.cpp:    if (ch->desc->original == NULL)
act_wiz.cpp:    if (ch->prompt != NULL)
act_wiz.cpp:        free_string (ch->prompt);
act_wiz.cpp:        ch->prompt = NULL;
act_wiz.cpp:    sprintf (buf, "$N returns from %s.", ch->short_descr);
act_wiz.cpp:    wiznet (buf, ch->desc->original, 0, WIZ_SWITCHES, WIZ_SECURE,
act_wiz.cpp:    ch->desc->character = ch->desc->original;
act_wiz.cpp:    ch->desc->original = NULL;
act_wiz.cpp:    ch->desc->character->desc = ch->desc;
act_wiz.cpp:    ch->desc = NULL;
act_wiz.cpp:            obj_to_room (clone, ch->in_room);
act_wiz.cpp:        char_to_room (clone, ch->in_room);
act_wiz.cpp:    char_to_room (victim, ch->in_room);
act_wiz.cpp:	     ch->name, obj->pIndexData->vnum, obj->id);
act_wiz.cpp:        obj_to_room (obj, ch->in_room);
act_wiz.cpp:    if (ch->level != MAX_LEVEL)
act_wiz.cpp:        for (victim = ch->in_room->people; victim != NULL; victim = vnext)
act_wiz.cpp:        for (obj = ch->in_room->contents; obj != NULL; obj = obj_next)
act_wiz.cpp:            sprintf (buf, "%s tried to purge you!\n\r", ch->name);
act_wiz.cpp:        for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
act_wiz.cpp:            if (!IS_NPC(vch) && vch->pcdata->pk_timer > 0)
act_wiz.cpp:            vch->hit = vch->max_hit;
act_wiz.cpp:            vch->mana = vch->max_mana;
act_wiz.cpp:            vch->move = vch->max_move;
act_wiz.cpp:        sprintf (buf, "$N restored room %ld.", ch->in_room->vnum);
act_wiz.cpp:    if ((get_trust (ch) >= MAX_LEVEL - 1 || !str_cmp(ch->name,"Creator")) && !str_cmp (arg, "all"))
act_wiz.cpp:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.cpp:        if (rch->fighting != NULL)
act_wiz.cpp:        if (IS_NPC (rch) && IS_SET (rch->act, ACT_AGGRESSIVE))
act_wiz.cpp:           REMOVE_BIT (rch->act, ACT_AGGRESSIVE);
act_wiz.cpp:        if (value > ch->pcdata->security || value < 0)
act_wiz.cpp:            if (ch->pcdata->security != 0)
act_wiz.cpp:                         ch->pcdata->security);
act_wiz.cpp:  if (victim->level > ch->level)
act_wiz.cpp:        if (!str_prefix (arg1, "acebo") && !str_cmp (ch->name, "Dreyus"))
act_wiz.cpp:    if (!is_room_owner (ch, location) && ch->in_room != location
act_wiz.cpp:           strftime( s, 100, "%I:%M%p", localtime( &vch->logon ) );
act_wiz.cpp:             if ( vch->timer > 0 )
act_wiz.cpp:              sprintf( idle, "%-2d", vch->timer );
act_wiz.cpp:            vch_next = vch->next;
act_wiz.cpp:            vch_next = vch->next;
act_wiz.cpp:                && vch->level < LEVEL_HERO)
act_wiz.cpp:            vch_next = vch->next;
act_wiz.cpp:                && vch->level >= LEVEL_HERO)
act_wiz.cpp:            && ch->in_room != victim->in_room
act_wiz.cpp:        if (ch->invis_level)
act_wiz.cpp:            ch->invis_level = 0;
act_wiz.cpp:            ch->invis_level = LEVEL_IMMORTAL;
act_wiz.cpp:            ch->oreply = NULL;
act_wiz.cpp:            ch->invis_level = level;
act_wiz.cpp:        if (ch->incog_level)
act_wiz.cpp:            ch->incog_level = 0;
act_wiz.cpp:            ch->incog_level = get_trust (ch);
act_wiz.cpp:            ch->oreply = NULL;
act_wiz.cpp:            ch->incog_level = level;
act_wiz.cpp:    if (IS_SET (ch->act, PLR_HOLYLIGHT))
act_wiz.cpp:        REMOVE_BIT (ch->act, PLR_HOLYLIGHT);
act_wiz.cpp:        SET_BIT (ch->act, PLR_HOLYLIGHT);
act_wiz.cpp:        if (ch->prefix[0] == '\0')
act_wiz.cpp:        free_string (ch->prefix);
act_wiz.cpp:        ch->prefix = str_dup ("");
act_wiz.cpp:    if (ch->prefix[0] != '\0')
act_wiz.cpp:        free_string (ch->prefix);
act_wiz.cpp:    ch->prefix = str_dup (argument);
act_wiz.cpp:          if (ch->invis_level < LEVEL_HERO)
act_wiz.cpp:    	    sprintf(buf,"`&Copyover cancelled by`# %s.`*", ch->name);
act_wiz.cpp:    if (ch->invis_level < LEVEL_HERO)
act_wiz.cpp:      sprintf(buf,"`&Copyover in `!%d `&tick%s started by `#%s.`*", copytimer, copytimer == 1 ? "" : "s", ch->name);
act_wiz.cpp:              ch->name);
act_wiz.cpp:               d->descriptor, och->name,
act_wiz.cpp:             fprintf (fp, "%d %s %s\n", d->descriptor, och->name, dns_gethostname(d->host));
act_wiz.cpp:// Old before threaded fprintf (fp, "%d %s %s\n", d->descriptor, och->name, d->host);
act_wiz.cpp:            if (och->level == 1)
act_wiz.cpp:              fch_next = fch->next;
act_wiz.cpp:              if (d->character->id == fch->id)
act_wiz.cpp:  if (arg1[0] == '\0' && ch->clan >= 1)
act_wiz.cpp:    sprintf(buf, "%s ranks:\n\r\n\r", clan_table[ch->clan].who_name);
act_wiz.cpp:    for (rank = 0;rank < clan_table[ch->clan].top_rank;rank++)
act_wiz.cpp:      sprintf(buf, "%d: %s\n\r", rank + 1, clan_table[ch->clan].rank[rank]);
act_wiz.cpp:  if (ch->rank < (clan_table[ch->clan].top_rank - 2) && !IS_IMMORTAL(ch))
act_wiz.cpp:  if (!IS_IMMORTAL(ch) && rank >= ch->rank)
act_wiz.cpp:  if (ch->clan != victim->clan && !IS_IMMORTAL(ch))
act_wiz.cpp:  if ((ch->rank < (clan_table[ch->clan].top_rank - 2) || victim->rank > ch->rank) && !IS_IMMORTAL(ch))
act_wiz.cpp:    char_to_room( d.character, ch->in_room); /* put in room imm is in */
act_wiz.cpp:		wch->name,
act_wiz.cpp:		wch->level,
act_wiz.cpp:		wch->pcdata->security,
act_wiz.cpp:		wch->cClass,
act_wiz.cpp:		wch->max_hit,
act_wiz.cpp:		wch->max_mana,
act_wiz.cpp:		wch->max_move,
act_wiz.cpp:		wch->questpoints,
act_wiz.cpp:		wch->race
act_wiz.cpp:    if (ch->level < 81)
act_wiz.cpp:    	chroom = ch->in_room;
act_wiz.cpp:	      char_to_room(victim, ch->in_room);
act_wiz.cpp:        if(ch->level < MAX_LEVEL )
act_wiz.cpp:    if ( ch->gold < 5 )
act_wiz.cpp:    ch->gold -= 5;
act_wiz.cpp:        ch->gold += 15;
act_wiz.cpp:            if ( ch->gold > 5000 )
act_wiz.cpp:        ch->gold += slotwin;
act_wiz.cpp:			sprintf(buf,"%s has awarded you with %d RP points for your great role-playing!\n\r",ch->name,award);
act_wiz.cpp:			sprintf(buf,"%s has awarded %d rp points to %s.\n\r",ch->name,award,victim->name);
act_wiz.cpp:			sprintf(buf,"%s has removed %d RP points as a punishment!\n\r",ch->name,award);
act_wiz.cpp:			sprintf(buf,"%s has awarded %d rp points to %s.\n\r",ch->name,award,victim->name);
act_wiz.cpp:			sprintf(buf,"%s has awarded you with %d RP experience for your great role-playing!\n\r",ch->name,award);
act_wiz.cpp:			sprintf(buf,"%s has awarded %d rp exp to %s.\n\r",ch->name,award,victim->name);
act_wiz.cpp:			sprintf(buf,"%s has removed %d RP experience as a punishment!\n\r",ch->name,award);
act_wiz.cpp:			sprintf(buf,"%s has awarded %d rp exp to %s.\n\r",ch->name,award,victim->name);
act_wiz.cpp:    if(IS_IMMORTAL(victim) && ch->level <= victim->level && str_cmp (ch->name,"Cammaedros"))
act_wiz.cpp:        for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
act_wiz.cpp:        sprintf(buf,"$N unrestored room %ld.",ch->in_room->vnum);
act_wiz.cpp:    if IS_SET(ch->act2, PLR_WAR)
act_wiz.cpp:    if (ch->level <= 10)
act_wiz.cpp:    if (ch->clan == (clan_lookup("None") || (ch->clan == (clan_lookup("Tinker")))))
act_wiz.cpp:    SET_BIT(ch->act2, PLR_WAR);
act_wiz.cpp:    if (!IS_SET(ch->act2, PLR_WAR))
act_wiz.cpp:    if (ch->pcdata->pk_timer > 0)
act_wiz.cpp:    REMOVE_BIT(ch->act2, PLR_WAR);
act_wiz.cpp:    sprintf(buf,"`&A `!War`& has been declared by`# %s.`*", ch->name);
act_wiz.cpp:  if (!IS_NPC(ch) && ch->clan != clan_lookup("Guide") && !IS_IMMORTAL(ch))
act_wiz.cpp:  if (ch->clan == clan_lookup("Guide") && ch->rank <= 2)
act_wiz.cpp:    sprintf(buf, "%s of Guide has increased %s's punishment counter\n",ch->name,victim->name);
act_wiz.cpp:    sprintf(buf, "%s of Guide has decreased %s's punishment counter\n",ch->name,victim->name);
act_wiz.cpp:  if (!IS_NPC(ch) && ch->clan != clan_lookup("Guide") && !IS_IMMORTAL(ch))
act_wiz.cpp:  if (ch->rank <= 2)
act_wiz.cpp:    sprintf(buf,"You have been found guilty of murder by %s\n",ch->name);
act_wiz.cpp:    sprintf(buf,"%s of Guide has found %s guilty of murder! %i ticks!\n",ch->name,victim->name, value);
act_wiz.cpp:    sprintf(buf,"You have been found guilty of thievery by %s\n",ch->name);
act_wiz.cpp:    sprintf(buf,"%s of Guide has found %s guilty of thievery! %i ticks!\n",ch->name,victim->name, value);
act_wiz.cpp:  if (!IS_NPC(ch)&&ch->clan != clan_lookup("Guide") && !IS_IMMORTAL(ch))
act_wiz.cpp:  if (ch->rank < 2)
act_wiz.cpp:  sprintf (buf,"%s chains up %s and drags him away to jail!", ch->name,victim->name);
act_wiz.cpp:    if (!IS_NPC(ch)&& ch->clan != clan_lookup("Guide") && !IS_IMMORTAL(ch))
act_wiz.cpp:    if (ch->rank < 2)
act_wiz.cpp:    	sprintf(buf,"You have been found guilty of murder by %s\n",ch->name);
act_wiz.cpp:    	sprintf(buf,"%s of Guide has found %s guilty of murder!\n",ch->name,victim->name);
act_wiz.cpp:    	sprintf(buf,"You have been found guilty of thievery by %s\n",ch->name);
act_wiz.cpp:    	sprintf(buf,"%s of Guide has found %s guilty of thievery!\n",ch->name,victim->name);
act_wiz.cpp:    if (!IS_NPC(ch)&&ch->clan != clan_lookup("Guide") && !IS_IMMORTAL(ch))
act_wiz.cpp:    if (ch->rank < 2)
act_wiz.cpp:    sprintf (buf,"%s chains up %s and drags him away to jail!", ch->name,victim->name);
act_wiz.cpp:    if (ch->clan != clan_lookup("Guide") && !IS_IMMORTAL(ch))
act_wiz.cpp:		pc_race_table[ch->race].stats[STAT_STR],
act_wiz.cpp:		pc_race_table[ch->race].stats[STAT_INT],
act_wiz.cpp:		pc_race_table[ch->race].stats[STAT_WIS],
act_wiz.cpp:		pc_race_table[ch->race].stats[STAT_DEX],
act_wiz.cpp:		pc_race_table[ch->race].stats[STAT_CON],
act_wiz.cpp:            vnum = ch->in_room ? ch->in_room->vnum : 0;
act_wiz.cpp:                ch->name, vnum, buf, str );
act_wiz.cpp:            fprintf( fp, "[`7%-10s`$]`3 %s`*`3:`* %s\n", ch->name, buf, str );
act_wiz.cpp:	parea = ch->in_room ? ch->in_room->area : NULL;
alias.cpp:    if (ch->prefix[0] != '\0' && str_prefix ("prefix", argument))
alias.cpp:        if (strlen (ch->prefix) + strlen (argument) > MAX_INPUT_LENGTH)
alias.cpp:            sprintf (prefix, "%s %s", ch->prefix, argument);
alias.cpp:    if (IS_NPC (ch) || ch->pcdata->alias[0] == NULL
alias.cpp:        if (ch->pcdata->alias[alias] == NULL)
alias.cpp:        if (!str_prefix (ch->pcdata->alias[alias], argument))
alias.cpp:            if (!strcmp (ch->pcdata->alias[alias], name))
alias.cpp:                strcat (buf, ch->pcdata->alias_sub[alias]);
alias.cpp:    if (ch->desc == NULL)
alias.cpp:        rch = ch->desc->original ? ch->desc->original : ch;
alias.cpp:        if (rch->pcdata->alias[0] == NULL)
alias.cpp:            if (rch->pcdata->alias[pos] == NULL
alias.cpp:                || rch->pcdata->alias_sub[pos] == NULL)
alias.cpp:            sprintf (buf, "    %s:  %s\n\r", rch->pcdata->alias[pos],
alias.cpp:                     rch->pcdata->alias_sub[pos]);
alias.cpp:            if (rch->pcdata->alias[pos] == NULL
alias.cpp:                || rch->pcdata->alias_sub[pos] == NULL)
alias.cpp:            if (!str_cmp (arg, rch->pcdata->alias[pos]))
alias.cpp:                         rch->pcdata->alias[pos],
alias.cpp:                         rch->pcdata->alias_sub[pos]);
alias.cpp:        if (rch->pcdata->alias[pos] == NULL)
alias.cpp:        if (!str_cmp (arg, rch->pcdata->alias[pos]))
alias.cpp:            free_string (rch->pcdata->alias_sub[pos]);
alias.cpp:            rch->pcdata->alias_sub[pos] = str_dup (argument);
alias.cpp:    rch->pcdata->alias[pos] = str_dup (arg);
alias.cpp:    rch->pcdata->alias_sub[pos] = str_dup (argument);
alias.cpp:    if (ch->desc == NULL)
alias.cpp:        rch = ch->desc->original ? ch->desc->original : ch;
alias.cpp:        if (rch->pcdata->alias[pos] == NULL)
alias.cpp:            rch->pcdata->alias[pos - 1] = rch->pcdata->alias[pos];
alias.cpp:            rch->pcdata->alias_sub[pos - 1] = rch->pcdata->alias_sub[pos];
alias.cpp:            rch->pcdata->alias[pos] = NULL;
alias.cpp:            rch->pcdata->alias_sub[pos] = NULL;
alias.cpp:        if (!strcmp (arg, rch->pcdata->alias[pos]))
alias.cpp:            free_string (rch->pcdata->alias[pos]);
alias.cpp:            free_string (rch->pcdata->alias_sub[pos]);
alias.cpp:            rch->pcdata->alias[pos] = NULL;
alias.cpp:            rch->pcdata->alias_sub[pos] = NULL;
arena.cpp:  if (ch->level < min_level || ch->level > max_level)
arena.cpp:  if (IS_SET(ch->act, PLR_ARENA))
arena.cpp:      SET_BIT(ch->act, PLR_ARENA);
arena.cpp:      sprintf(buf, "&c%s &R(&cLevel &Y%d&R) joins the war!", ch->name, ch->level);
asciimap.cpp:if (strcmp(ch->name,"Kroudar"))
asciimap.cpp:MapArea(ch->in_room, ch, 80, 80, min, max); 
asciimap.cpp:strcpy(desc,ch->in_room->description);
asciimap.cpp:	sprintf(buf,"`7   `$%s`7",ch->in_room->name);
asciimap.cpp:        if (  !IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOEXIT)  ) { 
asciimap.cpp:  size=URANGE(ch->mapsize,size,MAX_MAP);
asciimap.cpp:  size=URANGE(ch->mapsize,size,MAX_MAP);
asciimap.cpp:MapArea(ch->in_room, ch, center, center, min-1, max-1); 
asciimap.cpp: pArea = ch->in_room->area;
asciimap.cpp: if (ch->in_room->sector_type == SECT_TAKEN || ch->in_room->sector_type == SECT_TOWER)
asciimap.cpp:      sprintf(buf, "`*%s\n\r", ch->in_room->description);
asciimap.cpp: if (ch->in_room->sector_type == SECT_EMPTY)
asciimap.cpp:      ch->in_room->name = "Unowned Territory";
asciimap.cpp:      ch->in_room->description = "This territory is waiting to be claimed.";
asciimap.cpp:      save_area (ch->in_room->area);
asciimap.cpp: if (IS_SET(ch->act2, PLR_WORLDMAP))
asciimap.cpp:if (IS_IMMORTAL(ch) && IS_SET(ch->act2, PLR_WORLDMAP)) {
asciimap.cpp:    ch->mapsize = value;
asciimap.cpp:  size=URANGE(ch->mapsize,size,MAX_MAP);
asciimap.cpp:  size=URANGE(ch->mapsize,size,MAX_MAP);
asciimap.cpp:MapArea(ch->in_room, ch, center, center, min-1, max-1);
asciimap.cpp:MapArea(ch->in_room, ch, center, center, min-1, max-1); 
asciimap.cpp:/*if (strcmp(ch->name, "Kroudar") ) {
asciimap.cpp:vnum=(ch->in_room->vnum);
asciimap.cpp:SET_BIT( ch->in_room->area->area_flags, AREA_CHANGED );
auction.cpp:	if ( IS_SET(ch->comm,COMM_NOAUCTION) )
auction.cpp:	    REMOVE_BIT(ch->comm,COMM_NOAUCTION );
auction.cpp:	SET_BIT(ch->comm,COMM_NOAUCTION);
auction.cpp:	if ( (ch->silver + 100 * ch->gold) < 500 )
auction.cpp:	if(ch->silver < 500)
auction.cpp:		(ch->gold -= 5);
auction.cpp:	    (ch->silver -= 500);
auction.cpp:	if(ch->level == MAX_LEVEL)
auction.cpp:        if ( obj->pk && ch->clan == clan_lookup("tinker"))
auction.cpp:	if ( (ch->silver + 100 * ch->gold) < bid )
auction.cpp:	silver = UMIN( ch->silver, bid );
auction.cpp:	ch->gold -= gold;
auction.cpp:	ch->silver -= silver;
bank.cpp:    if (ch->pcdata->pk_timer > 0)
bank.cpp:    if (!IS_SET(ch->in_room->room_flags, ROOM_BANK))
bank.cpp:      if (ch->gold < atoi(arg1))
bank.cpp:      if ((ch->gold_in_bank + atoi(arg1)) > 50000)
bank.cpp:      ch->gold -= atoi(arg1);
bank.cpp:      ch->gold_in_bank += atoi(arg1);
bank.cpp:      ch->gold_in_bank, ch->silver_in_bank);
bank.cpp:      if (ch->silver < atoi(arg1))
bank.cpp:      if ((ch->silver_in_bank + atoi(arg1)) > 1000000)
bank.cpp:      ch->silver -= atoi(arg1);
bank.cpp:      ch->silver_in_bank += atoi(arg1);
bank.cpp:      ch->gold_in_bank, ch->silver_in_bank);
bank.cpp:    if ((ch->last_bank - current_time) > 86400)
bank.cpp:        for (j = ( ch->last_bank - current_time ) / 86400; j != 0 ; j--)
bank.cpp:            ch->gold_in_bank += int(ch->gold_in_bank * .02);
bank.cpp:            ch->silver_in_bank += int(ch->silver_in_bank * .02);
bank.cpp:      ch->last_bank = time(NULL);
bank.cpp:    if ((ch->gold_in_bank > 50000) || ch->gold_in_bank < 0)
bank.cpp:        ch->gold_in_bank = 50000;
bank.cpp:    if ((ch->silver_in_bank > 1000000) || ch->gold_in_bank < 0)
bank.cpp:        ch->silver_in_bank = 1000000;
bank.cpp:    if (!IS_SET(ch->in_room->room_flags, ROOM_BANK))
bank.cpp:    ch->gold_in_bank, ch->silver_in_bank);
bank.cpp:    if (!IS_SET(ch->in_room->room_flags, ROOM_BANK))
bank.cpp:      if (ch->gold_in_bank < atoi(arg1))
bank.cpp:      ch->gold_in_bank -= atoi(arg1);
bank.cpp:      ch->gold += atoi(arg1);
bank.cpp:      ch->gold_in_bank, ch->silver_in_bank);
bank.cpp:      if (ch->silver_in_bank < atoi(arg1))
bank.cpp:      ch->silver_in_bank -= atoi(arg1);
bank.cpp:      ch->silver += atoi(arg1);
bank.cpp:      ch->gold_in_bank, ch->silver_in_bank);
bomb.cpp:        if (bomb_table[i].level < ch->level)
bomb.cpp:        if (bomb_table[i].level < ch->level && 
bomb.cpp:       if (bomb_table[i].level < ch->level && 
bomb.cpp:     bomb = create_object(get_obj_index(DUMMY_BOMB), ch->level);
bomb.cpp:     bomb->level = ch->level;
bomb.cpp:     bomb->value[3] = bomb_table[bombNumber].avedam + (ch->level * 3) + number_range(1, 25);
bomb.cpp:     bomb->owner = str_dup(ch->name);
bomb.cpp:  for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
bomb.cpp:  location = ch->in_room;
bomb.cpp:     vch_next = vch->next_in_room;
bomb.cpp:     vch_next = vch->next_in_room;
bomb.cpp:     vch_next = vch->next_in_room;
bomb.cpp:     if (!IS_NULLSTR(bomb->owner) && !str_cmp(bomb->owner, vch->name) && number_percent() > 50)
castles.cpp:	if (IS_SET(ch->in_room->room_flags, ROOM_AIEL) && (ch->clan == clan_lookup("Aiel")))
castles.cpp:	else if (IS_SET(ch->in_room->room_flags, ROOM_WHITECLOAK) && (ch->clan == clan_lookup("Whitecloak")))
castles.cpp:	else if (IS_SET(ch->in_room->room_flags, ROOM_SHADOW) && (ch->clan == clan_lookup("Shadow")))
castles.cpp:	else if (IS_SET(ch->in_room->room_flags, ROOM_SHAIDO) && (ch->clan == clan_lookup("Shaido")))
castles.cpp:	else if (IS_SET(ch->in_room->room_flags, ROOM_TINKER) && (ch->clan == clan_lookup("Tinker")))
castles.cpp:	else if (IS_SET(ch->in_room->room_flags, ROOM_ASHAMAN) &&  (ch->clan == clan_lookup("Ashaman")))
castles.cpp:    location = ch->in_room;
castles.cpp:    if (ch->clan == clan_lookup("Aiel"))
castles.cpp:	    if ( IS_SET(ch->in_room->room_flags, ROOM_AIEL))
castles.cpp:	    else if (ch->in_room->sector_type == SECT_TAKEN || ch->in_room->sector_type == SECT_TOWER || ch->in_room->sector_type == SECT_GATE)
castles.cpp:        SET_BIT(ch->in_room->room_flags, ROOM_AIEL);
castles.cpp:        save_area (ch->in_room->area);
castles.cpp:    else if (ch->clan == clan_lookup("Warder") || (ch->clan == clan_lookup("Aessedai")))
castles.cpp:	    if ( IS_SET(ch->in_room->room_flags, ROOM_WHITETOWER))
castles.cpp:	    else if (ch->in_room->sector_type == SECT_TAKEN)
castles.cpp:        SET_BIT(ch->in_room->room_flags, ROOM_WHITETOWER);
castles.cpp:        save_area (ch->in_room->area);
castles.cpp:    else if (ch->clan == clan_lookup("Whitecloak"))
castles.cpp:	    if ( IS_SET(ch->in_room->room_flags, ROOM_WHITECLOAK))
castles.cpp:	    else if (ch->in_room->sector_type == SECT_TAKEN)
castles.cpp:        SET_BIT(ch->in_room->room_flags, ROOM_WHITECLOAK);
castles.cpp:        save_area (ch->in_room->area);
castles.cpp:    else if (ch->clan == clan_lookup("Shaido"))
castles.cpp:	    if ( IS_SET(ch->in_room->room_flags, ROOM_SHAIDO))
castles.cpp:	    else if (ch->in_room->sector_type == SECT_TAKEN)
castles.cpp:        SET_BIT(ch->in_room->room_flags, ROOM_SHAIDO);
castles.cpp:        save_area (ch->in_room->area);
castles.cpp:    else if (ch->clan == clan_lookup("Shadow"))
castles.cpp:	    if ( IS_SET(ch->in_room->room_flags, ROOM_SHADOW))
castles.cpp:	    else if (ch->in_room->sector_type == SECT_TAKEN)
castles.cpp:        SET_BIT(ch->in_room->room_flags, ROOM_SHADOW);
castles.cpp:        save_area (ch->in_room->area);
castles.cpp:    else if (ch->clan == clan_lookup("Tinker"))
castles.cpp:	    if ( IS_SET(ch->in_room->room_flags, ROOM_TINKER))
castles.cpp:	    else if (ch->in_room->sector_type == SECT_TAKEN)
castles.cpp:        SET_BIT(ch->in_room->room_flags, ROOM_TINKER);
castles.cpp:        save_area (ch->in_room->area);
castles.cpp:    location = ch->in_room;
castles.cpp:		clan_table[ch->clan].vnum = ch->in_room->vnum;
castles.cpp:	    if ( IS_SET(ch->in_room->room_flags, ROOM_SAFE))
castles.cpp:	    SET_BIT(ch->in_room->room_flags, ROOM_SAFE);
castles.cpp:	    save_area (ch->in_room->area);
castles.cpp:	    REMOVE_BIT(ch->in_room->room_flags, ROOM_TINKER);
castles.cpp:	    REMOVE_BIT(ch->in_room->room_flags, ROOM_SHAIDO);
castles.cpp:	    REMOVE_BIT(ch->in_room->room_flags, ROOM_AIEL);
castles.cpp:	    REMOVE_BIT(ch->in_room->room_flags, ROOM_WHITECLOAK);
castles.cpp:	    REMOVE_BIT(ch->in_room->room_flags, ROOM_WHITETOWER);
castles.cpp:	    REMOVE_BIT(ch->in_room->room_flags, ROOM_SHADOW);
castles.cpp:	    REMOVE_BIT(ch->in_room->room_flags, ROOM_SAFE);
castles.cpp:	    save_area (ch->in_room->area);
castles.cpp:    location = ch->in_room;
castles.cpp:	    save_area (ch->in_room->area);
castles.cpp:	    save_area (ch->in_room->area);
castles.cpp:	    save_area (ch->in_room->area);
comm.cpp:        sprintf (log_buf, "Closing link to %s.", ch->name);
comm.cpp:            ch->desc = NULL;
comm.cpp:            if ( ((victim = ch->fighting) != NULL) && can_see (ch, victim))
comm.cpp:            if (!IS_SET (ch->comm, COMM_COMPACT))
comm.cpp:        if ((victim = ch->fighting) != NULL && can_see(ch,victim) && ch->pcdata->barOn)
comm.cpp:            if (IS_IMMORTAL(ch) && IS_SET(ch->act2, PLR_MXP))
comm.cpp:                percent = ch->hit * 100 / ch->max_hit;
comm.cpp:            if (IS_SET (ch->comm, COMM_PROMPT))
comm.cpp:            if (IS_SET (ch->comm, COMM_TELNET_GA))
comm.cpp:    str = ch->prompt;
comm.cpp:                 ch->hit, ch->mana, ch->move);
comm.cpp:		ch->prefix);
comm.cpp:  if (ch->desc && ch->desc->editor != ED_NONE )
comm.cpp:     switch ( ch->desc->editor )
comm.cpp:	  pHelp = (HELP_DATA *) ch->desc->pEdit;
comm.cpp:                    if ((pexit = ch->in_room->exit[door]) != NULL
comm.cpp:                sprintf (buf2, "%d", ch->pcdata->damInflicted);
comm.cpp:                sprintf (buf2, "%d", ch->pcdata->damReceived);
comm.cpp:                if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_MXP))
comm.cpp:                  sprintf(buf2, "<Hp>%ld</Hp>", ch->hit);
comm.cpp:                  sprintf (buf2, "%ld", ch->hit);
comm.cpp:                if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_MXP))
comm.cpp:                  sprintf(buf2, "<MaxHp>%ld</MaxHp>", ch->max_hit);
comm.cpp:                  sprintf (buf2, "%ld", ch->max_hit);
comm.cpp:                if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_MXP))
comm.cpp:                  sprintf(buf2, "<Mana>%d</Mana>", ch->mana);
comm.cpp:                sprintf (buf2, "%d", ch->mana);
comm.cpp:                if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_MXP))
comm.cpp:                  sprintf(buf2, "<MaxMana>%d</MaxMana>", ch->max_mana);
comm.cpp:                sprintf (buf2, "%d", ch->max_mana);
comm.cpp:                sprintf (buf2, "%d", ch->move);
comm.cpp:                sprintf (buf2, "%d", ch->max_move);
comm.cpp:                sprintf (buf2, "%d", ch->exp);
comm.cpp:                         (ch->level + 1) * exp_per_level (ch,
comm.cpp:                                                          ch->pcdata->
comm.cpp:                                                          points) - ch->exp);
comm.cpp:                sprintf (buf2, "%ld", ch->gold);
comm.cpp:                sprintf (buf2, "%ld", ch->silver);
comm.cpp:                if (ch->level > 9)
comm.cpp:                    sprintf (buf2, "%d", ch->alignment);
comm.cpp:                if (ch->in_room != NULL)
comm.cpp:                               (ch) && IS_SET (ch->act, PLR_HOLYLIGHT))
comm.cpp:                                  && !room_is_dark (ch->
comm.cpp:                                                    in_room))) ? ch->in_room->
comm.cpp:                if (IS_IMMORTAL (ch) && ch->in_room != NULL)
comm.cpp:                    sprintf (buf2, "%ld", ch->in_room->vnum);
comm.cpp:                sprintf (buf2, "%ld", ch->questpoints);
comm.cpp:		if (IS_SET(ch->act, PLR_QUESTOR))
comm.cpp:                  if (ch->countdown > 0)
comm.cpp:                     sprintf(buf2, "`#%d`*", ch->countdown);
comm.cpp:                     sprintf(buf2, "%d", ch->nextquest);
comm.cpp:                   sprintf(buf2, "%d", ch->nextquest);
comm.cpp:		   IS_MURDERER(ch) ? ch->penalty.murder : 
comm.cpp:                   IS_THIEF(ch) ? ch->penalty.thief : 0);
comm.cpp:                if (IS_SET(ch->act2, PLR_MXP))
comm.cpp:                  if (ch->timed_affect.seconds > 0)
comm.cpp:                    sprintf (buf2, "`#<Ticks>%d</Ticks>`*", ch->timed_affect.seconds);
comm.cpp:                  else if (ch->pcdata->pk_timer > 0)
comm.cpp:                    sprintf (buf2, "`!<Ticks>%d</Ticks>`*", ch->pcdata->pk_timer);
comm.cpp:                  else if (ch->pcdata->safe_timer > 0)
comm.cpp:                    sprintf (buf2, "`$<Ticks>%d</Ticks>`*", ch->pcdata->safe_timer);
comm.cpp:                  else if (ch->pcdata->wait_timer > 0)  
comm.cpp:                    sprintf (buf2, "`&<Ticks>%d</Ticks>`*", ch->pcdata->wait_timer);
comm.cpp:                  if (ch->timed_affect.seconds > 0)
comm.cpp:                    sprintf (buf2, "`#%d`*", ch->timed_affect.seconds);
comm.cpp:                  else if (ch->pcdata->pk_timer > 0)
comm.cpp:                    sprintf (buf2, "`!%d`*", ch->pcdata->pk_timer);
comm.cpp:                  else if (ch->pcdata->safe_timer > 0)
comm.cpp:                    sprintf (buf2, "`$%d`*", ch->pcdata->safe_timer);
comm.cpp:                  else if (ch->pcdata->wait_timer > 0)  
comm.cpp:                    sprintf (buf2, "`&%d`*", ch->pcdata->wait_timer);
comm.cpp:                if (IS_IMMORTAL (ch) && ch->in_room != NULL)
comm.cpp:                    sprintf (buf2, "%s", ch->in_room->area->name);
comm.cpp:                sprintf (buf2, "%d",ch->rpexp);
comm.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_MXP))
comm.cpp:    write_to_buffer (ch->desc, buffer, 0);
comm.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_MXP))
comm.cpp:    if (IS_SET (ch->comm, COMM_AFK))
comm.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_NORP))
comm.cpp:    if (ch->invis_level >= LEVEL_HERO)
comm.cpp:    if (ch->incog_level >= 1)
comm.cpp:     if (IS_SET(ch->act, PLR_HUNGER_FLAG) &&
comm.cpp:         ch->pcdata->condition[COND_HUNGER] == 0)
comm.cpp:      if (IS_SET(ch->act, PLR_HUNGER_FLAG) &&
comm.cpp:         ch->pcdata->condition[COND_THIRST] == 0)
comm.cpp:    if (ch->prefix[0] != '\0')
comm.cpp:        write_to_buffer (ch->desc, ch->prefix, 0);
comm.cpp:            if (ch->level > 81)
comm.cpp:               ch->level -= 5;
comm.cpp:/*            if (IS_SET  ( ch->act, PLR_TOURNEY) )
comm.cpp:              REMOVE_BIT(ch->act, PLR_TOURNEY);
comm.cpp:            if (IS_SET  ( ch->act2, PLR_TOURNAMENT_START) )
comm.cpp:              REMOVE_BIT(ch->act2, PLR_TOURNAMENT_START);
comm.cpp:            if (IS_SET (ch->act, PLR_DENY))
comm.cpp:                && !IS_SET (ch->act, PLR_PERMIT))
comm.cpp:            if (strcmp (crypt (argument, ch->pcdata->pwd), ch->pcdata->pwd))
comm.cpp:                bugf("%s booted for wrong password", ch->name);
comm.cpp:            if (check_playing (d, IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name))
comm.cpp:            if (check_reconnect (d, IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name, TRUE))
comm.cpp:            sprintf (log_buf, "%s@%s has connected.", ch->name, dns_gethostname(d->host));
comm.cpp:            if (IS_SET(ch->act2, PLR_NOIP))
comm.cpp:              sprintf (log_buf, "%s has connected.", ch->name);
comm.cpp:    /*        if (ch->desc->ansi)
comm.cpp:                SET_BIT (ch->act, PLR_COLOUR);
comm.cpp:                REMOVE_BIT (ch->act, PLR_COLOUR);
comm.cpp:            ch->pcdata->Host = str_dup(dns_gethostname(ch->desc->host));
comm.cpp:                sprintf( buf, "\n\r`!Welcome `@%s`7@`8%s`7!\n\r", ch->name, dns_gethostname(d->host));
comm.cpp:                sprintf( buf, "\n\r`&Please be advised `@%s`& that upon enterance, you may be logged`7\n\r", ch->name);
comm.cpp:                sprintf( buf, "\n\rWelcome %s@%s!\n\r", ch->name, dns_gethostname(d->host));
comm.cpp:                        if (str_cmp (IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name,
comm.cpp:                    if (check_reconnect (d, IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name, TRUE))
comm.cpp:                             ch->name, echo_off_str);
comm.cpp:                    if (ch->desc->ansi)
comm.cpp:                        SET_BIT (ch->act, PLR_COLOUR);
comm.cpp:            pwdnew = crypt (argument, ch->name);
comm.cpp:            free_string (ch->pcdata->pwd);
comm.cpp:            ch->pcdata->pwd = str_dup (pwdnew);
comm.cpp:            if (strcmp (crypt (argument, ch->pcdata->pwd), ch->pcdata->pwd))
comm.cpp:            ch->race = race;
comm.cpp:                ch->perm_stat[i] += pc_race_table[race].modstats[i];
comm.cpp:                ch->perm_stat[i] = URANGE(18, ch->perm_stat[i], 25);
comm.cpp:// UBit            ch->affected_by = ch->affected_by | race_table[race].aff;
comm.cpp://            STR_OR_STR( ch->affected_by, race_table[race].aff, AFF_FLAGS);
comm.cpp:            ch->imm_flags = ch->imm_flags | race_table[race].imm;
comm.cpp:            ch->res_flags = ch->res_flags | race_table[race].res;
comm.cpp:            ch->vuln_flags = ch->vuln_flags | race_table[race].vuln;
comm.cpp:            ch->form = race_table[race].form;
comm.cpp:            ch->parts = race_table[race].parts;
comm.cpp:            ch->pcdata->points = pc_race_table[race].points;
comm.cpp:            ch->size = pc_race_table[race].size;
comm.cpp:                    ch->sex = SEX_MALE;
comm.cpp:                    ch->pcdata->true_sex = SEX_MALE;
comm.cpp:                    ch->sex = SEX_FEMALE;
comm.cpp:                    ch->pcdata->true_sex = SEX_FEMALE;
comm.cpp:              ch->cClass = iClass;
comm.cpp:              ch->cClass = iClass;
comm.cpp:            ch->cClass = iClass;
comm.cpp:                ch->perm_stat[i] = class_table[iClass].modstat[i];
comm.cpp:            sprintf (log_buf, "%s@%s new player.", ch->name, dns_gethostname(d->host));
comm.cpp:            print_class_stats(ch, ch->cClass);
comm.cpp:               ch->alignment = -750;
comm.cpp:               group_add (ch, class_table[ch->cClass].base_group, FALSE);                     
comm.cpp:               group_add (ch, class_table[ch->cClass].default_group, TRUE);
comm.cpp:                 if (skill_table[sn].name != NULL && ch->pcdata->learned[sn] > 0)
comm.cpp:                   ch->pcdata->learned[sn] = 75;
comm.cpp:                 ch->perm_stat[i] = 25;
comm.cpp:               ch->max_hit = 300;
comm.cpp:               ch->hit = 300;
comm.cpp:               ch->max_mana = 300;
comm.cpp:               ch->mana = 300;
comm.cpp:               ch->alignment = 750;
comm.cpp:               group_add (ch, class_table[ch->cClass].base_group, FALSE);                     
comm.cpp:               group_add (ch, class_table[ch->cClass].default_group, TRUE);
comm.cpp:                 if (skill_table[sn].name != NULL && ch->pcdata->learned[sn] > 0)
comm.cpp:                   ch->pcdata->learned[sn] = 80;
comm.cpp:                 ch->perm_stat[i] = 25;
comm.cpp:               ch->max_hit = 700;
comm.cpp:               ch->hit = 700;
comm.cpp:               ch->max_mana = 700;
comm.cpp:               ch->mana = 700;
comm.cpp:  	  if (ch->cClass == class_lookup("Dragon"))
comm.cpp:  	  else if (ch->cClass == class_lookup("Forsaken"))
comm.cpp:	    ch->pcdata->weaves[i] = num[i];
comm.cpp:            if (ch->pcdata->learned[*weapon_table[i].gsn] > 0)
comm.cpp:                    ch->alignment = 750;
comm.cpp:                    ch->alignment = 0;
comm.cpp:                    ch->alignment = -750;
comm.cpp:            group_add (ch, class_table[ch->cClass].base_group, FALSE);
comm.cpp:            ch->pcdata->learned[gsn_recall] = 50;
comm.cpp:                    ch->gen_data = new_gen_data ();
comm.cpp:                    ch->gen_data->points_chosen = ch->pcdata->points;
comm.cpp:                    group_add (ch, class_table[ch->cClass].default_group,
comm.cpp:                      sprintf(buf, "%d ",  class_table[ch->cClass].weaves[i] + sex_table[ch->sex].weaves[i]);
comm.cpp:                || ch->pcdata->learned[*weapon_table[weapon].gsn] <= 0)
comm.cpp:                    if (ch->pcdata->learned[*weapon_table[i].gsn] > 0)
comm.cpp:            ch->pcdata->learned[*weapon_table[weapon].gsn] = 40;
comm.cpp:	    SET_BIT(ch->act, PLR_NOPK);
comm.cpp:                if (ch->pcdata->points == pc_race_table[ch->race].points)
comm.cpp:                if (ch->pcdata->points < 40+ pc_race_table[ch->race].points)
comm.cpp:                             40+pc_race_table[ch->race].points);
comm.cpp:                sprintf (buf, "Creation points: %d\n\r", ch->pcdata->points);
comm.cpp:                         exp_per_level (ch, ch->gen_data->points_chosen));
comm.cpp:                if (ch->pcdata->points < 60)
comm.cpp:                    ch->train = (60 - ch->pcdata->points + 1) / 2;
comm.cpp:		if (ch->train < 5) ch->train = 5;
comm.cpp:                free_gen_data (ch->gen_data);
comm.cpp:                ch->gen_data = NULL;
comm.cpp:                  sprintf(buf, "%d ",  class_table[ch->cClass].weaves[i] + sex_table[ch->sex].weaves[i]);
comm.cpp:             if (ch->update < 1)
comm.cpp:            if (ch->update < 1)
comm.cpp:                      SET_BIT(ch->act2, PLR_LOOTABLE);
comm.cpp:                      ch->update = 1;
comm.cpp:                      ch->update = 1;
comm.cpp:            if (ch->pcdata == NULL || ch->pcdata->pwd[0] == '\0')
comm.cpp:            ch->next = char_list;
comm.cpp:            if (ch->level == 0)
comm.cpp:                SET_BIT (ch->act, PLR_COLOUR);
comm.cpp:		SET_BIT (ch->comm, COMM_NOVICE);
comm.cpp:              //  ch->perm_stat[class_table[ch->cClass].attr_prime] += 3;
comm.cpp:                ch->level = 1;
comm.cpp:                ch->exp = exp_per_level (ch, ch->pcdata->points);
comm.cpp:                ch->hit = ch->max_hit;
comm.cpp:                ch->mana = ch->max_mana;
comm.cpp:                ch->move = ch->max_move;
comm.cpp:                ch->train = 3;
comm.cpp:                ch->practice = 5;
comm.cpp:            else if (ch->in_room != NULL)
comm.cpp:                char_to_room (ch, ch->in_room);
comm.cpp:            ch->pcdata->wait_timer = 90; 
comm.cpp:            if (ch->pet != NULL)
comm.cpp:                char_to_room (ch->pet, ch->in_room);
comm.cpp:                act ("$n has entered the game.", ch->pet, NULL, NULL,
comm.cpp:            if (IS_SET(ch->act2, PLR_MXP))
comm.cpp:    for (ch = char_list; ch != NULL; ch = ch->next)
comm.cpp:            && (!fConn || ch->desc == NULL)
comm.cpp:            && !str_cmp (name, IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name))
comm.cpp:                d->character->pcdata->pwd = str_dup (ch->pcdata->pwd);
comm.cpp:                ch->desc = d;
comm.cpp:                ch->timer = 0;
comm.cpp:                sprintf (log_buf, "%s@%s reconnected.", ch->name, dns_gethostname(d->host));
comm.cpp:                if (IS_SET(ch->act, PLR_TOURNEY))
comm.cpp:                    REMOVE_BIT(ch->act, PLR_TOURNEY);
comm.cpp:		if (IS_SET(ch->act2, PLR_TOURNAMENT_START))
comm.cpp:		    REMOVE_BIT(ch->act2, PLR_TOURNAMENT_START);
comm.cpp:        || ch->desc == NULL
comm.cpp:        || ch->desc->connected != CON_PLAYING
comm.cpp:        || ch->was_in_room == NULL
comm.cpp:        || ch->in_room != get_room_index (ROOM_VNUM_LIMBO)) return;
comm.cpp:    ch->timer = 0;
comm.cpp:    char_to_room (ch, ch->was_in_room);
comm.cpp:    ch->was_in_room = NULL;
comm.cpp:    if (txt != NULL && ch->desc != NULL)
comm.cpp:        write_to_buffer (ch->desc, txt, strlen (txt));
comm.cpp:    if (txt == NULL || ch->desc == NULL)
comm.cpp:    if (ch->lines == 0)
comm.cpp:    if (ch->desc->showstr_head)
comm.cpp:      free_mem(ch->desc->showstr_head, strlen(ch->desc->showstr_head) + 1);
comm.cpp:    ch->desc->showstr_head = (char *) alloc_mem (strlen (txt) + 1);
comm.cpp:    strcpy (ch->desc->showstr_head, txt);
comm.cpp:    ch->desc->showstr_point = ch->desc->showstr_head;
comm.cpp:    show_string (ch->desc, "");
comm.cpp:    if (txt && ch->desc)
comm.cpp:        if (IS_SET (ch->act, PLR_COLOUR) ||
comm.cpp:            (IS_SWITCHED(ch) && IS_SET(ch->desc->original->act, PLR_COLOUR)))
comm.cpp:            write_to_buffer (ch->desc, buf, point2 - buf);
comm.cpp:            write_to_buffer (ch->desc, buf, point2 - buf);
comm.cpp:    if (txt && ch->desc)
comm.cpp:        if (IS_SET (ch->act, PLR_COLOUR) || 
comm.cpp:           (IS_SWITCHED(ch) && IS_SET(ch->desc->original->act, PLR_COLOUR)))
comm.cpp:            if (ch->desc->showstr_head)
comm.cpp:              free_string(ch->desc->showstr_head);
comm.cpp:            ch->desc->showstr_head = (char *) alloc_mem (strlen (buf) + 1);
comm.cpp:            strcpy (ch->desc->showstr_head, buf);
comm.cpp:            ch->desc->showstr_point = ch->desc->showstr_head;
comm.cpp:            show_string (ch->desc, "");
comm.cpp:            if (ch->desc->showstr_head)
comm.cpp:              free_string(ch->desc->showstr_head);
comm.cpp:            ch->desc->showstr_head = (char *) alloc_mem (strlen (buf) + 1);
comm.cpp:            strcpy (ch->desc->showstr_head, buf);
comm.cpp:            ch->desc->showstr_point = ch->desc->showstr_head;
comm.cpp:            show_string (ch->desc, "");
comm.cpp:    if (ch->sex < 0 || ch->sex > 2)
comm.cpp:        ch->sex = IS_NPC (ch) ? 0 : ch->pcdata->true_sex;
comm.cpp:    if (ch == NULL || ch->in_room == NULL)
comm.cpp:    to = ch->in_room->people;
comm.cpp:        if (vch->in_room == NULL)
comm.cpp:        to = vch->in_room->people;
comm.cpp:                        i = IS_DISGUISED(ch) ? ch->short_descr:PERS (ch, to, FALSE);
comm.cpp:                        i = IS_DISGUISED(vch) ? vch->short_descr:PERS (vch, to, FALSE);
comm.cpp:                        if (IS_NULLSTR(ch->pretit) || 
comm.cpp:			    !str_cmp(ch->pretit, "(null)") ||
comm.cpp:			  sprintf(pretit, "%s ", ch->pretit);
comm.cpp:                        if (IS_NULLSTR(vch->pretit) || 
comm.cpp:			    !str_cmp(vch->pretit, "(null)") ||
comm.cpp:			  sprintf(pretit, "%s ", vch->pretit);
comm.cpp:                        i = he_she[URANGE (0, ch->sex, 2)];
comm.cpp:                        i = he_she[URANGE (0, vch->sex, 2)];
comm.cpp:                        i = him_her[URANGE (0, ch->sex, 2)];
comm.cpp:                        i = him_her[URANGE (0, vch->sex, 2)];
comm.cpp:                        i = his_her[URANGE (0, ch->sex, 2)];
comm.cpp:                        i = his_her[URANGE (0, vch->sex, 2)];
comm.cpp:        for( obj = ch->in_room->contents; obj; obj = obj_next )
comm.cpp:            tch_next = tch->next_in_room;
comm.cpp:            for ( obj = tch->carrying; obj; obj = obj_next )
comm.cpp:         if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_ACT ) )
comm.cpp:             p_act_trigger( buf, NULL, NULL, ch->in_room, ch, NULL, NULL, TRIG_ACT );
comm.cpp:    if (ch == NULL || ch->in_room == NULL)
comm.cpp:        if (vch->in_room == NULL)
comm.cpp:                        i = IS_DISGUISED(ch)?ch->short_descr:PERS (ch, to, FALSE);
comm.cpp:                        i = IS_DISGUISED(vch)?vch->short_descr:PERS (vch, to, FALSE);
comm.cpp:                        i = he_she[URANGE (0, ch->sex, 2)];
comm.cpp:                        i = he_she[URANGE (0, vch->sex, 2)];
comm.cpp:                        i = him_her[URANGE (0, ch->sex, 2)];
comm.cpp:                        i = him_her[URANGE (0, vch->sex, 2)];
comm.cpp:                        i = his_her[URANGE (0, ch->sex, 2)];
comm.cpp:                        i = his_her[URANGE (0, vch->sex, 2)];
comm.cpp:    if (ch && IS_NPC (ch) && ch->desc->original == ch->desc->character)
comm.cpp:    col = ch ? ch->pcdata : NULL;
comm.cpp:    if (ch && ch->desc && txt)
comm.cpp:       if (IS_SET (ch->act, PLR_COLOUR)
comm.cpp:       ||  (IS_SWITCHED(ch) && IS_SET(ch->desc->original->act, PLR_COLOUR)))
comm.cpp:  ch->pcdata->mxpVersion = str_dup(version);
comm.cpp:  ch->pcdata->clientVersion = str_dup(client_version);
comm.cpp:  ch->pcdata->client = str_dup(client);
comm.cpp.save:        sprintf (log_buf, "Closing link to %s.", ch->name);
comm.cpp.save:            ch->desc = NULL;
comm.cpp.save:            if ( ((victim = ch->fighting) != NULL) && can_see (ch, victim))
comm.cpp.save:            if (!IS_SET (ch->comm, COMM_COMPACT))
comm.cpp.save:        if ((victim = ch->fighting) != NULL && can_see(ch,victim) && ch->pcdata->barOn)
comm.cpp.save:            if (IS_IMMORTAL(ch) && IS_SET(ch->act2, PLR_MXP))
comm.cpp.save:                percent = ch->hit * 100 / ch->max_hit;
comm.cpp.save:            if (IS_SET (ch->comm, COMM_PROMPT))
comm.cpp.save:            if (IS_SET (ch->comm, COMM_TELNET_GA))
comm.cpp.save:    str = ch->prompt;
comm.cpp.save:                 ch->hit, ch->mana, ch->move);
comm.cpp.save:		ch->prefix);
comm.cpp.save:  if (ch->desc && ch->desc->editor != ED_NONE )
comm.cpp.save:     switch ( ch->desc->editor )
comm.cpp.save:	  pHelp = (HELP_DATA *) ch->desc->pEdit;
comm.cpp.save:                    if ((pexit = ch->in_room->exit[door]) != NULL
comm.cpp.save:                sprintf (buf2, "%d", ch->pcdata->damInflicted);
comm.cpp.save:                sprintf (buf2, "%d", ch->pcdata->damReceived);
comm.cpp.save:                if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_MXP))
comm.cpp.save:                  sprintf(buf2, "<Hp>%ld</Hp>", ch->hit);
comm.cpp.save:                  sprintf (buf2, "%ld", ch->hit);
comm.cpp.save:                if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_MXP))
comm.cpp.save:                  sprintf(buf2, "<MaxHp>%ld</MaxHp>", ch->max_hit);
comm.cpp.save:                  sprintf (buf2, "%ld", ch->max_hit);
comm.cpp.save:                if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_MXP))
comm.cpp.save:                  sprintf(buf2, "<Mana>%d</Mana>", ch->mana);
comm.cpp.save:                sprintf (buf2, "%d", ch->mana);
comm.cpp.save:                if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_MXP))
comm.cpp.save:                  sprintf(buf2, "<MaxMana>%d</MaxMana>", ch->max_mana);
comm.cpp.save:                sprintf (buf2, "%d", ch->max_mana);
comm.cpp.save:                sprintf (buf2, "%d", ch->move);
comm.cpp.save:                sprintf (buf2, "%d", ch->max_move);
comm.cpp.save:                sprintf (buf2, "%d", ch->exp);
comm.cpp.save:                         (ch->level + 1) * exp_per_level (ch,
comm.cpp.save:                                                          ch->pcdata->
comm.cpp.save:                                                          points) - ch->exp);
comm.cpp.save:                sprintf (buf2, "%ld", ch->gold);
comm.cpp.save:                sprintf (buf2, "%ld", ch->silver);
comm.cpp.save:                if (ch->level > 9)
comm.cpp.save:                    sprintf (buf2, "%d", ch->alignment);
comm.cpp.save:                if (ch->in_room != NULL)
comm.cpp.save:                               (ch) && IS_SET (ch->act, PLR_HOLYLIGHT))
comm.cpp.save:                                  && !room_is_dark (ch->
comm.cpp.save:                                                    in_room))) ? ch->in_room->
comm.cpp.save:                if (IS_IMMORTAL (ch) && ch->in_room != NULL)
comm.cpp.save:                    sprintf (buf2, "%ld", ch->in_room->vnum);
comm.cpp.save:                sprintf (buf2, "%ld", ch->questpoints);
comm.cpp.save:		if (IS_SET(ch->act, PLR_QUESTOR))
comm.cpp.save:                  if (ch->countdown > 0)
comm.cpp.save:                     sprintf(buf2, "`#%d`*", ch->countdown);
comm.cpp.save:                     sprintf(buf2, "%d", ch->nextquest);
comm.cpp.save:                   sprintf(buf2, "%d", ch->nextquest);
comm.cpp.save:		   IS_MURDERER(ch) ? ch->penalty.murder : 
comm.cpp.save:                   IS_THIEF(ch) ? ch->penalty.thief : 0);
comm.cpp.save:                if (IS_SET(ch->act2, PLR_MXP))
comm.cpp.save:                  if (ch->timed_affect.seconds > 0)
comm.cpp.save:                    sprintf (buf2, "`#<Ticks>%d</Ticks>`*", ch->timed_affect.seconds);
comm.cpp.save:                  else if (ch->pcdata->pk_timer > 0)
comm.cpp.save:                    sprintf (buf2, "`!<Ticks>%d</Ticks>`*", ch->pcdata->pk_timer);
comm.cpp.save:                  else if (ch->pcdata->safe_timer > 0)
comm.cpp.save:                    sprintf (buf2, "`$<Ticks>%d</Ticks>`*", ch->pcdata->safe_timer);
comm.cpp.save:                  else if (ch->pcdata->wait_timer > 0)  
comm.cpp.save:                    sprintf (buf2, "`&<Ticks>%d</Ticks>`*", ch->pcdata->wait_timer);
comm.cpp.save:                  if (ch->timed_affect.seconds > 0)
comm.cpp.save:                    sprintf (buf2, "`#%d`*", ch->timed_affect.seconds);
comm.cpp.save:                  else if (ch->pcdata->pk_timer > 0)
comm.cpp.save:                    sprintf (buf2, "`!%d`*", ch->pcdata->pk_timer);
comm.cpp.save:                  else if (ch->pcdata->safe_timer > 0)
comm.cpp.save:                    sprintf (buf2, "`$%d`*", ch->pcdata->safe_timer);
comm.cpp.save:                  else if (ch->pcdata->wait_timer > 0)  
comm.cpp.save:                    sprintf (buf2, "`&%d`*", ch->pcdata->wait_timer);
comm.cpp.save:                if (IS_IMMORTAL (ch) && ch->in_room != NULL)
comm.cpp.save:                    sprintf (buf2, "%s", ch->in_room->area->name);
comm.cpp.save:                sprintf (buf2, "%d",ch->rpexp);
comm.cpp.save:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_MXP))
comm.cpp.save:    write_to_buffer (ch->desc, buffer, 0);
comm.cpp.save:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_MXP))
comm.cpp.save:    if (IS_SET (ch->comm, COMM_AFK))
comm.cpp.save:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_NORP))
comm.cpp.save:    if (ch->invis_level >= LEVEL_HERO)
comm.cpp.save:    if (ch->incog_level >= 1)
comm.cpp.save:     if (IS_SET(ch->act, PLR_HUNGER_FLAG) &&
comm.cpp.save:         ch->pcdata->condition[COND_HUNGER] == 0)
comm.cpp.save:      if (IS_SET(ch->act, PLR_HUNGER_FLAG) &&
comm.cpp.save:         ch->pcdata->condition[COND_THIRST] == 0)
comm.cpp.save:    if (ch->prefix[0] != '\0')
comm.cpp.save:        write_to_buffer (ch->desc, ch->prefix, 0);
comm.cpp.save:            if (ch->level > 81)
comm.cpp.save:               ch->level -= 5;
comm.cpp.save:/*            if (IS_SET  ( ch->act, PLR_TOURNEY) )
comm.cpp.save:              REMOVE_BIT(ch->act, PLR_TOURNEY);
comm.cpp.save:            if (IS_SET  ( ch->act2, PLR_TOURNAMENT_START) )
comm.cpp.save:              REMOVE_BIT(ch->act2, PLR_TOURNAMENT_START);
comm.cpp.save:            if (IS_SET (ch->act, PLR_DENY))
comm.cpp.save:                && !IS_SET (ch->act, PLR_PERMIT))
comm.cpp.save:            if (strcmp (crypt (argument, ch->pcdata->pwd), ch->pcdata->pwd))
comm.cpp.save:                bugf("%s booted for wrong password", ch->name);
comm.cpp.save:            if (check_playing (d, IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name))
comm.cpp.save:            if (check_reconnect (d, IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name, TRUE))
comm.cpp.save:            sprintf (log_buf, "%s@%s has connected.", ch->name, dns_gethostname(d->host));
comm.cpp.save:            if (IS_SET(ch->act2, PLR_NOIP))
comm.cpp.save:              sprintf (log_buf, "%s has connected.", ch->name);
comm.cpp.save:    /*        if (ch->desc->ansi)
comm.cpp.save:                SET_BIT (ch->act, PLR_COLOUR);
comm.cpp.save:                REMOVE_BIT (ch->act, PLR_COLOUR);
comm.cpp.save:            ch->pcdata->Host = str_dup(dns_gethostname(ch->desc->host));
comm.cpp.save:                sprintf( buf, "\n\r`!Welcome `@%s`7@`8%s`7!\n\r", ch->name, dns_gethostname(d->host));
comm.cpp.save:                sprintf( buf, "\n\r`&Please be advised `@%s`& that upon enterance, you may be logged`7\n\r", ch->name);
comm.cpp.save:                sprintf( buf, "\n\rWelcome %s@%s!\n\r", ch->name, dns_gethostname(d->host));
comm.cpp.save:                        if (str_cmp (IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name,
comm.cpp.save:                    if (check_reconnect (d, IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name, TRUE))
comm.cpp.save:                             ch->name, echo_off_str);
comm.cpp.save:                    if (ch->desc->ansi)
comm.cpp.save:                        SET_BIT (ch->act, PLR_COLOUR);
comm.cpp.save:            pwdnew = crypt (argument, ch->name);
comm.cpp.save:            free_string (ch->pcdata->pwd);
comm.cpp.save:            ch->pcdata->pwd = str_dup (pwdnew);
comm.cpp.save:            if (strcmp (crypt (argument, ch->pcdata->pwd), ch->pcdata->pwd))
comm.cpp.save:            ch->race = race;
comm.cpp.save:                ch->perm_stat[i] += pc_race_table[race].modstats[i];
comm.cpp.save:                ch->perm_stat[i] = URANGE(18, ch->perm_stat[i], 25);
comm.cpp.save:// UBit            ch->affected_by = ch->affected_by | race_table[race].aff;
comm.cpp.save://            STR_OR_STR( ch->affected_by, race_table[race].aff, AFF_FLAGS);
comm.cpp.save:            ch->imm_flags = ch->imm_flags | race_table[race].imm;
comm.cpp.save:            ch->res_flags = ch->res_flags | race_table[race].res;
comm.cpp.save:            ch->vuln_flags = ch->vuln_flags | race_table[race].vuln;
comm.cpp.save:            ch->form = race_table[race].form;
comm.cpp.save:            ch->parts = race_table[race].parts;
comm.cpp.save:            ch->pcdata->points = pc_race_table[race].points;
comm.cpp.save:            ch->size = pc_race_table[race].size;
comm.cpp.save:                    ch->sex = SEX_MALE;
comm.cpp.save:                    ch->pcdata->true_sex = SEX_MALE;
comm.cpp.save:                    ch->sex = SEX_FEMALE;
comm.cpp.save:                    ch->pcdata->true_sex = SEX_FEMALE;
comm.cpp.save:              ch->cClass = iClass;
comm.cpp.save:              ch->cClass = iClass;
comm.cpp.save:            ch->cClass = iClass;
comm.cpp.save:                ch->perm_stat[i] = class_table[iClass].modstat[i];
comm.cpp.save:            sprintf (log_buf, "%s@%s new player.", ch->name, dns_gethostname(d->host));
comm.cpp.save:            print_class_stats(ch, ch->cClass);
comm.cpp.save:               ch->alignment = -750;
comm.cpp.save:               group_add (ch, class_table[ch->cClass].base_group, FALSE);                     
comm.cpp.save:               group_add (ch, class_table[ch->cClass].default_group, TRUE);
comm.cpp.save:                 if (skill_table[sn].name != NULL && ch->pcdata->learned[sn] > 0)
comm.cpp.save:                   ch->pcdata->learned[sn] = 75;
comm.cpp.save:                 ch->perm_stat[i] = 25;
comm.cpp.save:               ch->max_hit = 300;
comm.cpp.save:               ch->hit = 300;
comm.cpp.save:               ch->max_mana = 300;
comm.cpp.save:               ch->mana = 300;
comm.cpp.save:               ch->alignment = 750;
comm.cpp.save:               group_add (ch, class_table[ch->cClass].base_group, FALSE);                     
comm.cpp.save:               group_add (ch, class_table[ch->cClass].default_group, TRUE);
comm.cpp.save:                 if (skill_table[sn].name != NULL && ch->pcdata->learned[sn] > 0)
comm.cpp.save:                   ch->pcdata->learned[sn] = 80;
comm.cpp.save:                 ch->perm_stat[i] = 25;
comm.cpp.save:               ch->max_hit = 700;
comm.cpp.save:               ch->hit = 700;
comm.cpp.save:               ch->max_mana = 700;
comm.cpp.save:               ch->mana = 700;
comm.cpp.save:  	  if (ch->cClass == class_lookup("Dragon"))
comm.cpp.save:  	  else if (ch->cClass == class_lookup("Forsaken"))
comm.cpp.save:	    ch->pcdata->weaves[i] = num[i];
comm.cpp.save:            if (ch->pcdata->learned[*weapon_table[i].gsn] > 0)
comm.cpp.save:                    ch->alignment = 750;
comm.cpp.save:                    ch->alignment = 0;
comm.cpp.save:                    ch->alignment = -750;
comm.cpp.save:            group_add (ch, class_table[ch->cClass].base_group, FALSE);
comm.cpp.save:            ch->pcdata->learned[gsn_recall] = 50;
comm.cpp.save:                    ch->gen_data = new_gen_data ();
comm.cpp.save:                    ch->gen_data->points_chosen = ch->pcdata->points;
comm.cpp.save:                    group_add (ch, class_table[ch->cClass].default_group,
comm.cpp.save:                      sprintf(buf, "%d ",  class_table[ch->cClass].weaves[i] + sex_table[ch->sex].weaves[i]);
comm.cpp.save:                || ch->pcdata->learned[*weapon_table[weapon].gsn] <= 0)
comm.cpp.save:                    if (ch->pcdata->learned[*weapon_table[i].gsn] > 0)
comm.cpp.save:            ch->pcdata->learned[*weapon_table[weapon].gsn] = 40;
comm.cpp.save:	    SET_BIT(ch->act, PLR_NOPK);
comm.cpp.save:                if (ch->pcdata->points == pc_race_table[ch->race].points)
comm.cpp.save:                if (ch->pcdata->points < 40+ pc_race_table[ch->race].points)
comm.cpp.save:                             40+pc_race_table[ch->race].points);
comm.cpp.save:                sprintf (buf, "Creation points: %d\n\r", ch->pcdata->points);
comm.cpp.save:                         exp_per_level (ch, ch->gen_data->points_chosen));
comm.cpp.save:                if (ch->pcdata->points < 60)
comm.cpp.save:                    ch->train = (60 - ch->pcdata->points + 1) / 2;
comm.cpp.save:		if (ch->train < 5) ch->train = 5;
comm.cpp.save:                free_gen_data (ch->gen_data);
comm.cpp.save:                ch->gen_data = NULL;
comm.cpp.save:                  sprintf(buf, "%d ",  class_table[ch->cClass].weaves[i] + sex_table[ch->sex].weaves[i]);
comm.cpp.save:             if (ch->update < 1)
comm.cpp.save:            if (ch->update < 1)
comm.cpp.save:                      SET_BIT(ch->act2, PLR_LOOTABLE);
comm.cpp.save:                      ch->update = 1;
comm.cpp.save:                      ch->update = 1;
comm.cpp.save:            if (ch->pcdata == NULL || ch->pcdata->pwd[0] == '\0')
comm.cpp.save:            ch->next = char_list;
comm.cpp.save:            if (ch->level == 0)
comm.cpp.save:                SET_BIT (ch->act, PLR_COLOUR);
comm.cpp.save:		SET_BIT (ch->comm, COMM_NOVICE);
comm.cpp.save:              //  ch->perm_stat[class_table[ch->cClass].attr_prime] += 3;
comm.cpp.save:                ch->level = 1;
comm.cpp.save:                ch->exp = exp_per_level (ch, ch->pcdata->points);
comm.cpp.save:                ch->hit = ch->max_hit;
comm.cpp.save:                ch->mana = ch->max_mana;
comm.cpp.save:                ch->move = ch->max_move;
comm.cpp.save:                ch->train = 3;
comm.cpp.save:                ch->practice = 5;
comm.cpp.save:            else if (ch->in_room != NULL)
comm.cpp.save:                char_to_room (ch, ch->in_room);
comm.cpp.save:            ch->pcdata->wait_timer = 90; 
comm.cpp.save:            if (ch->pet != NULL)
comm.cpp.save:                char_to_room (ch->pet, ch->in_room);
comm.cpp.save:                act ("$n has entered the game.", ch->pet, NULL, NULL,
comm.cpp.save:            if (IS_SET(ch->act2, PLR_MXP))
comm.cpp.save:    for (ch = char_list; ch != NULL; ch = ch->next)
comm.cpp.save:            && (!fConn || ch->desc == NULL)
comm.cpp.save:            && !str_cmp (name, IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name))
comm.cpp.save:                d->character->pcdata->pwd = str_dup (ch->pcdata->pwd);
comm.cpp.save:                ch->desc = d;
comm.cpp.save:                ch->timer = 0;
comm.cpp.save:                sprintf (log_buf, "%s@%s reconnected.", ch->name, dns_gethostname(d->host));
comm.cpp.save:                if (IS_SET(ch->act, PLR_TOURNEY))
comm.cpp.save:                    REMOVE_BIT(ch->act, PLR_TOURNEY);
comm.cpp.save:		if (IS_SET(ch->act2, PLR_TOURNAMENT_START))
comm.cpp.save:		    REMOVE_BIT(ch->act2, PLR_TOURNAMENT_START);
comm.cpp.save:        || ch->desc == NULL
comm.cpp.save:        || ch->desc->connected != CON_PLAYING
comm.cpp.save:        || ch->was_in_room == NULL
comm.cpp.save:        || ch->in_room != get_room_index (ROOM_VNUM_LIMBO)) return;
comm.cpp.save:    ch->timer = 0;
comm.cpp.save:    char_to_room (ch, ch->was_in_room);
comm.cpp.save:    ch->was_in_room = NULL;
comm.cpp.save:    if (txt != NULL && ch->desc != NULL)
comm.cpp.save:        write_to_buffer (ch->desc, txt, strlen (txt));
comm.cpp.save:    if (txt == NULL || ch->desc == NULL)
comm.cpp.save:    if (ch->lines == 0)
comm.cpp.save:    if (ch->desc->showstr_head)
comm.cpp.save:      free_mem(ch->desc->showstr_head, strlen(ch->desc->showstr_head) + 1);
comm.cpp.save:    ch->desc->showstr_head = (char *) alloc_mem (strlen (txt) + 1);
comm.cpp.save:    strcpy (ch->desc->showstr_head, txt);
comm.cpp.save:    ch->desc->showstr_point = ch->desc->showstr_head;
comm.cpp.save:    show_string (ch->desc, "");
comm.cpp.save:    if (txt && ch->desc)
comm.cpp.save:        if (IS_SET (ch->act, PLR_COLOUR) ||
comm.cpp.save:            (IS_SWITCHED(ch) && IS_SET(ch->desc->original->act, PLR_COLOUR)))
comm.cpp.save:            write_to_buffer (ch->desc, buf, point2 - buf);
comm.cpp.save:            write_to_buffer (ch->desc, buf, point2 - buf);
comm.cpp.save:    if (txt && ch->desc)
comm.cpp.save:        if (IS_SET (ch->act, PLR_COLOUR) || 
comm.cpp.save:           (IS_SWITCHED(ch) && IS_SET(ch->desc->original->act, PLR_COLOUR)))
comm.cpp.save:            if (ch->desc->showstr_head)
comm.cpp.save:              free_string(ch->desc->showstr_head);
comm.cpp.save:            ch->desc->showstr_head = (char *) alloc_mem (strlen (buf) + 1);
comm.cpp.save:            strcpy (ch->desc->showstr_head, buf);
comm.cpp.save:            ch->desc->showstr_point = ch->desc->showstr_head;
comm.cpp.save:            show_string (ch->desc, "");
comm.cpp.save:            if (ch->desc->showstr_head)
comm.cpp.save:              free_string(ch->desc->showstr_head);
comm.cpp.save:            ch->desc->showstr_head = (char *) alloc_mem (strlen (buf) + 1);
comm.cpp.save:            strcpy (ch->desc->showstr_head, buf);
comm.cpp.save:            ch->desc->showstr_point = ch->desc->showstr_head;
comm.cpp.save:            show_string (ch->desc, "");
comm.cpp.save:    if (ch->sex < 0 || ch->sex > 2)
comm.cpp.save:        ch->sex = IS_NPC (ch) ? 0 : ch->pcdata->true_sex;
comm.cpp.save:    if (ch == NULL || ch->in_room == NULL)
comm.cpp.save:    to = ch->in_room->people;
comm.cpp.save:        if (vch->in_room == NULL)
comm.cpp.save:        to = vch->in_room->people;
comm.cpp.save:                        i = IS_DISGUISED(ch) ? ch->short_descr:PERS (ch, to, FALSE);
comm.cpp.save:                        i = IS_DISGUISED(vch) ? vch->short_descr:PERS (vch, to, FALSE);
comm.cpp.save:                        if (IS_NULLSTR(ch->pretit) || 
comm.cpp.save:			    !str_cmp(ch->pretit, "(null)") ||
comm.cpp.save:			  sprintf(pretit, "%s ", ch->pretit);
comm.cpp.save:                        if (IS_NULLSTR(vch->pretit) || 
comm.cpp.save:			    !str_cmp(vch->pretit, "(null)") ||
comm.cpp.save:			  sprintf(pretit, "%s ", vch->pretit);
comm.cpp.save:                        i = he_she[URANGE (0, ch->sex, 2)];
comm.cpp.save:                        i = he_she[URANGE (0, vch->sex, 2)];
comm.cpp.save:                        i = him_her[URANGE (0, ch->sex, 2)];
comm.cpp.save:                        i = him_her[URANGE (0, vch->sex, 2)];
comm.cpp.save:                        i = his_her[URANGE (0, ch->sex, 2)];
comm.cpp.save:                        i = his_her[URANGE (0, vch->sex, 2)];
comm.cpp.save:        for( obj = ch->in_room->contents; obj; obj = obj_next )
comm.cpp.save:            tch_next = tch->next_in_room;
comm.cpp.save:            for ( obj = tch->carrying; obj; obj = obj_next )
comm.cpp.save:         if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_ACT ) )
comm.cpp.save:             p_act_trigger( buf, NULL, NULL, ch->in_room, ch, NULL, NULL, TRIG_ACT );
comm.cpp.save:    if (ch == NULL || ch->in_room == NULL)
comm.cpp.save:        if (vch->in_room == NULL)
comm.cpp.save:                        i = IS_DISGUISED(ch)?ch->short_descr:PERS (ch, to, FALSE);
comm.cpp.save:                        i = IS_DISGUISED(vch)?vch->short_descr:PERS (vch, to, FALSE);
comm.cpp.save:                        i = he_she[URANGE (0, ch->sex, 2)];
comm.cpp.save:                        i = he_she[URANGE (0, vch->sex, 2)];
comm.cpp.save:                        i = him_her[URANGE (0, ch->sex, 2)];
comm.cpp.save:                        i = him_her[URANGE (0, vch->sex, 2)];
comm.cpp.save:                        i = his_her[URANGE (0, ch->sex, 2)];
comm.cpp.save:                        i = his_her[URANGE (0, vch->sex, 2)];
comm.cpp.save:    if (ch && IS_NPC (ch) && ch->desc->original == ch->desc->character)
comm.cpp.save:    col = ch ? ch->pcdata : NULL;
comm.cpp.save:    if (ch && ch->desc && txt)
comm.cpp.save:       if (IS_SET (ch->act, PLR_COLOUR)
comm.cpp.save:       ||  (IS_SWITCHED(ch) && IS_SET(ch->desc->original->act, PLR_COLOUR)))
comm.cpp.save:  ch->pcdata->mxpVersion = str_dup(version);
comm.cpp.save:  ch->pcdata->clientVersion = str_dup(client_version);
comm.cpp.save:  ch->pcdata->client = str_dup(client);
db.cpp:     rch->vnum = fread_number(fp);
db.cpp:     rch->difficulty = fread_number(fp);
db.cpp:     rch->question = fread_string(fp);
db.cpp:     rch->answer = fread_string(fp);
db.cpp:     iHash = rch->vnum % MAX_KEY_HASH;
db.cpp:     rch->next = riddle_hash[iHash];
db.cpp:     top_vnum_riddle = top_vnum_riddle < rch->vnum ? rch->vnum : top_vnum_riddle;
db.cpp:        fprintf(fp, "%d\n", rch->vnum);
db.cpp:        fprintf(fp, "%d\n", rch->difficulty);
db.cpp:        fprintf(fp, "%s~\n", rch->question);
db.cpp:        fprintf(fp, "%s~\n", rch->answer);
db.cpp:     vch->next = voteinfo.voters;
db.cpp:     vch->host = fread_string(fp);
db.cpp:     vch->id = fread_number(fp);
db.cpp:     vch->vote = fread_number(fp);
db.cpp:     vch->reason = fread_string(fp); 
db.cpp://     vch->reason = str_dup("None given"); 
db.cpp:    for (vch = voteinfo.voters; vch != NULL; vch = vch->next)
db.cpp:      fprintf(fp, "%s~\n", vch->host);
db.cpp:      fprintf(fp, "%d\n", vch->id);
db.cpp:      fprintf(fp, "%d\n", vch->vote);
db.cpp:      fprintf(fp, "%s~\n", vch->reason);
db.cpp:    ch->name = &str_empty[0];
db.cpp:    ch->short_descr = &str_empty[0];
db.cpp:    ch->long_descr = &str_empty[0];
db.cpp:    ch->description = &str_empty[0];
db.cpp:    ch->prompt = &str_empty[0];
db.cpp:    ch->logon = current_time;
db.cpp:    ch->lines = PAGELEN;
db.cpp:        ch->armor[i] = 100;
db.cpp:    ch->position = POS_STANDING;
db.cpp:    ch->hit = 20;
db.cpp:    ch->max_hit = 20;
db.cpp:    ch->mana = 100;
db.cpp:    ch->max_mana = 100;
db.cpp:    ch->move = 100;
db.cpp:    ch->max_move = 100;
db.cpp:    ch->on = NULL;
db.cpp:        ch->perm_stat[i] = 13;
db.cpp:        ch->mod_stat[i] = 0;
db.cpp:    for (fch = char_list; fch != NULL; fch = fch->next)
db.cpp:        if (fch->pcdata != NULL)
db.cpp:        for (af = fch->affected; af != NULL; af = af->next)
db.cpp:    for (fch = char_free; fch != NULL; fch = fch->next)
db.cpp:                 ch->in_room ? ch->in_room->vnum : 0, ch->name, str);
dice.cpp:               ch->name, get_value());
dice.cpp:  cecho(buf, ch->name);
dice.cpp:  if ((player = get_player(ch->name)) == NULL)
dice.cpp:    if (ch->questpoints < get_bet())
dice.cpp:      ch->questpoints -= get_bet();    
dice.cpp:    if ((ch->silver / 100 + ch->gold) < get_bet())
dice.cpp:          ch->questpoints += get_pot();
dice.cpp:          ch->gold += get_pot();
dice.cpp:            ch->questpoints += get_pot() / (tie + 1);
dice.cpp:            ch->gold += get_pot() / (tie + 1);
dice.cpp:    if ((game = find_game(ch->name)) == NULL)
dice.cpp:    if (find_game(ch->name))
dice.cpp:    game->new_player(ch->name);
dice.cpp:    if (find_game(ch->name))
dice.cpp:    Crowns game(5, ch->name);
dice.cpp:    if ((game = find_game(ch->name)) == NULL)
dice.cpp:    if ((game = find_game(ch->name)) == NULL)
dice.cpp:    sprintf(buf, "%s dice talks '`&%s`*'\n\r", ch->name, argument);
dice.cpp:    game->cecho(buf, ch->name);
dice.cpp:    if ((game = find_game(ch->name)) == NULL)
dice.cpp:    if ((player = game->get_player(ch->name)) == NULL)
disguise.cpp:    for (paf = ch->affected; paf != NULL; paf = paf_next)
disguise.cpp:            STR_REMOVE_BIT(ch->affected_by, paf->bitvector); 
disguise.cpp:    ch->name = ch->pcdata->disguise.orig_name;
disguise.cpp:    ch->pcdata->title = ch->pcdata->disguise.orig_title;
disguise.cpp:    ch->description = ch->pcdata->disguise.orig_desc;
disguise.cpp:    ch->short_descr = ch->pcdata->disguise.orig_short;
disguise.cpp:    ch->long_descr = ch->pcdata->disguise.orig_long;
disguise.cpp:    ch->sex = ch->pcdata->disguise.orig_sex;
disguise.cpp:        ch->pcdata->disguise.orig_name = ch->name;
disguise.cpp:        ch->pcdata->disguise.orig_title = ch->pcdata->title;
disguise.cpp:        ch->pcdata->disguise.orig_desc = ch->description;
disguise.cpp:        ch->pcdata->disguise.orig_short = ch->short_descr;
disguise.cpp:        ch->pcdata->disguise.orig_long = ch->long_descr;
disguise.cpp:        ch->pcdata->disguise.orig_sex = ch->sex;
disguise.cpp:        sprintf (tmpname, "%s ",ch->name);
disguise.cpp:        ch->name = str_dup(tmpname);
disguise.cpp:        ch->description = str_dup(victim->description);
disguise.cpp:        ch->pcdata->title = ("");
disguise.cpp:        ch->short_descr = str_dup(victim->short_descr);
disguise.cpp:        ch->long_descr = str_dup(victim->long_descr);
disguise.cpp:        ch->sex = victim->sex;
disguise.cpp:        af.level = ch->level;
disguise.cpp:        af.duration = number_fuzzy (ch->level / 6);
fight_bow.cpp:    if (IS_SET(ch->act, PLR_TOURNEY) || IS_SET(ch->act, PLR_QUESTING))
fight_bow.cpp:                if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight_bow.cpp:                if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight_bow.cpp:	    arrow->owner = str_dup(ch->name);
fight_bow.cpp:	    remove_arrow(ch,arrow,ch->in_room);
fight_bow.cpp:  in_room = ch->in_room;
fight_bow.cpp:  to_room = ch->in_room;
fight_bow.cpp:    if (IS_SET(in_room->room_flags,ROOM_SAFE)&& ch->pcdata->pk_timer == 0)
fight_bow.cpp:      ch->pcdata->pk_timer = 120;
fight_bow.cpp:      ch->pcdata->safe_timer =0;
fight_bow.cpp:	STR_REMOVE_BIT(ch->affected_by, AFF_SHROUD);
fight_bow.cpp:            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight_bow.cpp:            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight_bow.cpp:            ch->alignment = UMAX (-1000, ch->alignment - 1);
fight_bow.cpp:            ch->hit += dam / 2;
fight_bow.cpp:            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight_bow.cpp:            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight_bow.cpp:            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight_bow.cpp:            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight_bow.cpp:            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight_bow.cpp:            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight_bow.cpp:  in_room = ch->in_room;
fight_bow.cpp:  to_room = ch->in_room;
fight_bow.cpp:  if (ch->fighting != NULL)
fight_bow.cpp:      if (IS_SET(in_room->room_flags,ROOM_SAFE)&& ch->pcdata->pk_timer == 0 && victim->pcdata->pk_timer == 0)
fight_bow.cpp:      if (ch->mana < 50 && ch->move < 50)
fight_bow.cpp:      	 ch->mana -= 35;
fight_bow.cpp:      	 ch->move -= 20*MAX_DIST;
fight_bow.cpp:	  sprintf( buf1, "%s runs in from %s and looks around confused.",ch->name,tmp);	  
fight_bow.cpp:      sprintf(buf1,"%s runs in from the %s and does a flying side kick straight at %s!", ch->name,tmp, IS_NPC(victim)?victim->short_descr:victim->name);
fight_bow.cpp:      sprintf(buf3,"%s runs in from the %s and does a flying side kick straight at you!", ch->name, tmp);
fight_bow.cpp:      dam = number_range (int((ch->level)*2.5*(1+skill)/100), (ch->level)* 4*(1+skill)/100);
fight_bow.cpp:	  sprintf( buf1, "%s runs in from %s and looks around confused.",ch->name,tmp);	  
fight_bow.cpp:  in_room = ch->in_room;
fight_bow.cpp:  to_room = ch->in_room;
fight_bow.cpp:      if (ch->mana < 50 || ch->move < 50)
fight_bow.cpp:      	 ch->mana -= 15;
fight_bow.cpp:         ch->move -= 15;
fight_bow.cpp:      	 ch->move -= 10*MAX_DIST;
fight_bow.cpp:	    if (victim->position == POS_DEAD || ch->in_room != victim->in_room)
fight_bow.cpp:            sprintf(buf1,"%s seems to levitate into the air while his feet pummels you into the %s wall!", ch->name, tmp );
fight_bow.cpp:            sprintf(buf3,"%s seems to levitate into the air while his feet pummels %s into the %s wall!", ch->name,IS_NPC(victim)?victim->short_descr:victim->name, tmp );
fight_bow.cpp:            dam =number_range (int((ch->level)*2.0*(1+skill)/100.0), int((ch->level)* 3.0*(1+skill)/100.0));
fight_bow.cpp:            if (victim->position == POS_DEAD || ch->in_room != victim->in_room)
fight_bow.cpp:            sprintf(buf1,"%s seems to levitate into the air while his feet pummels you %s!", ch->name, tmp );
fight_bow.cpp:            sprintf(buf3,"%s seems to levitate into the air while his feet pummels %s %s!", ch->name,IS_NPC(victim)?victim->short_descr:victim->name, tmp );
fight_bow.cpp:            dam =number_range (int((ch->level)*1.2*(1+skill)/100), (ch->level)* 2*(1+skill)/100);
fight_bow.cpp:    	 if (victim->position == POS_DEAD || ch->in_room != victim->in_room)
fight_bow.cpp:    	 sprintf(buf1,"%s seems to levitate into the air while his feet pummels you but managed to dodge most of his kicks!", ch->name);
fight_bow.cpp:         sprintf(buf3,"%s seems to levitate into the air while his feet pummels %s but he managed to dodge most of your kicks !", ch->name,IS_NPC(victim)?victim->short_descr:victim->name);
fight_bow.cpp:         dam =number_range (int((ch->level)*0.85*(1+skill)/100), (ch->level)* 2*(1+skill)/100);
fight_bow.cpp:    if (ch->move <0||ch->mana<0)
fight_bow.cpp:    ch->move -= 3+ch->level/3;
fight_bow.cpp:    ch->mana -= 3+ch->level/5;
fight_bow.cpp:    af.level = int(ch->level / 1.1);
fight_bow.cpp:    af.duration = 3+ch->level / 5;
fight_bow.cpp:    af.modifier = int(-10 - ch->level*1.2);
fight_bow.cpp:    switch (ch->position)
fight_bow.cpp:            if (ch->fighting != NULL)
fight_bow.cpp:            if (str_cmp("form master", class_table[ch->cClass].name))
fight_bow.cpp:            if (argument[0] == '\0' && ch->on == NULL)
fight_bow.cpp:                ch->position = POS_MEDITATING;
fight_bow.cpp:                    obj = ch->on;
fight_bow.cpp:                    obj = get_obj_list (ch, argument, ch->in_room->contents);
fight_bow.cpp:                if (ch->on != obj && count_users (obj) >= obj->value[0])
fight_bow.cpp:                ch->on = obj;
fight_bow.cpp:                ch->position = POS_MEDITATING;
fight_bow.cpp: af.level     = ch->level; 
fight_bow.cpp: af.duration  = ch->level/3; 
fight_bow.cpp:    af.duration = ch->level/10;
fight.cpp:    if (ch->level < 11)
fight.cpp:    else if (ch->level < 16)
fight.cpp:    else if (ch->level < 26)
fight.cpp:    else if (ch->level < 36)
fight.cpp:    else if (ch->level < 46)
fight.cpp:    else if (ch->level < 56)
fight.cpp:    else if (ch->level < 66)
fight.cpp:    else if (ch->level <= 78)
fight.cpp:    difference = ch->level - victim->level;
fight.cpp:    if (difference > change && victim->level < ch->level && !IS_NPC(victim))
fight.cpp:    if (IS_INPKRANGE(ch,victim)|| IS_SET(ch->act, PLR_TOURNEY) || IS_SET(ch->act, PLR_QUESTING))
fight.cpp:        sprintf(buf,"%s (Level %d) has been killed by %s (Level %d) and OOL'd\nPlease check and verify if Murder Flag is appropriate.",victim->name,victim->level,ch->name,ch->level);
fight.cpp:    	sprintf(buf,"%s (Level %d) has been ganked by %s (Level %d) OOL steal!\nPlease check and verify if Thief Flag is appropriate.",IS_DISGUISED(victim)?victim->pcdata->disguise.orig_name:victim->name,victim->level,IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name,ch->level);
fight.cpp:    if (IS_NPC(ch)||IS_SET(ch->act, PLR_TOURNEY) || IS_SET(ch->act, PLR_QUESTING) || !IS_GUILDED(victim))
fight.cpp:        sprintf(vic_guild,"%s",clan_table[ch->clan].name);
fight.cpp:        IS_DISGUISED(victim)?victim->pcdata->disguise.orig_name:victim->name,IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name,vic_guild,IS_DISGUISED(victim)?victim->pcdata->disguise.orig_name:victim->name);
fight.cpp:        IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name,IS_DISGUISED(victim)?victim->pcdata->disguise.orig_name:victim->name,def_guild);
fight.cpp:        IS_DISGUISED(victim)?victim->pcdata->disguise.orig_name:victim->name,IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name,IS_DISGUISED(victim)?victim->pcdata->disguise.orig_name:victim->name);
fight.cpp:  for (pk = ch->pcdata->atkby;pk != NULL;pk = pk_next)      
fight.cpp:  for (pk = ch->pcdata->kill; pk != NULL; pk = pk_next)
fight.cpp:    ch->murd += 300;
fight.cpp:        ch_next = ch->next;
fight.cpp:        if ((victim = ch->fighting) == NULL || ch->in_room == NULL)
fight.cpp:	  ch->pcdata->damInflicted = 0;
fight.cpp:	  ch->pcdata->damReceived = 0;
fight.cpp:        if (IS_AWAKE (ch) && ch->in_room == victim->in_room)
fight.cpp:        if ((victim = ch->fighting) == NULL)
fight.cpp:        for ( obj = ch->carrying; obj; obj = obj_next )
fight.cpp:        if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_FIGHT ) && room_trig == FALSE )
fight.cpp:            p_percent_trigger( NULL, NULL, ch->in_room, victim, NULL, NULL, TRIG_FIGHT );
fight.cpp:        ch_next = ch->next;
fight.cpp:	  if ((ch->pcdata->damInflicted > 0 || ch->pcdata->damReceived > 0) && !ch->fighting)
fight.cpp:                  ch->pcdata->damInflicted, ch->pcdata->damReceived);
fight.cpp:            ch->pcdata->damInflicted = 0;
fight.cpp:            ch->pcdata->damReceived = 0;
fight.cpp:    for (rch = ch->in_room->people; rch != NULL; rch = rch_next)
fight.cpp:        rch_next = rch->next_in_room;
fight.cpp:        if (IS_AWAKE (rch) && rch->fighting == NULL && can_see(rch,victim))
fight.cpp:                && IS_SET (rch->off_flags, ASSIST_PLAYERS)
fight.cpp:                && rch->level + 6 > victim->level)
fight.cpp:                if (((!IS_NPC (rch) && IS_SET (rch->act, PLR_AUTOASSIST))
fight.cpp:                    	    rch->name,rch->level,ch->name,ch->level,victim->name,victim->level);
fight.cpp:                if ((IS_NPC (rch) && IS_SET (rch->off_flags, ASSIST_ALL))
fight.cpp:                    || (IS_NPC (rch) && rch->group && rch->group == ch->group)
fight.cpp:                    || (IS_NPC (rch) && rch->race == ch->race
fight.cpp:                        && IS_SET (rch->off_flags, ASSIST_RACE))
fight.cpp:                    || (IS_NPC (rch) && IS_SET (rch->off_flags, ASSIST_ALIGN)
fight.cpp:                    || (rch->pIndexData == ch->pIndexData
fight.cpp:                        && IS_SET (rch->off_flags, ASSIST_VNUM)))
fight.cpp:                    if (ch->rescuer && ch->fighting == ch->attacker)
fight.cpp:                    for (vch = ch->in_room->people; vch; vch = vch->next)
fight.cpp:    if (ch->desc == NULL)
fight.cpp:        ch->wait = UMAX (0, ch->wait - PULSE_VIOLENCE);
fight.cpp:    if (ch->desc == NULL)
fight.cpp:        ch->daze = UMAX (0, ch->daze - PULSE_VIOLENCE);
fight.cpp:          IS_SET(ch->act2, PLR_MSP_MUSIC) && 
fight.cpp:          !IS_SET(ch->act2, PLR_MSP_PLAYING))
fight.cpp:      SET_BIT(ch->act2, PLR_MSP_PLAYING);
fight.cpp:    if (IS_SET(ch->act2, PLR_FLED))
fight.cpp:      REMOVE_BIT(ch->act2, PLR_FLED);
fight.cpp:    if (ch->position < POS_RESTING)
fight.cpp:       STR_REMOVE_BIT(ch->affected_by, AFF_SHROUD);
fight.cpp:       STR_REMOVE_BIT(ch->affected_by, AFF_HIDE);
fight.cpp:      ch->pcdata->pk_timer = 120;
fight.cpp:      ch->pcdata->safe_timer = 0;
fight.cpp:    if (ch->clan != clan_lookup("Seanchan"))
fight.cpp:      blood_dam = number_range(ch->level * 2 + 20, ch->level * 3 - 20);
fight.cpp:      ch->hit += blood_dam / 2;  
fight.cpp:     chance -= class_table[ch->cClass].thac0_32;
fight.cpp:    if (ch->fighting != victim)
fight.cpp:    if (ch->fighting != victim 
fight.cpp:    	if (ch->fighting != victim)
fight.cpp:    chance -= class_table[ch->cClass].thac0_32 * 2;
fight.cpp:        if (ch->fighting != victim)
fight.cpp:    chance -= class_table[ch->cClass].thac0_32 * 2;
fight.cpp:        if (ch->fighting != victim)
fight.cpp:    if (!str_cmp("warrior", class_table[ch->cClass].name) && ch->pcdata->stance == STANCE_OFFENSIVE)
fight.cpp:    chance -= class_table[ch->cClass].thac0_32 * 2;
fight.cpp:    if (number_percent () < chance && (!str_cmp("warrior", class_table[ch->cClass].name) && ch->pcdata->stance != STANCE_OFFENSIVE))
fight.cpp:        if (ch->fighting != victim)
fight.cpp:    if ((ch->clan == clan_lookup("warder")) && (ch->sex == 1))
fight.cpp:    if (ch->attacker == victim)
fight.cpp:    if (ch->fighting != victim)
fight.cpp:    if (IS_SET (ch->off_flags, OFF_AREA_ATTACK))
fight.cpp:        for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
fight.cpp:            vch_next = vch->next;
fight.cpp:            if ((vch != victim && vch->fighting == ch))
fight.cpp:        || (IS_SET (ch->off_flags, OFF_FAST) && !IS_AFFECTED (ch, AFF_SLOW) && !IS_AFFECTED(ch, AFF_STICKY)))
fight.cpp:    if (ch->fighting != victim || dt == gsn_backstab)
fight.cpp:    if (IS_AFFECTED (ch, AFF_SLOW) && !IS_SET (ch->off_flags, OFF_FAST))
fight.cpp:        if (ch->fighting != victim)
fight.cpp:    if ((IS_AFFECTED(ch, AFF_STICKY) || IS_AFFECTED (ch, AFF_SLOW)) && !IS_SET (ch->off_flags, OFF_FAST))
fight.cpp:        if (ch->fighting != victim)
fight.cpp:    if (ch->wait > 0)
fight.cpp:    if (number == 1 && IS_SET (ch->act, ACT_MAGE))
fight.cpp:    if (number == 2 && IS_SET (ch->act, ACT_CLERIC))
fight.cpp:            if (IS_SET (ch->off_flags, OFF_BASH))
fight.cpp:            if (IS_SET (ch->off_flags, OFF_BERSERK)
fight.cpp:            if (IS_SET (ch->off_flags, OFF_DISARM)
fight.cpp:                    && (IS_SET (ch->act, ACT_WARRIOR)
fight.cpp:                        || IS_SET (ch->act, ACT_THIEF))))
fight.cpp:            if (IS_SET (ch->off_flags, OFF_KICK))
fight.cpp:            if (IS_SET (ch->off_flags, OFF_KICK_DIRT))
fight.cpp:            if (IS_SET (ch->off_flags, OFF_TAIL))
fight.cpp:            if (IS_SET (ch->off_flags, OFF_TRIP))
fight.cpp:            if (IS_SET (ch->off_flags, OFF_CRUSH))
fight.cpp:            if (IS_SET (ch->off_flags, OFF_BACKSTAB))
fight.cpp:        if (IS_SET (ch->act, ACT_WARRIOR))
fight.cpp:        else if (IS_SET (ch->act, ACT_THIEF))
fight.cpp:        else if (IS_SET (ch->act, ACT_CLERIC))
fight.cpp:        else if (IS_SET (ch->act, ACT_MAGE))
fight.cpp:        thac0_00 = class_table[ch->cClass].thac0_00;
fight.cpp:        thac0_32 = class_table[ch->cClass].thac0_32;
fight.cpp:    thac0 = interpolate (ch->level, thac0_00, thac0_32);
fight.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp:    if (!str_cmp("warrior", class_table[ch->cClass].name))
fight.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp:      if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp:    if (IS_NPC(ch) && ch->attacker == victim)
fight.cpp:    if (victim->position == POS_DEAD || ch->in_room != victim->in_room)
fight.cpp:            dt = TYPE_HIT + ch->dam_type;
fight.cpp:            dam_type = attack_table[ch->dam_type].damage;
fight.cpp:    if (!str_cmp("warrior", class_table[ch->cClass].name))
fight.cpp:    if (IS_NPC (ch) && (!ch->pIndexData->new_format || wield == NULL))
fight.cpp:        if (!ch->pIndexData->new_format)
fight.cpp:            dam = number_range (ch->level / 2, ch->level * 3 / 2);
fight.cpp:            dam = dice (ch->damage[DICE_NUMBER], ch->damage[DICE_TYPE]);
fight.cpp:			dam = number_range (int(mar_attack_table[dt - TYPE_HIT].mindam * mskill /100 + 2.5 * ch->level/4.0 * mskill /120.0),
fight.cpp:				  int(mar_attack_table[dt - TYPE_HIT].maxdam * mskill /100.0 + 2.5 * ch->level / 3.0 * mskill /120.0));
fight.cpp:		if (ch->fighting == victim && ch->pcdata->stance == STANCE_STRAW)
fight.cpp:			if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp:			ch->move -= number_range(25,50);
fight.cpp:			if (((ch->level < LEVEL_HERO && !IS_DRAGON(ch) && !IS_FORSAKEN(ch))
fight.cpp:				 || !IS_SET(ch->act2, PLR_NOEXP)) && !IS_SET(ch->act, PLR_QUESTING))
fight.cpp:			  ch->alignment = UMAX (-1000, ch->alignment - 1);
fight.cpp:			ch->hit += dam / 25;         
fight.cpp:        if (ch->fighting == victim && ch->pcdata->stance == STANCE_LEAF && dam > 0)
fight.cpp:                level = (ch->level);
fight.cpp:		if (ch->fighting == victim && ch->pcdata->stance == STANCE_STONE && dam > 0)
fight.cpp:			if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp:		if (ch->fighting == victim && ch->pcdata->stance == STANCE_WHIRLWIND && dam > 0)
fight.cpp:			if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp:		if (ch->fighting == victim && ch->pcdata->stance == STANCE_LIGHTNING && dam > 0)
fight.cpp:			if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp:			dam = number_range (int(ch->level/4 * mskill /100.0 + 25 * mskill /100.0),int(ch->level/2 * mskill /100.0+30 * mskill /100.0));
fight.cpp:			dam = number_range (int(1 + 4 * skill / 100.0), int(2 * ch->level / 3.0 * skill / 100.0));        
fight.cpp:    if (ch->interdimension > 0)
fight.cpp:	ch->interdimension = 0;
fight.cpp:            dam = dam * (2 + (ch->level / 15));
fight.cpp:            dam = dam * (2 + (ch->level / 12));
fight.cpp:             dam = int(dam * (5 + (ch->level / 10)));
fight.cpp:            dam = int(dam * (5 + (ch->level / 8)));
fight.cpp:       dam = dam * (2 + (ch->level / 12));     
fight.cpp:	dam_min += ch->level/10;
fight.cpp:	dam_max += ch->level/4;
fight.cpp:	dam_min += ch->level/10;
fight.cpp:	dam_max += ch->level/4;	
fight.cpp:	dam_min += ch->level/10;
fight.cpp:	dam_max += ch->level/4;
fight.cpp:        if (ch->fighting == victim && IS_WEAPON_STAT (wield, WEAPON_POISON))
fight.cpp:        if (ch->fighting == victim)
fight.cpp:        if (ch->fighting == victim && (IS_WEAPON_STAT (wield, WEAPON_VAMPIRIC)))
fight.cpp:            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp:            if (((ch->level < LEVEL_HERO && !IS_DRAGON(ch) && !IS_FORSAKEN(ch))
fight.cpp:                 || !IS_SET(ch->act2, PLR_NOEXP)) && !IS_SET(ch->act, PLR_QUESTING))
fight.cpp:              ch->alignment = UMAX (-1000, ch->alignment - 1);
fight.cpp:            ch->hit += dam / 2;         
fight.cpp:        if (ch->fighting == victim && (IS_WEAPON_STAT (wield, WEAPON_FLAMING)))
fight.cpp:            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp:        if (ch->fighting == victim && (IS_WEAPON_STAT (wield, WEAPON_FROST)))
fight.cpp:            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp:        if (ch->fighting == victim && (IS_WEAPON_STAT (wield, WEAPON_SHOCKING)))
fight.cpp:            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp:        if (ch->position > POS_STUNNED)
fight.cpp:            if (ch->fighting == NULL)
fight.cpp:      STR_REMOVE_BIT(ch->affected_by, AFF_SUPER_INVIS);
fight.cpp:    if (IS_AFFECTED (ch, AFF_INVISIBLE) && (dt != gsn_poison || ch->in_room == victim->in_room))
fight.cpp:        STR_REMOVE_BIT (ch->affected_by, AFF_INVISIBLE);
fight.cpp:      ch->pcdata->pk_timer = 120;
fight.cpp:      ch->pcdata->safe_timer = 0;
fight.cpp:	if (!str_cmp("form master", class_table[ch->cClass].name))
fight.cpp:      for (bch = ch->in_room->people; bch != NULL; bch = bch->next_in_room)
fight.cpp:        if (can_see(ch, bch) && strstr(ch->pcdata->bond, bch->name) &&
fight.cpp:               bch->fighting != NULL)
fight.cpp:        if ((pExit = ch->in_room->exit[door]) != NULL)
fight.cpp:          for (bch = pExit->u1.to_room->people; bch != NULL; bch = bch->next_in_room)
fight.cpp:            if (can_see(ch, bch) && strstr(ch->pcdata->bond, bch->name) &&
fight.cpp:                bch->fighting != NULL)
fight.cpp:        if ((ch->clan == clan_lookup("aessedai") || ch->clan == clan_lookup("Whitetower"))  && dt < TYPE_HIT)
fight.cpp:        else if (ch->clan == clan_lookup("Warder") && dt >= TYPE_HIT)
fight.cpp:      dam = int((dam * 1.30 * (get_skill(ch,gsn_focus) / 100.0) + (ch->level / 200.0)) * 0.80);
fight.cpp:      dam = int(dam * 1.30 * (get_skill(ch,gsn_focus) / 100.0) + (ch->level / 200.0));
fight.cpp:    if (ch->clan == clan_lookup("Redhand"))
fight.cpp:      if (ch->clan == clan_lookup("Wolfbrother"))
fight.cpp:    if ((ch->clan == clan_lookup("aessedai") && (ch->sex == 2)))
fight.cpp:     if (!IS_SET(ch->act2, PLR_TOURNEY))
fight.cpp:         if ((victim->honor == 0) && (ch->honor > 0))
fight.cpp:         ch->honor++;
fight.cpp:	 ch->practice += number_range(3,10);
fight.cpp:                     (IS_NPC (ch) ? ch->short_descr : ch->name),
fight.cpp:		     ch->level,
fight.cpp:                     ch->in_room->vnum);
fight.cpp:	    if (ch->level > 75 &&
fight.cpp:                 (IS_NPC (ch) ? ch->short_descr : ch->name),
fight.cpp:                 ch->in_room->name, ch->in_room->vnum);
fight.cpp:          victim->pcdata->lastKilled = str_dup(ch->name);
fight.cpp:    	REMOVE_BIT(ch->act, PLR_TAG);
fight.cpp:    	SET_BIT(ch->act, PLR_IT);
fight.cpp:    	ch->name);
fight.cpp:                get_obj_list (ch, "corpse", ch->in_room->contents)) != NULL
fight.cpp:            corpse = get_obj_list (ch, "corpse", ch->in_room->contents);
fight.cpp:            if (IS_SET (ch->act, PLR_AUTOLOOT) && corpse && corpse->contains)
fight.cpp:            if (IS_SET (ch->act, PLR_AUTOGOLD) && corpse && corpse->contains &&    /* exists and not empty */
fight.cpp:                !IS_SET (ch->act, PLR_AUTOLOOT))
fight.cpp:            if (IS_SET (ch->act, PLR_AUTOSAC))
fight.cpp:                if (IS_SET (ch->act, PLR_AUTOLOOT) && corpse
fight.cpp:		      ch->pcdata->damInflicted += dam;
fight.cpp:	  ch->pcdata->damInflicted += dam;
fight.cpp:	  ch->pcdata->damInflicted += dam;
fight.cpp:	       ch->pcdata->damInflicted += dam;
fight.cpp:      ch->pcdata->damInflicted += dam;
fight.cpp:    if (victim->in_room == NULL || ch->in_room == NULL)
fight.cpp:    if (ch->level > LEVEL_IMMORTAL)
fight.cpp:    if (ch->clan == clan_lookup("Guide") || victim->clan == clan_lookup("Guide")) // Hardcoded for speed sake
fight.cpp:	    if (IS_SET(ch->act, PLR_TOURNEY) && !IS_SET(victim->act, ACT_GUILDMOB) && 
fight.cpp:            if (IS_AFFECTED (ch, AFF_CHARM) && ch->master != NULL
fight.cpp:                && ch->master->fighting != victim)
fight.cpp:	    if (IS_SET(ch->act, PLR_TOURNEY) && 
fight.cpp:		(ch->pcdata->tournament.last_killed == victim->id ||
fight.cpp:		victim->pcdata->tournament.last_killed == ch->id))
fight.cpp:            if (ch->pcdata->wait_timer > 0)
fight.cpp:            if (IS_SET(victim->act, PLR_TOURNEY) && !IS_SET(ch->act, PLR_TOURNEY))
fight.cpp:            if (IS_SET(victim->act2, PLR_WAR) && !IS_SET(ch->act2, PLR_WAR))
fight.cpp:	    if (!IS_SET(victim->act, PLR_TOURNEY) && IS_SET(ch->act, PLR_TOURNEY))
fight.cpp:            if (!IS_SET(victim->act2, PLR_WAR) && IS_SET(ch->act2, PLR_WAR))
fight.cpp:            if (IS_SET(victim->act, PLR_QUESTING) && !IS_SET(ch->act, PLR_QUESTING))
fight.cpp:                        if (!IS_SET(victim->act, PLR_QUESTING) && IS_SET(ch->act, PLR_QUESTING))
fight.cpp:            if (((victim->pcdata->safe_timer > 0) || (ch->pcdata->safe_timer > 0)) && (!IS_SET(victim->act,
fight.cpp:            if (ch->pcdata->safe_timer > 0)
fight.cpp:		victim->fighting != ch->pet)
fight.cpp:            if (!str_cmp("Tinker", clan_table[ch->clan].name) &&
fight.cpp:            (!IS_SET(ch->act, PLR_TOURNEY)) && 
fight.cpp:            (!IS_SET(ch->act, PLR_QUESTING)) && 
fight.cpp:            (!IS_SET(ch->act, PLR_TAG)) &&
fight.cpp:            (!IS_SET(ch->act, PLR_IT)))  
fight.cpp:	    if (IS_SET(ch->act, PLR_NOPK))
fight.cpp:	    && !IS_SET(ch->act, PLR_TOURNEY) && !IS_SET(ch->act, PLR_QUESTING)
fight.cpp:	    && ch->id != victim->pcdata->initiator)
fight.cpp:    	        ch->name,ch->level,victim->name,victim->level);
fight.cpp:            victim->pcdata->initiator = ch->id;
fight.cpp:    if (victim->in_room == NULL || ch->in_room == NULL)
fight.cpp:    if (ch->level > LEVEL_IMMORTAL)
fight.cpp:            if (IS_AFFECTED (ch, AFF_CHARM) && ch->master != NULL
fight.cpp:                && ch->master->fighting != victim)
fight.cpp:            if (IS_SET(victim->act, PLR_TOURNEY) && !IS_SET(ch->act, PLR_TOURNEY))
fight.cpp:                        if (!IS_SET(victim->act, PLR_TOURNEY) && IS_SET(ch->act, PLR_TOURNEY))
fight.cpp:            if (IS_SET(victim->act, PLR_QUESTING) && !IS_SET(ch->act, PLR_QUESTING))
fight.cpp:                        if (!IS_SET(victim->act, PLR_QUESTING) && IS_SET(ch->act, PLR_QUESTING))
fight.cpp:            if (ch->pcdata->safe_timer > 0)
fight.cpp:            if (!str_cmp("Tinker", clan_table[ch->clan].name) &&
fight.cpp:            (!IS_SET(ch->act, PLR_TOURNEY)) && 
fight.cpp:            (!IS_SET(ch->act, PLR_QUESTING)) && 
fight.cpp:            (!IS_SET(ch->act, PLR_TAG)) &&
fight.cpp:            (!IS_SET(ch->act, PLR_IT)))  
fight.cpp:	    if (IS_SET(ch->act, PLR_NOPK))
fight.cpp:	    && !IS_SET(ch->act, PLR_TOURNEY) && !IS_SET(ch->act, PLR_QUESTING)
fight.cpp:	    && ch->id != victim->pcdata->initiator)
fight.cpp:    	        ch->name,ch->level,victim->name,victim->level);
fight.cpp:            victim->pcdata->initiator = ch->id;
fight.cpp:    if (victim->in_room == NULL || ch->in_room == NULL)
fight.cpp:    if (IS_AFFECTED(victim, AFF_SUPER_INVIS) && !IS_SET(ch->act, PLR_HOLYLIGHT))
fight.cpp:    if (ch->level > LEVEL_IMMORTAL)
fight.cpp:    if (ch->clan == clan_lookup("Guide") || victim->clan == clan_lookup("Guide")) // Hardcoded for speed sake
fight.cpp:            if (IS_SET(ch->act, PLR_TOURNEY) && !IS_SET(victim->act, ACT_GUILDMOB) &&
fight.cpp:            if (area && !is_same_group (victim, ch->fighting))
fight.cpp:            if (IS_AFFECTED (ch, AFF_CHARM) && ch->master != NULL
fight.cpp:                && ch->master->fighting != victim)
fight.cpp:            if (ch->fighting != NULL && !is_same_group (ch->fighting, victim))
fight.cpp:	    if (IS_SET(ch->act, PLR_TOURNEY) && 
fight.cpp:		(ch->pcdata->tournament.last_killed == victim->id ||
fight.cpp:		victim->pcdata->tournament.last_killed == ch->id))
fight.cpp:            if (ch->pcdata->wait_timer > 0)
fight.cpp:		victim->fighting != ch->pet)
fight.cpp:	    if (IS_SET(victim->act, PLR_NOPK) || IS_SET(ch->act, PLR_NOPK))
fight.cpp:	    && !IS_SET(ch->act, PLR_TOURNEY) && !IS_SET(ch->act, PLR_QUESTING)
fight.cpp:	    && ch->id != victim->pcdata->initiator)
fight.cpp:    	        ch->name,ch->level,victim->name,victim->level);
fight.cpp:            victim->pcdata->initiator = ch->id;
fight.cpp:       diff = victim->level - ch->level;       
fight.cpp:          diff = int(20 + ((victim->level - ch->level)*.05));
fight.cpp:          diff = int(-20 + ((victim->level - ch->level)*.05));
fight.cpp:        adj_chance = 2*(victim->level - ch->level);//Player Level difference
fight.cpp:    if (IS_SET (ch->off_flags, OFF_FAST) 
fight.cpp:    if (ch->clan == clan_lookup("Whitetower") && victim->clan != clan_lookup("Whitetower") && !furies_imm(ch,victim))
fight.cpp:        && str_cmp("warrior", class_table[ch->cClass].name) && get_eq_char( ch, WEAR_WIELD)==NULL)
fight.cpp:        && ch->clan != clan_lookup("Whitecloak") && IS_AFFECTED(ch, AFF_STANCE))
fight.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp:       diff = ch->level - victim->level;
fight.cpp:          diff = int(20 + ((ch->level - victim->level)*.05));
fight.cpp:          diff = int(-20 + ((ch->level - victim->level)*.05));
fight.cpp:        adjustment = 2 * (ch->level - victim->level);//Player Level difference
fight.cpp:    if (IS_SET (ch->off_flags, OFF_FAST) 
fight.cpp:    if (!str_cmp("warrior", class_table[ch->cClass].name))
fight.cpp:    if (ch->clan == clan_lookup("Whitetower") && victim->clan != clan_lookup("Whitetower") && !furies_imm(ch,victim))
fight.cpp:    if (!str_cmp("warrior", class_table[ch->cClass].name) && get_eq_char( ch, WEAR_WIELD)==NULL
fight.cpp:    if ( (ch->clan == clan_lookup("Whitecloak") && IS_AFFECTED(ch, AFF_STANCE)
fight.cpp:            switch (ch->in_room->sector_type)
fight.cpp:            adjustment += ch->carry_weight / 250;
fight.cpp:            if (ch->size < victim->size)
fight.cpp:                adjustment += (ch->size - victim->size) * 15;
fight.cpp:                adjustment += (ch->size - victim->size) * 10;
fight.cpp:            adjustment += ch->carry_weight / 250;
fight.cpp:            if (ch->size < victim->size)
fight.cpp:                adjustment += (ch->size - victim->size) * 15;
fight.cpp:                adjustment += (ch->size - victim->size) * 10;
fight.cpp:            if (ch->position == POS_FIGHTING)
fight.cpp:            adjustment += 25 - (100 * ch->hit / ch->max_hit) / 2;
fight.cpp:             if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp:             if (ch->size < victim->size)
fight.cpp:                 adjustment += (ch->size - victim->size) * 10;    /* bigger = harder to trip */
fight.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp:    if (ch->fighting != NULL)
fight.cpp:    ch->fighting = victim;
fight.cpp:    ch->position = POS_FIGHTING;
fight.cpp:    for (fch = char_list; fch != NULL; fch = fch->next)
fight.cpp:        if (fch == ch || (fBoth && fch->fighting == ch))
fight.cpp:            fch->fighting = NULL;
fight.cpp:            fch->position = IS_NPC (fch) ? fch->default_pos : POS_STANDING;
fight.cpp:            if (!IS_NPC(fch) && IS_SET(fch->act2, PLR_MSP_MUSIC))
fight.cpp:		fch->pcdata->aggro_timer = 6; 
fight.cpp:        name = ch->short_descr;
fight.cpp:        if (ch->gold >= 0)
fight.cpp:            obj_to_obj (create_money (ch->gold, ch->silver), corpse);
fight.cpp:            ch->gold = 0;
fight.cpp:            ch->silver = 0;
fight.cpp:        name = ch->name;
fight.cpp:        corpse->owner = str_dup (ch->name);
fight.cpp:	if (ch->pcdata->lastKilled != '\0')
fight.cpp:	  corpse->lastKilled = str_dup (ch->pcdata->lastKilled);
fight.cpp:          if (IS_SET(ch->act2, PLR_LOOTABLE) && IS_SET(killer->act2, PLR_LOOTABLE))
fight.cpp:          if (IS_SET(ch->act2, PLR_WAR))
fight.cpp:	  if (((killer = get_char_world_special(ch->pcdata->lastKilled)) != NULL)
fight.cpp:	if (ch->gold > 1 || ch->silver > 1)
fight.cpp:           obj_to_obj (create_money (ch->gold / 2, ch->silver / 2),
fight.cpp:           ch->gold -= ch->gold / 2;
fight.cpp:           ch->silver -= ch->silver / 2;
fight.cpp:    corpse->level = ch->level;
fight.cpp:    for (obj = ch->carrying; obj != NULL; obj = obj_next)
fight.cpp:                        obj_to_room (in, ch->in_room);
fight.cpp:                obj_to_room (obj, ch->in_room);
fight.cpp:    obj_to_room (corpse, ch->in_room);
fight.cpp:            if (ch->material == 0)
fight.cpp:            if (IS_SET (ch->parts, PART_GUTS))
fight.cpp:            if (IS_SET (ch->parts, PART_HEAD))
fight.cpp:            if (IS_SET (ch->parts, PART_HEART))
fight.cpp:            if (IS_SET (ch->parts, PART_ARMS))
fight.cpp:            if (IS_SET (ch->parts, PART_LEGS))
fight.cpp:            if (IS_SET (ch->parts, PART_BRAINS))
fight.cpp:        name = IS_NPC (ch) ? ch->short_descr : ch->name;
fight.cpp:            if (IS_SET (ch->form, FORM_POISON))
fight.cpp:            else if (!IS_SET (ch->form, FORM_EDIBLE))
fight.cpp:        obj_to_room (obj, ch->in_room);
fight.cpp:    was_in_room = ch->in_room;
fight.cpp:            ch->in_room = pexit->u1.to_room;
fight.cpp:    ch->in_room = was_in_room;
fight.cpp:    for (obj = ch->carrying; obj != NULL; obj = obj_next)
fight.cpp:	  obj_to_room(obj, ch->in_room);
fight.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_MSP_SOUND))
fight.cpp:    if (!IS_NPC(ch) && IS_NPC(victim) && !getbit(ch->pcdata->mobbed, victim->pIndexData->vnum))
fight.cpp:      setbit( ch->pcdata->mobbed, victim->pIndexData->vnum);
fight.cpp:        update_mobbed(ch->name, count);
fight.cpp:        /* if ( !IS_NPC(ch) && !IS_SET(ch->act, PLR_TOURNEY) && 
fight.cpp:	     !IS_SET(ch->act, PLR_QUESTING))
fight.cpp:                  ch->murd = ch->murd + 300;
fight.cpp:	if ( IS_NPC(ch) && ch->hunting != NULL )
fight.cpp:		ch->hunting = NULL;	
fight.cpp:	if (IS_NPC(ch) && ch->memory != NULL )
fight.cpp:    if (!IS_NPC(ch) && IS_SET(ch->act, PLR_TOURNEY))
fight.cpp:    for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room)
fight.cpp:            int dif = gch->level - ch->level;
fight.cpp:              group_levels += IS_NPC (gch) ? gch->level / 2 : gch->level;  
fight.cpp:           else if (abs(dif) < ch->level / 6)
fight.cpp:              group_levels += IS_NPC (gch) ? gch->level / 4 : gch->level; 
fight.cpp:              group_levels += IS_NPC (gch) ? gch->level / 2 : gch->level;
fight.cpp:        group_levels = ch->level;
fight.cpp:    lch = (ch->leader != NULL) ? ch->leader : ch;
fight.cpp:    for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room)
fight.cpp:        if (IS_SET(ch->act, PLR_QUESTOR) && IS_NPC(victim))
fight.cpp:            if (ch->questmob == victim->pIndexData->vnum &&
fight.cpp:               (ch->rescuemob == 0 || victim->attacking == ch->rescuemob))
fight.cpp:                if (ch->rescuemob != 0)
fight.cpp:                ch->questmob = -1;
fight.cpp:        if(IS_SET(gch->act2, PLR_NOEXP))        
fight.cpp:		if (IS_SET(gch->act, PLR_QUESTING))
fight.cpp:		   if (ch->level < 75)
fight.cpp:        for (obj = ch->carrying; obj != NULL; obj = obj_next)
fight.cpp:                obj_to_room (obj, ch->in_room);
fight.cpp:    level_range = victim->level - gch->level;
fight.cpp:    align = victim->alignment - gch->alignment;
fight.cpp:           && (gch->level >= LEVEL_HERO || IS_DRAGON(gch) || IS_FORSAKEN(gch))
fight.cpp:           && IS_SET(gch->act2, PLR_NOEXP) || IS_SET(gch->act, PLR_QUESTING)))
fight.cpp:        change = (align - 500) * base_exp / 500 * gch->level / total_levels;
fight.cpp:        if ((gch->level < LEVEL_HERO && !IS_FORSAKEN(gch) && !IS_DRAGON(gch))
fight.cpp:           || !IS_SET(gch->act2, PLR_NOEXP) || !IS_SET(gch->act, PLR_QUESTING))
fight.cpp:          gch->alignment = UMAX (-1000, gch->alignment - change);
fight.cpp:          if (gch->alignment > 1000)
fight.cpp:              gch->alignment = 1000;
fight.cpp:            (-1 * align - 500) * base_exp / 500 * gch->level / total_levels;
fight.cpp:        if ((gch->level < LEVEL_HERO && !IS_FORSAKEN(gch) && !IS_DRAGON(gch)) 
fight.cpp:           || !IS_SET(gch->act2, PLR_NOEXP) || (!IS_SET(gch->act, PLR_QUESTING))) 
fight.cpp:          gch->alignment = UMIN (1000, gch->alignment + change);
fight.cpp:          if (gch->alignment < -1000)
fight.cpp:              gch->alignment = -1000;
fight.cpp:        change = gch->alignment * base_exp / 500 * gch->level / total_levels;
fight.cpp:        if ((gch->level < LEVEL_HERO && !IS_DRAGON(gch) && !IS_FORSAKEN(gch))
fight.cpp:           || !IS_SET(gch->act2, PLR_NOEXP) || (!IS_SET(gch->act, PLR_QUESTING))) 
fight.cpp:          gch->alignment -= change;
fight.cpp:    else if (gch->alignment > 500)
fight.cpp:    else if (gch->alignment < -500)
fight.cpp:    else if (gch->alignment > 200)
fight.cpp:    else if (gch->alignment < -200)
fight.cpp:    if (gch->level < 6)
fight.cpp:        xp = 10 * xp / (gch->level + 4);
fight.cpp:    if (gch->level > 35)
fight.cpp:        xp = 15 * xp / (gch->level - 25);
fight.cpp:       modifier = float(gch->level) / ((total_levels - gch->level) / (members - 1));
fight.cpp:      if (gch->pcdata->xpmultiplier.on)
fight.cpp:        if (gch->pcdata->xpmultiplier.factor > 0)
fight.cpp:          xp = xp * gch->pcdata->xpmultiplier.factor;
fight.cpp:        if (gch->pcdata->xpmultiplier.factor < 0)
fight.cpp:          xp = xp / abs(gch->pcdata->xpmultiplier.factor);
fight.cpp:    if (IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)
fight.cpp:    if (ch->position == POS_FIGHTING)
fight.cpp:        || (IS_NPC (ch) && IS_SET (ch->act, ACT_PET)))
fight.cpp:    if (IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)
fight.cpp:    if (ch->position == POS_FIGHTING)
fight.cpp:        sprintf (buf, "Help! I am being attacked by %s!", ch->short_descr);
fight.cpp:        sprintf (buf, "Help!  I am being attacked by %s!", ch->name);
fight.cpp:    if ((victim = ch->fighting) == NULL)
fight.cpp:        if (ch->position == POS_FIGHTING)
fight.cpp:            ch->position = POS_STANDING;
fight.cpp:    was_in = ch->in_room;
fight.cpp:            || number_range (0, ch->daze) != 0 
fight.cpp:        if ((now_in = ch->in_room) == was_in)
fight.cpp:        ch->in_room = was_in;
fight.cpp:        ch->in_room = now_in;
fight.cpp:		  ch->pcdata->damInflicted, ch->pcdata->damReceived);
fight.cpp:	   ch->pcdata->damInflicted = 0;
fight.cpp:	   ch->pcdata->damReceived = 0;
fight.cpp:            SET_BIT(ch->act2, PLR_FLED);  
fight.cpp:            if ((ch->cClass == 2) && (number_percent () < 3 * (ch->level / 2)))
fight.cpp:    if ((mob = ch->fighting) == NULL)
fight.cpp:      &&  (ch->level < skill_table[gsn_engage].skill_level[ch->cClass]))
fight.cpp:  if (ch->fighting == NULL)
fight.cpp:  if (ch->fighting == victim)
fight.cpp:  if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
fight.cpp:  if ((victim->fighting != ch) && (ch->level < 35))
fight.cpp:      if (ch->in_room == victim->in_room)
fight.cpp:                     (IS_NPC (ch) ? ch->short_descr : ch->name),
fight.cpp:		     ch->level,
fight.cpp:                     ch->in_room->vnum);
fight.cpp:	     if (ch->level > 75 &&
fight.cpp:                 (IS_NPC (ch) ? ch->short_descr : ch->name),
fight.cpp:                 ch->in_room->name, ch->in_room->vnum);
fight.cpp:            victim->pcdata->lastKilled = str_dup(ch->name);
fight.cpp:    	  REMOVE_BIT(ch->act, PLR_TAG);
fight.cpp:    	  SET_BIT(ch->act, PLR_IT);
fight.cpp:    	  ch->name);
fight.cpp:         if (ch->in_room == victim->in_room)
fight.cpp:    if (ch->fighting != NULL)
fight.cpp:  if (ch->fighting != NULL)
fight.cpp:  if (ch->hit < (ch->max_hit / 2) && IS_NPC(victim))
fight.cpp:	if (ch->fighting != NULL)
fight.cpp:    if (!str_cmp("warrior", class_table[ch->cClass].name) && ch->pcdata->stance != STANCE_DEFENSIVE)
fight.cpp:    if (ch->fighting == victim)
fight.cpp:        victim = ch->fighting;
fight.cpp:        && (ch->level < skill_table[gsn_kick].skill_level[ch->cClass]
fight.cpp:    if (IS_NPC (ch) && !IS_SET (ch->off_flags, OFF_KICK))
fight.cpp:    /*if ((victim = ch->fighting) == NULL)
fight.cpp:    	    dam =number_range (int(1+(ch->level/2.5)), int(ch->level/1.5));
fight.cpp:            dam =number_range (1+(ch->level/3), int(ch->level/1.8));
fight.cpp:    if ((victim = ch->fighting) == NULL)
fight.cpp:    if (!str_cmp("warrior", class_table[ch->cClass].name) && ch->pcdata->stance != STANCE_OFFENSIVE)
fight.cpp:        || (IS_NPC (ch) && !IS_SET (ch->off_flags, OFF_BERSERK))
fight.cpp:            && ch->level < skill_table[gsn_berserk].skill_level[ch->cClass]))
fight.cpp:    if (ch->mana < 50)
fight.cpp:            if (ch->position == POS_FIGHTING)
fight.cpp:            chance += 25 - (100 * ch->hit / ch->max_hit) / 2;
fight.cpp:        ch->mana -= 50;
fight.cpp:        ch->move /= 2;
fight.cpp:        ch->hit += ch->level * 2;
fight.cpp:        ch->hit = UMIN (ch->hit, ch->max_hit);
fight.cpp:        af.level = ch->level;
fight.cpp:        af.duration = number_fuzzy (ch->level / 8);
fight.cpp:        af.modifier = UMAX (1, ch->level / 5);
fight.cpp:        af.modifier = UMAX (10, 10 * (ch->level / 5));
fight.cpp:        ch->mana -= 25;
fight.cpp:        ch->move /= 2;
fight.cpp:        || (IS_NPC (ch) && !IS_SET (ch->off_flags, OFF_BASH))
fight.cpp:            && ch->level < skill_table[gsn_bash].skill_level[ch->cClass]))
fight.cpp:    if (!str_cmp("warrior", class_table[ch->cClass].name) && ch->pcdata->stance != STANCE_OFFENSIVE)
fight.cpp:        victim = ch->fighting;
fight.cpp:    if (IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)
fight.cpp:        dam =number_range ((ch->level / 2), (ch->level / 2) + 10 * ch->size + number_percent() / 2);
fight.cpp:        ch->position = POS_RESTING;
fight.cpp:        || (IS_NPC (ch) && !IS_SET (ch->off_flags, OFF_KICK_DIRT))
fight.cpp:            && ch->level < skill_table[gsn_dirt].skill_level[ch->cClass]))
fight.cpp:    if (!str_cmp("warrior", class_table[ch->cClass].name) && ch->pcdata->stance != STANCE_OFFENSIVE)
fight.cpp:        victim = ch->fighting;
fight.cpp:    if (IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)
fight.cpp:    if (ch->in_room->sector_type == SECT_WATER_SWIM
fight.cpp:      || ch->in_room->sector_type == SECT_WATER_NOSWIM
fight.cpp:      || ch->in_room->sector_type == SECT_AIR)
fight.cpp:        af.level = ch->level;
fight.cpp:            chance += ( victim->level - ch->level );        
fight.cpp:            dt += ch->dam_type;
fight.cpp:    	    dam_type = attack_table[ch->dam_type].damage;
fight.cpp:        || (IS_NPC (ch) && !IS_SET (ch->off_flags, OFF_TRIP))
fight.cpp:            && ch->level < skill_table[gsn_trip].skill_level[ch->cClass]))
fight.cpp:    if (!str_cmp("warrior", class_table[ch->cClass].name) && ch->pcdata->stance != STANCE_OFFENSIVE)
fight.cpp:        victim = ch->fighting;
fight.cpp:    if (IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)
fight.cpp:    if (ch->fighting != NULL)
fight.cpp:    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.cpp:	af.level 	= ch->level;
fight.cpp:       sprintf(buf, "%s tried to BJ from %s, but failed.\n\r", ch->name, victim->name);
fight.cpp:        STR_REMOVE_BIT (ch->affected_by, AFF_SNEAK);
fight.cpp:        STR_REMOVE_BIT (ch->affected_by, AFF_HIDE);
fight.cpp:        STR_REMOVE_BIT (ch->affected_by, AFF_SHROUD);
fight.cpp:                ch->name,ch->level,victim->name,victim->level);
fight.cpp:            && ch->level < skill_table[gsn_flip].skill_level[ch->cClass]))
fight.cpp:        victim = ch->fighting;
fight.cpp:    if (IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)
fight.cpp:        damage (ch, victim, number_range ((ch->level / 2), (ch->level / 2) + 10 * ch->size + number_percent() / 2),
fight.cpp:            && ch->level < skill_table[gsn_rub].skill_level[ch->cClass]))
fight.cpp:    if (!str_cmp("warrior", class_table[ch->cClass].name) && ch->pcdata->stance != STANCE_DEFENSIVE)
fight.cpp:    if( ch->stunned)
fight.cpp:            && ch->level < skill_table[gsn_dance].skill_level[ch->cClass]))
fight.cpp:  sprintf(buf, "Current dance: %s\n\r",stance_table[ch->pcdata->stance].name);
fight.cpp: ch->pcdata->stance = 0;
fight.cpp: ch->pcdata->stance = 1;
fight.cpp: ch->pcdata->stance = 2;
fight.cpp: ch->pcdata->stance = 3;
fight.cpp: ch->pcdata->stance = 4;
fight.cpp: ch->pcdata->stance = 5;
fight.cpp: ch->pcdata->stance = 6;
fight.cpp:            && ch->level < skill_table[gsn_style].skill_level[ch->cClass]))
fight.cpp:  sprintf(buf, "Current style: %s\n\r",stance_table[ch->pcdata->stance].name);
fight.cpp: ch->pcdata->stance = 0;
fight.cpp: ch->pcdata->stance = 7;
fight.cpp: ch->pcdata->stance = 8;
fight.cpp:            && ch->level < skill_table[gsn_gash].skill_level[ch->cClass]))
fight.cpp:    if( (victim = ch->fighting) == NULL )
fight.cpp:    if( ch->stunned)
fight.cpp:	ch->move-=25;
fight.cpp:	ch->move-=25;
fight.cpp:        ch->move-=25;
fight.cpp:        if( (victim = ch->fighting) == NULL)
fight.cpp:        if (ch->stunned)
fight.cpp:        damage(ch,victim,number_range(ch->level/2, ch->level),gsn_caltraps,DAM_PIERCE, TRUE, FALSE);
fight.cpp:                af.level         = ch->level;
fight.cpp:            && ch->level < skill_table[gsn_salve].skill_level[ch->cClass]))
fight.cpp:    ch->move -= 10;
fight.cpp:            paf->duration       = ch->level / 20;
fight.cpp:        af.duration     = ch->level / 20;
fight.cpp:            && ch->level < skill_table[gsn_dislodge].skill_level[ch->cClass]))
fight.cpp:    if (!str_cmp("warrior", class_table[ch->cClass].name) && ch->pcdata->stance != STANCE_DEFENSIVE)
fight.cpp:    if ((victim = ch->fighting) == NULL)
fight.cpp:            && ch->level < skill_table[gsn_quickening].skill_level[ch->cClass]))
fight.cpp:    af.level    = ch->level;
fight.cpp:    af.duration = ch->level / 4;
fight.cpp:        || (IS_NPC (ch) && !IS_SET (ch->off_flags, OFF_KICK_DIRT))
fight.cpp:            && ch->level < skill_table[gsn_gouge].skill_level[ch->cClass]))
fight.cpp:        victim = ch->fighting;
fight.cpp:    if (IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)
fight.cpp:        af.level = ch->level;
fight.cpp:            && ch->level < skill_table[gsn_unseen_fury].skill_level[ch->cClass]))
fight.cpp:            paf->duration       = ch->level / 20;
fight.cpp:  if (IS_SET(ch->act, PLR_TOURNEY) && tournament.noguild)
fight.cpp:  if (ch->darkcounter >= 3)
fight.cpp:  for (gch = char_list; gch != NULL; gch = gch->next)
fight.cpp:    af.level = ch->level;
fight.cpp:     char_to_room( darkhound, ch->in_room );
fight.cpp:    darkhound->max_hit = int(ch->max_hit * .25);
fight.cpp:    darkhound->level = int(ch->level * .8);
fight.cpp:    darkhound->hitroll = int(ch->hitroll * .8);
fight.cpp:    darkhound->damroll = int(ch->damroll * .8);
fight.cpp:    ch->pet = darkhound;
fight.cpp':    if (ch->level < 11)
fight.cpp':    else if (ch->level < 16)
fight.cpp':    else if (ch->level < 26)
fight.cpp':    else if (ch->level < 36)
fight.cpp':    else if (ch->level < 46)
fight.cpp':    else if (ch->level < 56)
fight.cpp':    else if (ch->level < 66)
fight.cpp':    else if (ch->level <= 78)
fight.cpp':    difference = ch->level - victim->level;
fight.cpp':    if (difference > change && victim->level < ch->level && !IS_NPC(victim))
fight.cpp':    if (IS_INPKRANGE(ch,victim)|| IS_SET(ch->act, PLR_TOURNEY) || IS_SET(ch->act, PLR_QUESTING))
fight.cpp':        sprintf(buf,"%s (Level %d) has been killed by %s (Level %d) and OOL'd\nPlease check and verify if Murder Flag is appropriate.",victim->name,victim->level,ch->name,ch->level);
fight.cpp':    	sprintf(buf,"%s (Level %d) has been ganked by %s (Level %d) OOL steal!\nPlease check and verify if Thief Flag is appropriate.",IS_DISGUISED(victim)?victim->pcdata->disguise.orig_name:victim->name,victim->level,IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name,ch->level);
fight.cpp':    if (IS_NPC(ch)||IS_SET(ch->act, PLR_TOURNEY) || IS_SET(ch->act, PLR_QUESTING) || !IS_GUILDED(victim))
fight.cpp':        sprintf(vic_guild,"%s",clan_table[ch->clan].name);
fight.cpp':        IS_DISGUISED(victim)?victim->pcdata->disguise.orig_name:victim->name,IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name,vic_guild,IS_DISGUISED(victim)?victim->pcdata->disguise.orig_name:victim->name);
fight.cpp':        IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name,IS_DISGUISED(victim)?victim->pcdata->disguise.orig_name:victim->name,def_guild);
fight.cpp':        IS_DISGUISED(victim)?victim->pcdata->disguise.orig_name:victim->name,IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name,IS_DISGUISED(victim)?victim->pcdata->disguise.orig_name:victim->name);
fight.cpp':  for (pk = ch->pcdata->atkby;pk != NULL;pk = pk_next)      
fight.cpp':  for (pk = ch->pcdata->kill; pk != NULL; pk = pk_next)
fight.cpp':    ch->murd += 300;
fight.cpp':        ch_next = ch->next;
fight.cpp':        if ((victim = ch->fighting) == NULL || ch->in_room == NULL)
fight.cpp':	  ch->pcdata->damInflicted = 0;
fight.cpp':	  ch->pcdata->damReceived = 0;
fight.cpp':        if (IS_AWAKE (ch) && ch->in_room == victim->in_room)
fight.cpp':        if ((victim = ch->fighting) == NULL)
fight.cpp':        for ( obj = ch->carrying; obj; obj = obj_next )
fight.cpp':        if ( HAS_TRIGGER_ROOM( ch->in_room, TRIG_FIGHT ) && room_trig == FALSE )
fight.cpp':            p_percent_trigger( NULL, NULL, ch->in_room, victim, NULL, NULL, TRIG_FIGHT );
fight.cpp':        ch_next = ch->next;
fight.cpp':	  if ((ch->pcdata->damInflicted > 0 || ch->pcdata->damReceived > 0) && !ch->fighting)
fight.cpp':                  ch->pcdata->damInflicted, ch->pcdata->damReceived);
fight.cpp':            ch->pcdata->damInflicted = 0;
fight.cpp':            ch->pcdata->damReceived = 0;
fight.cpp':    for (rch = ch->in_room->people; rch != NULL; rch = rch_next)
fight.cpp':        rch_next = rch->next_in_room;
fight.cpp':        if (IS_AWAKE (rch) && rch->fighting == NULL && can_see(rch,victim))
fight.cpp':                && IS_SET (rch->off_flags, ASSIST_PLAYERS)
fight.cpp':                && rch->level + 6 > victim->level)
fight.cpp':                if (((!IS_NPC (rch) && IS_SET (rch->act, PLR_AUTOASSIST))
fight.cpp':                    	    rch->name,rch->level,ch->name,ch->level,victim->name,victim->level);
fight.cpp':                if ((IS_NPC (rch) && IS_SET (rch->off_flags, ASSIST_ALL))
fight.cpp':                    || (IS_NPC (rch) && rch->group && rch->group == ch->group)
fight.cpp':                    || (IS_NPC (rch) && rch->race == ch->race
fight.cpp':                        && IS_SET (rch->off_flags, ASSIST_RACE))
fight.cpp':                    || (IS_NPC (rch) && IS_SET (rch->off_flags, ASSIST_ALIGN)
fight.cpp':                    || (rch->pIndexData == ch->pIndexData
fight.cpp':                        && IS_SET (rch->off_flags, ASSIST_VNUM)))
fight.cpp':                    if (ch->rescuer && ch->fighting == ch->attacker)
fight.cpp':                    for (vch = ch->in_room->people; vch; vch = vch->next)
fight.cpp':    if (ch->desc == NULL)
fight.cpp':        ch->wait = UMAX (0, ch->wait - PULSE_VIOLENCE);
fight.cpp':    if (ch->desc == NULL)
fight.cpp':        ch->daze = UMAX (0, ch->daze - PULSE_VIOLENCE);
fight.cpp':          IS_SET(ch->act2, PLR_MSP_MUSIC) && 
fight.cpp':          !IS_SET(ch->act2, PLR_MSP_PLAYING))
fight.cpp':      SET_BIT(ch->act2, PLR_MSP_PLAYING);
fight.cpp':    if (IS_SET(ch->act2, PLR_FLED))
fight.cpp':      REMOVE_BIT(ch->act2, PLR_FLED);
fight.cpp':    if (ch->position < POS_RESTING)
fight.cpp':       STR_REMOVE_BIT(ch->affected_by, AFF_SHROUD);
fight.cpp':       STR_REMOVE_BIT(ch->affected_by, AFF_HIDE);
fight.cpp':      ch->pcdata->pk_timer = 120;
fight.cpp':      ch->pcdata->safe_timer = 0;
fight.cpp':    if (ch->clan != clan_lookup("Seanchan"))
fight.cpp':      blood_dam = number_range(ch->level * 2 + 20, ch->level * 3 - 20);
fight.cpp':      ch->hit += blood_dam / 2;  
fight.cpp':     chance -= class_table[ch->cClass].thac0_32;
fight.cpp':    if (ch->fighting != victim)
fight.cpp':    if (ch->fighting != victim 
fight.cpp':    	if (ch->fighting != victim)
fight.cpp':    chance -= class_table[ch->cClass].thac0_32 * 2;
fight.cpp':        if (ch->fighting != victim)
fight.cpp':    chance -= class_table[ch->cClass].thac0_32 * 2;
fight.cpp':        if (ch->fighting != victim)
fight.cpp':    chance -= class_table[ch->cClass].thac0_32 * 2;
fight.cpp':        if (ch->fighting != victim)
fight.cpp':    if ((ch->clan == clan_lookup("warder")) && (ch->sex == 1))
fight.cpp':    if (ch->attacker == victim)
fight.cpp':    if (ch->fighting != victim)
fight.cpp':    if (IS_SET (ch->off_flags, OFF_AREA_ATTACK))
fight.cpp':        for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
fight.cpp':            vch_next = vch->next;
fight.cpp':            if ((vch != victim && vch->fighting == ch))
fight.cpp':        || (IS_SET (ch->off_flags, OFF_FAST) && !IS_AFFECTED (ch, AFF_SLOW) && !IS_AFFECTED(ch, AFF_STICKY)))
fight.cpp':    if (ch->fighting != victim || dt == gsn_backstab)
fight.cpp':    if (IS_AFFECTED (ch, AFF_SLOW) && !IS_SET (ch->off_flags, OFF_FAST))
fight.cpp':        if (ch->fighting != victim)
fight.cpp':    if ((IS_AFFECTED(ch, AFF_STICKY) || IS_AFFECTED (ch, AFF_SLOW)) && !IS_SET (ch->off_flags, OFF_FAST))
fight.cpp':        if (ch->fighting != victim)
fight.cpp':    if (ch->wait > 0)
fight.cpp':    if (number == 1 && IS_SET (ch->act, ACT_MAGE))
fight.cpp':    if (number == 2 && IS_SET (ch->act, ACT_CLERIC))
fight.cpp':            if (IS_SET (ch->off_flags, OFF_BASH))
fight.cpp':            if (IS_SET (ch->off_flags, OFF_BERSERK)
fight.cpp':            if (IS_SET (ch->off_flags, OFF_DISARM)
fight.cpp':                    && (IS_SET (ch->act, ACT_WARRIOR)
fight.cpp':                        || IS_SET (ch->act, ACT_THIEF))))
fight.cpp':            if (IS_SET (ch->off_flags, OFF_KICK))
fight.cpp':            if (IS_SET (ch->off_flags, OFF_KICK_DIRT))
fight.cpp':            if (IS_SET (ch->off_flags, OFF_TAIL))
fight.cpp':            if (IS_SET (ch->off_flags, OFF_TRIP))
fight.cpp':            if (IS_SET (ch->off_flags, OFF_CRUSH))
fight.cpp':            if (IS_SET (ch->off_flags, OFF_BACKSTAB))
fight.cpp':        if (IS_SET (ch->act, ACT_WARRIOR))
fight.cpp':        else if (IS_SET (ch->act, ACT_THIEF))
fight.cpp':        else if (IS_SET (ch->act, ACT_CLERIC))
fight.cpp':        else if (IS_SET (ch->act, ACT_MAGE))
fight.cpp':        thac0_00 = class_table[ch->cClass].thac0_00;
fight.cpp':        thac0_32 = class_table[ch->cClass].thac0_32;
fight.cpp':    thac0 = interpolate (ch->level, thac0_00, thac0_32);
fight.cpp':    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp':    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp':    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp':    if (!str_cmp("warrior", class_table[ch->cClass].name))
fight.cpp':    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp':    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp':    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp':    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp':      if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp':    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp':    if (IS_NPC(ch) && ch->attacker == victim)
fight.cpp':    if (victim->position == POS_DEAD || ch->in_room != victim->in_room)
fight.cpp':            dt = TYPE_HIT + ch->dam_type;
fight.cpp':            dam_type = attack_table[ch->dam_type].damage;
fight.cpp':    if (!str_cmp("warrior", class_table[ch->cClass].name))
fight.cpp':    if (IS_NPC (ch) && (!ch->pIndexData->new_format || wield == NULL))
fight.cpp':        if (!ch->pIndexData->new_format)
fight.cpp':            dam = number_range (ch->level / 2, ch->level * 3 / 2);
fight.cpp':            dam = dice (ch->damage[DICE_NUMBER], ch->damage[DICE_TYPE]);
fight.cpp':			dam = number_range (int(mar_attack_table[dt - TYPE_HIT].mindam * mskill /100 + 2.5 * ch->level/4.0 * mskill /120.0),
fight.cpp':				  int(mar_attack_table[dt - TYPE_HIT].maxdam * mskill /100.0 + 2.5 * ch->level / 3.0 * mskill /120.0));
fight.cpp':		if (ch->fighting == victim && ch->pcdata->stance == STANCE_STRAW)
fight.cpp':			if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp':			if (((ch->level < LEVEL_HERO && !IS_DRAGON(ch) && !IS_FORSAKEN(ch))
fight.cpp':				 || !IS_SET(ch->act2, PLR_NOEXP)) && !IS_SET(ch->act, PLR_QUESTING))
fight.cpp':			  ch->alignment = UMAX (-1000, ch->alignment - 1);
fight.cpp':			ch->hit += dam / 2;         
fight.cpp':        if (ch->fighting == victim && ch->pcdata->stance == STANCE_LEAF)
fight.cpp':                level = (ch->level);
fight.cpp':		if (ch->fighting == victim && ch->pcdata->stance == STANCE_STONE)
fight.cpp':			if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp':		if (ch->fighting == victim && ch->pcdata->stance == STANCE_WHIRLWIND)
fight.cpp':			if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp':		if (ch->fighting == victim && ch->pcdata->stance == STANCE_LIGHTNING)
fight.cpp':			if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp':			dam = number_range (int(ch->level/4 * mskill /100.0 + 25 * mskill /100.0),int(ch->level/2 * mskill /100.0+30 * mskill /100.0));
fight.cpp':			dam = number_range (int(1 + 4 * skill / 100.0), int(2 * ch->level / 3.0 * skill / 100.0));        
fight.cpp':    if (ch->interdimension > 0)
fight.cpp':	ch->interdimension = 0;
fight.cpp':            dam = dam * (2 + (ch->level / 15));
fight.cpp':            dam = dam * (2 + (ch->level / 12));
fight.cpp':             dam = int(dam * (5 + (ch->level / 10)));
fight.cpp':            dam = int(dam * (5 + (ch->level / 8)));
fight.cpp':       dam = dam * (2 + (ch->level / 12));     
fight.cpp':	dam_min += ch->level/10;
fight.cpp':	dam_max += ch->level/4;
fight.cpp':	dam_min += ch->level/10;
fight.cpp':	dam_max += ch->level/4;	
fight.cpp':	dam_min += ch->level/10;
fight.cpp':	dam_max += ch->level/4;
fight.cpp':        if (ch->fighting == victim && IS_WEAPON_STAT (wield, WEAPON_POISON))
fight.cpp':        if (ch->fighting == victim)
fight.cpp':        if (ch->fighting == victim && (IS_WEAPON_STAT (wield, WEAPON_VAMPIRIC)))
fight.cpp':            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp':            if (((ch->level < LEVEL_HERO && !IS_DRAGON(ch) && !IS_FORSAKEN(ch))
fight.cpp':                 || !IS_SET(ch->act2, PLR_NOEXP)) && !IS_SET(ch->act, PLR_QUESTING))
fight.cpp':              ch->alignment = UMAX (-1000, ch->alignment - 1);
fight.cpp':            ch->hit += dam / 2;         
fight.cpp':	if (ch->fighting == victim)
fight.cpp':            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp':            if (((ch->level < LEVEL_HERO && !IS_DRAGON(ch) && !IS_FORSAKEN(ch))
fight.cpp':                 || !IS_SET(ch->act2, PLR_NOEXP)) && !IS_SET(ch->act, PLR_QUESTING))
fight.cpp':              ch->alignment = UMAX (-1000, ch->alignment - 1);
fight.cpp':            ch->hit += dam / 2;
fight.cpp':        if (ch->fighting == victim && (IS_WEAPON_STAT (wield, WEAPON_FLAMING)))
fight.cpp':            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp':        if (ch->fighting == victim && (IS_WEAPON_STAT (wield, WEAPON_FROST)))
fight.cpp':            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp':        if (ch->fighting == victim && (IS_WEAPON_STAT (wield, WEAPON_SHOCKING)))
fight.cpp':            if (!IS_SET(ch->act2, PLR_NODAMAGE))
fight.cpp':        if (ch->position > POS_STUNNED)
fight.cpp':            if (ch->fighting == NULL)
fight.cpp':      STR_REMOVE_BIT(ch->affected_by, AFF_SUPER_INVIS);
fight.cpp':    if (IS_AFFECTED (ch, AFF_INVISIBLE) && (dt != gsn_poison || ch->in_room == victim->in_room))
fight.cpp':        STR_REMOVE_BIT (ch->affected_by, AFF_INVISIBLE);
fight.cpp':      ch->pcdata->pk_timer = 120;
fight.cpp':      ch->pcdata->safe_timer = 0;
fight.cpp':      for (bch = ch->in_room->people; bch != NULL; bch = bch->next_in_room)
fight.cpp':        if (can_see(ch, bch) && strstr(ch->pcdata->bond, bch->name) &&
fight.cpp':               bch->fighting != NULL)
fight.cpp':        if ((pExit = ch->in_room->exit[door]) != NULL)
fight.cpp':          for (bch = pExit->u1.to_room->people; bch != NULL; bch = bch->next_in_room)
fight.cpp':            if (can_see(ch, bch) && strstr(ch->pcdata->bond, bch->name) &&
fight.cpp':                bch->fighting != NULL)
fight.cpp':        if ((ch->clan == clan_lookup("Whitetower") || ch->clan == clan_lookup("Rebel"))  && dt < TYPE_HIT)
fight.cpp':      /*  else if (ch->clan == clan_lookup("Warder") && dt >= TYPE_HIT)
fight.cpp':      dam = int((dam * 2 * (get_skill(ch,gsn_focus) / 100.0) + (ch->level / 200.0)) * 0.80);
fight.cpp':      dam = int(dam * 2 * (get_skill(ch,gsn_focus) / 100.0) + (ch->level / 200.0));
fight.cpp':    if (ch->clan == clan_lookup("Redhand"))
fight.cpp':      if (ch->clan == clan_lookup("Wolfbrother"))
fight.cpp':    if ((ch->clan == clan_lookup("aessedai") && (ch->sex == 2)))
fight.cpp':     if (!IS_SET(ch->act2, PLR_TOURNEY))
fight.cpp':         if ((victim->honor == 0) && (ch->honor > 0))
fight.cpp':         ch->honor++;
fight.cpp':                     (IS_NPC (ch) ? ch->short_descr : ch->name),
fight.cpp':		     ch->level,
fight.cpp':                     ch->in_room->vnum);
fight.cpp':	    if (ch->level > 75 &&
fight.cpp':                 (IS_NPC (ch) ? ch->short_descr : ch->name),
fight.cpp':                 ch->in_room->name, ch->in_room->vnum);
fight.cpp':          victim->pcdata->lastKilled = str_dup(ch->name);
fight.cpp':    	REMOVE_BIT(ch->act, PLR_TAG);
fight.cpp':    	SET_BIT(ch->act, PLR_IT);
fight.cpp':    	ch->name);
fight.cpp':                get_obj_list (ch, "corpse", ch->in_room->contents)) != NULL
fight.cpp':            corpse = get_obj_list (ch, "corpse", ch->in_room->contents);
fight.cpp':            if (IS_SET (ch->act, PLR_AUTOLOOT) && corpse && corpse->contains)
fight.cpp':            if (IS_SET (ch->act, PLR_AUTOGOLD) && corpse && corpse->contains &&    /* exists and not empty */
fight.cpp':                !IS_SET (ch->act, PLR_AUTOLOOT))
fight.cpp':            if (IS_SET (ch->act, PLR_AUTOSAC))
fight.cpp':                if (IS_SET (ch->act, PLR_AUTOLOOT) && corpse
fight.cpp':		      ch->pcdata->damInflicted += dam;
fight.cpp':	  ch->pcdata->damInflicted += dam;
fight.cpp':	  ch->pcdata->damInflicted += dam;
fight.cpp':	       ch->pcdata->damInflicted += dam;
fight.cpp':      ch->pcdata->damInflicted += dam;
fight.cpp':    if (victim->in_room == NULL || ch->in_room == NULL)
fight.cpp':    if (ch->level > LEVEL_IMMORTAL)
fight.cpp':    if (ch->clan == clan_lookup("Guide") || victim->clan == clan_lookup("Guide")) // Hardcoded for speed sake
fight.cpp':	    if (IS_SET(ch->act, PLR_TOURNEY) && !IS_SET(victim->act, ACT_GUILDMOB) && 
fight.cpp':            if (IS_AFFECTED (ch, AFF_CHARM) && ch->master != NULL
fight.cpp':                && ch->master->fighting != victim)
fight.cpp':	    if (IS_SET(ch->act, PLR_TOURNEY) && 
fight.cpp':		(ch->pcdata->tournament.last_killed == victim->id ||
fight.cpp':		victim->pcdata->tournament.last_killed == ch->id))
fight.cpp':            if (ch->pcdata->wait_timer > 0)
fight.cpp':            if (IS_SET(victim->act, PLR_TOURNEY) && !IS_SET(ch->act, PLR_TOURNEY))
fight.cpp':            if (IS_SET(victim->act2, PLR_WAR) && !IS_SET(ch->act2, PLR_WAR))
fight.cpp':	    if (!IS_SET(victim->act, PLR_TOURNEY) && IS_SET(ch->act, PLR_TOURNEY))
fight.cpp':            if (!IS_SET(victim->act2, PLR_WAR) && IS_SET(ch->act2, PLR_WAR))
fight.cpp':            if (IS_SET(victim->act, PLR_QUESTING) && !IS_SET(ch->act, PLR_QUESTING))
fight.cpp':                        if (!IS_SET(victim->act, PLR_QUESTING) && IS_SET(ch->act, PLR_QUESTING))
fight.cpp':            if (((victim->pcdata->safe_timer > 0) || (ch->pcdata->safe_timer > 0)) && (!IS_SET(victim->act,
fight.cpp':            if (ch->pcdata->safe_timer > 0)
fight.cpp':		victim->fighting != ch->pet)
fight.cpp':            if (!str_cmp("Tinker", clan_table[ch->clan].name) &&
fight.cpp':            (!IS_SET(ch->act, PLR_TOURNEY)) && 
fight.cpp':            (!IS_SET(ch->act, PLR_QUESTING)) && 
fight.cpp':            (!IS_SET(ch->act, PLR_TAG)) &&
fight.cpp':            (!IS_SET(ch->act, PLR_IT)))  
fight.cpp':	    if (IS_SET(ch->act, PLR_NOPK))
fight.cpp':	    && !IS_SET(ch->act, PLR_TOURNEY) && !IS_SET(ch->act, PLR_QUESTING)
fight.cpp':	    && ch->id != victim->pcdata->initiator)
fight.cpp':    	        ch->name,ch->level,victim->name,victim->level);
fight.cpp':            victim->pcdata->initiator = ch->id;
fight.cpp':    if (victim->in_room == NULL || ch->in_room == NULL)
fight.cpp':    if (ch->level > LEVEL_IMMORTAL)
fight.cpp':            if (IS_AFFECTED (ch, AFF_CHARM) && ch->master != NULL
fight.cpp':                && ch->master->fighting != victim)
fight.cpp':            if (IS_SET(victim->act, PLR_TOURNEY) && !IS_SET(ch->act, PLR_TOURNEY))
fight.cpp':                        if (!IS_SET(victim->act, PLR_TOURNEY) && IS_SET(ch->act, PLR_TOURNEY))
fight.cpp':            if (IS_SET(victim->act, PLR_QUESTING) && !IS_SET(ch->act, PLR_QUESTING))
fight.cpp':                        if (!IS_SET(victim->act, PLR_QUESTING) && IS_SET(ch->act, PLR_QUESTING))
fight.cpp':            if (ch->pcdata->safe_timer > 0)
fight.cpp':            if (!str_cmp("Tinker", clan_table[ch->clan].name) &&
fight.cpp':            (!IS_SET(ch->act, PLR_TOURNEY)) && 
fight.cpp':            (!IS_SET(ch->act, PLR_QUESTING)) && 
fight.cpp':            (!IS_SET(ch->act, PLR_TAG)) &&
fight.cpp':            (!IS_SET(ch->act, PLR_IT)))  
fight.cpp':	    if (IS_SET(ch->act, PLR_NOPK))
fight.cpp':	    && !IS_SET(ch->act, PLR_TOURNEY) && !IS_SET(ch->act, PLR_QUESTING)
fight.cpp':	    && ch->id != victim->pcdata->initiator)
fight.cpp':    	        ch->name,ch->level,victim->name,victim->level);
fight.cpp':            victim->pcdata->initiator = ch->id;
fight.cpp':    if (victim->in_room == NULL || ch->in_room == NULL)
fight.cpp':    if (IS_AFFECTED(victim, AFF_SUPER_INVIS) && !IS_SET(ch->act, PLR_HOLYLIGHT))
fight.cpp':    if (ch->level > LEVEL_IMMORTAL)
fight.cpp':    if (ch->clan == clan_lookup("Guide") || victim->clan == clan_lookup("Guide")) // Hardcoded for speed sake
fight.cpp':            if (IS_SET(ch->act, PLR_TOURNEY) && !IS_SET(victim->act, ACT_GUILDMOB) &&
fight.cpp':            if (area && !is_same_group (victim, ch->fighting))
fight.cpp':            if (IS_AFFECTED (ch, AFF_CHARM) && ch->master != NULL
fight.cpp':                && ch->master->fighting != victim)
fight.cpp':            if (ch->fighting != NULL && !is_same_group (ch->fighting, victim))
fight.cpp':	    if (IS_SET(ch->act, PLR_TOURNEY) && 
fight.cpp':		(ch->pcdata->tournament.last_killed == victim->id ||
fight.cpp':		victim->pcdata->tournament.last_killed == ch->id))
fight.cpp':            if (ch->pcdata->wait_timer > 0)
fight.cpp':		victim->fighting != ch->pet)
fight.cpp':	    if (IS_SET(victim->act, PLR_NOPK) || IS_SET(ch->act, PLR_NOPK))
fight.cpp':	    && !IS_SET(ch->act, PLR_TOURNEY) && !IS_SET(ch->act, PLR_QUESTING)
fight.cpp':	    && ch->id != victim->pcdata->initiator)
fight.cpp':    	        ch->name,ch->level,victim->name,victim->level);
fight.cpp':            victim->pcdata->initiator = ch->id;
fight.cpp':       diff = victim->level - ch->level;       
fight.cpp':          diff = int(20 + ((victim->level - ch->level)*.05));
fight.cpp':          diff = int(-20 + ((victim->level - ch->level)*.05));
fight.cpp':        adj_chance = 2*(victim->level - ch->level);//Player Level difference
fight.cpp':    if (IS_SET (ch->off_flags, OFF_FAST) 
fight.cpp':    if (ch->clan == clan_lookup("Whitetower") && victim->clan != clan_lookup("Whitetower") && !furies_imm(ch,victim))
fight.cpp':        && str_cmp("warrior", class_table[ch->cClass].name) && get_eq_char( ch, WEAR_WIELD)==NULL)
fight.cpp':        && ch->clan != clan_lookup("Whitecloak") && IS_AFFECTED(ch, AFF_STANCE))
fight.cpp':    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp':       diff = ch->level - victim->level;
fight.cpp':          diff = int(20 + ((ch->level - victim->level)*.05));
fight.cpp':          diff = int(-20 + ((ch->level - victim->level)*.05));
fight.cpp':        adjustment = 2 * (ch->level - victim->level);//Player Level difference
fight.cpp':    if (IS_SET (ch->off_flags, OFF_FAST) 
fight.cpp':    if (ch->clan == clan_lookup("Whitetower") && victim->clan != clan_lookup("Whitetower") && !furies_imm(ch,victim))
fight.cpp':    if (!str_cmp("warrior", class_table[ch->cClass].name) && get_eq_char( ch, WEAR_WIELD)==NULL
fight.cpp':    if ( (ch->clan == clan_lookup("Whitecloak") && IS_AFFECTED(ch, AFF_STANCE)
fight.cpp':            switch (ch->in_room->sector_type)
fight.cpp':            adjustment += ch->carry_weight / 250;
fight.cpp':            if (ch->size < victim->size)
fight.cpp':                adjustment += (ch->size - victim->size) * 15;
fight.cpp':                adjustment += (ch->size - victim->size) * 10;
fight.cpp':            adjustment += ch->carry_weight / 250;
fight.cpp':            if (ch->size < victim->size)
fight.cpp':                adjustment += (ch->size - victim->size) * 15;
fight.cpp':                adjustment += (ch->size - victim->size) * 10;
fight.cpp':            if (ch->position == POS_FIGHTING)
fight.cpp':            adjustment += 25 - (100 * ch->hit / ch->max_hit) / 2;
fight.cpp':             if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp':             if (ch->size < victim->size)
fight.cpp':                 adjustment += (ch->size - victim->size) * 10;    /* bigger = harder to trip */
fight.cpp':    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_TESTOR))
fight.cpp':    if (ch->fighting != NULL)
fight.cpp':    ch->fighting = victim;
fight.cpp':    ch->position = POS_FIGHTING;
fight.cpp':    for (fch = char_list; fch != NULL; fch = fch->next)
fight.cpp':        if (fch == ch || (fBoth && fch->fighting == ch))
fight.cpp':            fch->fighting = NULL;
fight.cpp':            fch->position = IS_NPC (fch) ? fch->default_pos : POS_STANDING;
fight.cpp':            if (!IS_NPC(fch) && IS_SET(fch->act2, PLR_MSP_MUSIC))
fight.cpp':		fch->pcdata->aggro_timer = 6; 
fight.cpp':        name = ch->short_descr;
fight.cpp':        if (ch->gold >= 0)
fight.cpp':            obj_to_obj (create_money (ch->gold, ch->silver), corpse);
fight.cpp':            ch->gold = 0;
fight.cpp':            ch->silver = 0;
fight.cpp':        name = ch->name;
fight.cpp':        corpse->owner = str_dup (ch->name);
fight.cpp':	if (ch->pcdata->lastKilled != '\0')
fight.cpp':	  corpse->lastKilled = str_dup (ch->pcdata->lastKilled);
fight.cpp':          if (IS_SET(ch->act2, PLR_LOOTABLE) && IS_SET(killer->act2, PLR_LOOTABLE))
fight.cpp':          if (IS_SET(ch->act2, PLR_WAR))
fight.cpp':	  if (((killer = get_char_world_special(ch->pcdata->lastKilled)) != NULL)
fight.cpp':	if (ch->gold > 1 || ch->silver > 1)
fight.cpp':           obj_to_obj (create_money (ch->gold / 2, ch->silver / 2),
fight.cpp':           ch->gold -= ch->gold / 2;
fight.cpp':           ch->silver -= ch->silver / 2;
fight.cpp':    corpse->level = ch->level;
fight.cpp':    for (obj = ch->carrying; obj != NULL; obj = obj_next)
fight.cpp':                        obj_to_room (in, ch->in_room);
fight.cpp':                obj_to_room (obj, ch->in_room);
fight.cpp':    obj_to_room (corpse, ch->in_room);
fight.cpp':            if (ch->material == 0)
fight.cpp':            if (IS_SET (ch->parts, PART_GUTS))
fight.cpp':            if (IS_SET (ch->parts, PART_HEAD))
fight.cpp':            if (IS_SET (ch->parts, PART_HEART))
fight.cpp':            if (IS_SET (ch->parts, PART_ARMS))
fight.cpp':            if (IS_SET (ch->parts, PART_LEGS))
fight.cpp':            if (IS_SET (ch->parts, PART_BRAINS))
fight.cpp':        name = IS_NPC (ch) ? ch->short_descr : ch->name;
fight.cpp':            if (IS_SET (ch->form, FORM_POISON))
fight.cpp':            else if (!IS_SET (ch->form, FORM_EDIBLE))
fight.cpp':        obj_to_room (obj, ch->in_room);
fight.cpp':    was_in_room = ch->in_room;
fight.cpp':            ch->in_room = pexit->u1.to_room;
fight.cpp':    ch->in_room = was_in_room;
fight.cpp':    for (obj = ch->carrying; obj != NULL; obj = obj_next)
fight.cpp':	  obj_to_room(obj, ch->in_room);
fight.cpp':    if (!IS_NPC(ch) && IS_SET(ch->act2, PLR_MSP_SOUND))
fight.cpp':    if (!IS_NPC(ch) && IS_NPC(victim) && !getbit(ch->pcdata->mobbed, victim->pIndexData->vnum))
fight.cpp':      setbit( ch->pcdata->mobbed, victim->pIndexData->vnum);
fight.cpp':        update_mobbed(ch->name, count);
fight.cpp':        /*if ( !IS_NPC(ch) && !IS_SET(ch->act, PLR_TOURNEY) && 
fight.cpp':	     !IS_SET(ch->act, PLR_QUESTING))
fight.cpp':                  ch->murd = ch->murd + 300;
fight.cpp':	if ( IS_NPC(ch) && ch->hunting != NULL )
fight.cpp':		ch->hunting = NULL;	
fight.cpp':	if (IS_NPC(ch) && ch->memory != NULL )
fight.cpp':    if (!IS_NPC(ch) && IS_SET(ch->act, PLR_TOURNEY))
fight.cpp':    for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room)
fight.cpp':           int dif = gch->level - ch->level;
fight.cpp':              group_levels += IS_NPC (gch) ? gch->level / 2 : gch->level;  
fight.cpp':           else if (abs(dif) < ch->level / 6)
fight.cpp':              group_levels += IS_NPC (gch) ? gch->level / 4 : gch->level / 2;
fight.cpp':              group_levels += IS_NPC (gch) ? gch->level / 2 : gch->level * 2;
fight.cpp':        group_levels = ch->level;
fight.cpp':    lch = (ch->leader != NULL) ? ch->leader : ch;
fight.cpp':    for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room)
fight.cpp':        if (IS_SET(ch->act, PLR_QUESTOR) && IS_NPC(victim))
fight.cpp':            if (ch->questmob == victim->pIndexData->vnum &&
fight.cpp':               (ch->rescuemob == 0 || victim->attacking == ch->rescuemob))
fight.cpp':                if (ch->rescuemob != 0)
fight.cpp':                ch->questmob = -1;
fight.cpp':        if(IS_SET(gch->act2, PLR_NOEXP))        
fight.cpp':		if (IS_SET(gch->act, PLR_QUESTING))
fight.cpp':		   if (ch->level < 75)
fight.cpp':        for (obj = ch->carrying; obj != NULL; obj = obj_next)
fight.cpp':                obj_to_room (obj, ch->in_room);
fight.cpp':    level_range = victim->level - gch->level;
fight.cpp':    align = victim->alignment - gch->alignment;
fight.cpp':           && (gch->level >= LEVEL_HERO || IS_DRAGON(gch) || IS_FORSAKEN(gch))
fight.cpp':           && IS_SET(gch->act2, PLR_NOEXP) || IS_SET(gch->act, PLR_QUESTING)))
fight.cpp':        change = (align - 500) * base_exp / 500 * gch->level / total_levels;
fight.cpp':        if ((gch->level < LEVEL_HERO && !IS_FORSAKEN(gch) && !IS_DRAGON(gch))
fight.cpp':           || !IS_SET(gch->act2, PLR_NOEXP) || !IS_SET(gch->act, PLR_QUESTING))
fight.cpp':          gch->alignment = UMAX (-1000, gch->alignment - change);
fight.cpp':          if (gch->alignment > 1000)
fight.cpp':              gch->alignment = 1000;
fight.cpp':            (-1 * align - 500) * base_exp / 500 * gch->level / total_levels;
fight.cpp':        if ((gch->level < LEVEL_HERO && !IS_FORSAKEN(gch) && !IS_DRAGON(gch)) 
fight.cpp':           || !IS_SET(gch->act2, PLR_NOEXP) || (!IS_SET(gch->act, PLR_QUESTING))) 
fight.cpp':          gch->alignment = UMIN (1000, gch->alignment + change);
fight.cpp':          if (gch->alignment < -1000)
fight.cpp':              gch->alignment = -1000;
fight.cpp':        change = gch->alignment * base_exp / 500 * gch->level / total_levels;
fight.cpp':        if ((gch->level < LEVEL_HERO && !IS_DRAGON(gch) && !IS_FORSAKEN(gch))
fight.cpp':           || !IS_SET(gch->act2, PLR_NOEXP) || (!IS_SET(gch->act, PLR_QUESTING))) 
fight.cpp':          gch->alignment -= change;
fight.cpp':    else if (gch->alignment > 500)
fight.cpp':    else if (gch->alignment < -500)
fight.cpp':    else if (gch->alignment > 200)
fight.cpp':    else if (gch->alignment < -200)
fight.cpp':    if (gch->level < 6)
fight.cpp':        xp = 10 * xp / (gch->level + 4);
fight.cpp':    if (gch->level > 35)
fight.cpp':        xp = 15 * xp / (gch->level - 25);
fight.cpp':       modifier = float(gch->level) / ((total_levels - gch->level) / (members - 1));
fight.cpp':      if (gch->pcdata->xpmultiplier.on)
fight.cpp':        if (gch->pcdata->xpmultiplier.factor > 0)
fight.cpp':          xp = xp * gch->pcdata->xpmultiplier.factor;
fight.cpp':        if (gch->pcdata->xpmultiplier.factor < 0)
fight.cpp':          xp = xp / abs(gch->pcdata->xpmultiplier.factor);
fight.cpp':    if (IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)
fight.cpp':    if (ch->position == POS_FIGHTING)
fight.cpp':        || (IS_NPC (ch) && IS_SET (ch->act, ACT_PET)))
fight.cpp':    if (IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)
fight.cpp':    if (ch->position == POS_FIGHTING)
fight.cpp':        sprintf (buf, "Help! I am being attacked by %s!", ch->short_descr);
fight.cpp':        sprintf (buf, "Help!  I am being attacked by %s!", ch->name);
fight.cpp':    if ((victim = ch->fighting) == NULL)
fight.cpp':        if (ch->position == POS_FIGHTING)
fight.cpp':            ch->position = POS_STANDING;
fight.cpp':    was_in = ch->in_room;
fight.cpp':            || number_range (0, ch->daze) != 0 
fight.cpp':        if ((now_in = ch->in_room) == was_in)
fight.cpp':        ch->in_room = was_in;
fight.cpp':        ch->in_room = now_in;
fight.cpp':		  ch->pcdata->damInflicted, ch->pcdata->damReceived);
fight.cpp':	   ch->pcdata->damInflicted = 0;
fight.cpp':	   ch->pcdata->damReceived = 0;
fight.cpp':            SET_BIT(ch->act2, PLR_FLED);  
fight.cpp':            if ((ch->cClass == 2) && (number_percent () < 3 * (ch->level / 2)))
fight.cpp':    if ((mob = ch->fighting) == NULL)
fight.cpp':      &&  (ch->level < skill_table[gsn_engage].skill_level[ch->cClass]))
fight.cpp':  if (ch->fighting == NULL)
fight.cpp':  if (ch->fighting == victim)
fight.cpp':  if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
fight.cpp':  if ((victim->fighting != ch) && (ch->level < 35))
fight.cpp':      if (ch->in_room == victim->in_room)
fight.cpp':                     (IS_NPC (ch) ? ch->short_descr : ch->name),
fight.cpp':		     ch->level,
fight.cpp':                     ch->in_room->vnum);
fight.cpp':	     if (ch->level > 75 &&
fight.cpp':                 (IS_NPC (ch) ? ch->short_descr : ch->name),
fight.cpp':                 ch->in_room->name, ch->in_room->vnum);
fight.cpp':            victim->pcdata->lastKilled = str_dup(ch->name);
fight.cpp':    	  REMOVE_BIT(ch->act, PLR_TAG);
fight.cpp':    	  SET_BIT(ch->act, PLR_IT);
fight.cpp':    	  ch->name);
fight.cpp':         if (ch->in_room == victim->in_room)
fight.cpp':    if (ch->fighting != NULL)
fight.cpp':  if (ch->fighting != NULL)
fight.cpp':  if (ch->hit < (ch->max_hit / 2) && IS_NPC(victim))
fight.cpp':	if (ch->fighting != NULL)
fight.cpp':    if (ch->fighting == victim)
fight.cpp':        victim = ch->fighting;
fight.cpp':        && (ch->level < skill_table[gsn_kick].skill_level[ch->cClass]
fight.cpp':    if (IS_NPC (ch) && !IS_SET (ch->off_flags, OFF_KICK))
fight.cpp':    /*if ((victim = ch->fighting) == NULL)
fight.cpp':    	    dam =number_range (int(1+(ch->level/2.5)), int(ch->level/1.5));
fight.cpp':            dam =number_range (1+(ch->level/3), int(ch->level/1.8));
fight.cpp':    if ((victim = ch->fighting) == NULL)
fight.cpp':        || (IS_NPC (ch) && !IS_SET (ch->off_flags, OFF_BERSERK))
fight.cpp':            && ch->level < skill_table[gsn_berserk].skill_level[ch->cClass]))
fight.cpp':    if (ch->mana < 50)
fight.cpp':            if (ch->position == POS_FIGHTING)
fight.cpp':            chance += 25 - (100 * ch->hit / ch->max_hit) / 2;
fight.cpp':        ch->mana -= 50;
fight.cpp':        ch->move /= 2;
fight.cpp':        ch->hit += ch->level * 2;
fight.cpp':        ch->hit = UMIN (ch->hit, ch->max_hit);
fight.cpp':        af.level = ch->level;
fight.cpp':        af.duration = number_fuzzy (ch->level / 8);
fight.cpp':        af.modifier = UMAX (1, ch->level / 5);
fight.cpp':        af.modifier = UMAX (10, 10 * (ch->level / 5));
fight.cpp':        ch->mana -= 25;
fight.cpp':        ch->move /= 2;
fight.cpp':        || (IS_NPC (ch) && !IS_SET (ch->off_flags, OFF_BASH))
fight.cpp':            && ch->level < skill_table[gsn_bash].skill_level[ch->cClass]))
fight.cpp':        victim = ch->fighting;
fight.cpp':    if (IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)
fight.cpp':        dam =number_range ((ch->level / 2), (ch->level / 2) + 10 * ch->size + number_percent() / 2);
fight.cpp':        ch->position = POS_RESTING;
fight.cpp':        || (IS_NPC (ch) && !IS_SET (ch->off_flags, OFF_KICK_DIRT))
fight.cpp':            && ch->level < skill_table[gsn_dirt].skill_level[ch->cClass]))
fight.cpp':        victim = ch->fighting;
fight.cpp':    if (IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)
fight.cpp':    if (ch->in_room->sector_type == SECT_WATER_SWIM
fight.cpp':      || ch->in_room->sector_type == SECT_WATER_NOSWIM
fight.cpp':      || ch->in_room->sector_type == SECT_AIR)
fight.cpp':        af.level = ch->level;
fight.cpp':            chance += ( victim->level - ch->level );        
fight.cpp':            dt += ch->dam_type;
fight.cpp':    	    dam_type = attack_table[ch->dam_type].damage;
fight.cpp':        || (IS_NPC (ch) && !IS_SET (ch->off_flags, OFF_TRIP))
fight.cpp':            && ch->level < skill_table[gsn_trip].skill_level[ch->cClass]))
fight.cpp':        victim = ch->fighting;
fight.cpp':    if (IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)
fight.cpp':    if (ch->fighting != NULL)
fight.cpp':    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.cpp':	af.level 	= ch->level;
fight.cpp':       sprintf(buf, "%s tried to BJ from %s, but failed.\n\r", ch->name, victim->name);
fight.cpp':        STR_REMOVE_BIT (ch->affected_by, AFF_SNEAK);
fight.cpp':        STR_REMOVE_BIT (ch->affected_by, AFF_HIDE);
fight.cpp':        STR_REMOVE_BIT (ch->affected_by, AFF_SHROUD);
fight.cpp':                ch->name,ch->level,victim->name,victim->level);
fight.cpp':            && ch->level < skill_table[gsn_flip].skill_level[ch->cClass]))
fight.cpp':        victim = ch->fighting;
fight.cpp':    if (IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)
fight.cpp':        damage (ch, victim, number_range ((ch->level / 2), (ch->level / 2) + 10 * ch->size + number_percent() / 2),
fight.cpp':            && ch->level < skill_table[gsn_rub].skill_level[ch->cClass]))
fight.cpp':    if( ch->stunned)
fight.cpp':            && ch->level < skill_table[gsn_dance].skill_level[ch->cClass]))
fight.cpp':  sprintf(buf, "Current dance: %s\n\r",stance_table[ch->pcdata->stance].name);
fight.cpp': ch->pcdata->stance = 0;
fight.cpp': ch->pcdata->stance = 1;
fight.cpp': ch->pcdata->stance = 2;
fight.cpp': ch->pcdata->stance = 3;
fight.cpp': ch->pcdata->stance = 4;
fight.cpp': ch->pcdata->stance = 5;
fight.cpp': ch->pcdata->stance = 6;
guild_skills.cpp:  if (!str_cmp(ch->name, "Rand"))
guild_skills.cpp:  if (ch->rank < 4 && !IS_IMMORTAL(ch))
guild_skills.cpp:  if (ch->clan != victim->clan && !IS_IMMORTAL(ch))
guild_skills.cpp:  if (!str_cmp("warrior", class_table[ch->cClass].name) && 
guild_skills.cpp:     (!str_cmp("formmaster", class_table[ch->cClass].name) && 
guild_skills.cpp:     (!str_cmp("assassin", class_table[ch->cClass].name) && 
guild_skills.cpp:     (!str_cmp("rogue", class_table[ch->cClass].name)))))
guild_skills.cpp:  if (!str_cmp(ch->name, "Rand"))
guild_skills.cpp:  if ( IS_SET (ch->in_room->room_flags, ROOM_SAFE) )
guild_skills.cpp:  if (ch->mana < 50)
guild_skills.cpp:    af.level = ch->level;
guild_skills.cpp:    ch->mana -= 50;
guild_skills.cpp: if (ch->clan != clan_lookup("aiel") && !IS_IMMORTAL(ch) && 
guild_skills.cpp:    (ch->clan != clan_lookup("Shaido")))
guild_skills.cpp:   if ( ch->position != POS_SLEEPING)
guild_skills.cpp:        || (!IS_NPC(victim) && ((IS_IMMORTAL(victim)) && (ch->level < victim->level)))
guild_skills.cpp:        ch->pcdata->dream_to_room = ch->in_room;
guild_skills.cpp:        ch->pcdata->dream = TRUE;
guild_skills.cpp:      ch->pcdata->dream_to_room = victim->in_room;
guild_skills.cpp:      ch->pcdata->dream = TRUE;
guild_skills.cpp:      IS_SET(ch->act, PLR_TOURNEY))
guild_skills.cpp:  char_to_room(ch, ch->pcdata->dream_to_room);
guild_skills.cpp:  ch->pcdata->dream = FALSE;
guild_skills.cpp:  ch->pcdata->dream_to_room = ch->in_room;
guild_skills.cpp:  if (ch->clan != clan_lookup("Seanchan") && !IS_IMMORTAL(ch))
guild_skills.cpp:  if (ch->mana < 50)
guild_skills.cpp:    af.level = ch->level;
guild_skills.cpp:    af.duration = IS_SET(ch->act, PLR_TOURNEY) ? ch->level / 10 : ch->level / 6;  
guild_skills.cpp:    dam = ch->level * (number_percent() / 20) + 10;
guild_skills.cpp:      af.level = ch->level;
guild_skills.cpp:    ch->mana -= 50;
guild_skills.cpp:  if (ch->clan != clan_lookup("Redhand") && !IS_IMMORTAL(ch))
guild_skills.cpp:  if (ch->mana < 50)
guild_skills.cpp:    af.level     = ch->level;
guild_skills.cpp:    af.duration  = ch->level / 6;
guild_skills.cpp:    af.modifier  = ch->level / 6;
guild_skills.cpp:    af.modifier  = -(ch->level / 6);
guild_skills.cpp:    ch->mana -= 50;
guild_skills.cpp:    ch->mana -= 50;
guild_skills.cpp:  if (!str_cmp("channeler", class_table[ch->cClass].name) ||
guild_skills.cpp:      (!str_cmp("cleric", class_table[ch->cClass].name)))
guild_skills.cpp:  if (ch->clan != clan_lookup("ashaman") && !IS_IMMORTAL(ch)&&!IS_DRAGON(ch))
guild_skills.cpp: /* if ((ch->class != 0) && (ch->class != 1))
guild_skills.cpp:  if (ch->fighting)
guild_skills.cpp:    af.level     = ch->level;
guild_skills.cpp:    if (ch->level >= 60)
guild_skills.cpp:    if (ch->level >= 60)
guild_skills.cpp:    ch->mana -= 50;
guild_skills.cpp:    ch->mana -= 50;
guild_skills.cpp:  if (!str_cmp("channeler", class_table[ch->cClass].name) ||
guild_skills.cpp:     (!str_cmp("cleric", class_table[ch->cClass].name)))
guild_skills.cpp:  if (ch->clan != clan_lookup("ashaman") && !IS_IMMORTAL(ch) && !IS_DRAGON(ch))
guild_skills.cpp:  if (!IS_SET(ch->level == LEVEL_HERO))
guild_skills.cpp:  if (ch->fighting)
guild_skills.cpp:    af.level     = ch->level;
guild_skills.cpp:    af.duration = ch->level / 10;    
guild_skills.cpp:    ch->mana -= 30;
guild_skills.cpp:    ch->pcdata->manadrainee = str_dup(victim->name);
guild_skills.cpp:    ch->mana -= 50;
guild_skills.cpp:  if (ch->clan != clan_lookup("ashaman") && !IS_IMMORTAL(ch))
guild_skills.cpp:  if (IS_SET(ch->act, PLR_TOURNEY) && tournament.noguild)
guild_skills.cpp:    af.level     = ch->level;
guild_skills.cpp:    af.duration  = ch->level / 10;
guild_skills.cpp:  if (ch->clan != clan_lookup("ashaman") && !IS_IMMORTAL(ch))
guild_skills.cpp:  for (paf = ch->affected; paf != NULL; paf = paf_next)
guild_skills.cpp:  if (ch->sex != 2)
guild_skills.cpp:  if (ch->clan != clan_lookup("aessedai") && ch->clan != clan_lookup("Rebel") && !IS_IMMORTAL(ch))
guild_skills.cpp:    af.level     = ch->level;
guild_skills.cpp:    if (ch->level >= 60)
guild_skills.cpp:  if (ch->clan != clan_lookup("Gleeman") && !IS_IMMORTAL(ch))
guild_skills.cpp:  if (IS_SET(ch->act, PLR_TOURNEY) && tournament.noguild)
guild_skills.cpp:  if (ch->mana < (ch->max_mana / 40))
guild_skills.cpp:    ch->mana -= ch->max_mana / 40;
guild_skills.cpp:    for (fch = ch->in_room->people; fch != NULL; fch = fch_next)
guild_skills.cpp:      fch_next = fch->next_in_room;
guild_skills.cpp:      result_hit = fch->hit + (fch->max_hit / factor);
guild_skills.cpp:      result_mana = fch->mana + (fch->max_mana / factor);
guild_skills.cpp:      result_move = fch->move + (fch->max_move / factor);
guild_skills.cpp:       if (fch->clan == clan_lookup("furies"))
guild_skills.cpp:        fch->move = fch->move;
guild_skills.cpp:        fch->mana = fch->mana;
guild_skills.cpp:        fch->hit = fch->hit;  
guild_skills.cpp:     if (result_hit > fch->max_hit)
guild_skills.cpp:        fch->hit = fch->max_hit;
guild_skills.cpp:        fch->hit = result_hit;
guild_skills.cpp:      if (result_mana > fch->max_mana)
guild_skills.cpp:        fch->mana = fch->max_mana;
guild_skills.cpp:        fch->mana = result_mana;
guild_skills.cpp:      if (result_move > fch->max_move)
guild_skills.cpp:        fch->move = fch->max_move;
guild_skills.cpp:        fch->move = result_move;
guild_skills.cpp:    af.level     = ch->level;
guild_skills.cpp:    ch->mana -= (ch->max_mana / 40);
guild_skills.cpp:  if (ch->clan != clan_lookup("Gleeman") && !IS_IMMORTAL(ch))
guild_skills.cpp:  dam = ch->level * (number_percent() / 30) + 10;
guild_skills.cpp:    af.level     = ch->level;
guild_skills.cpp:  if (ch->clan != clan_lookup("Gleeman") && !IS_IMMORTAL(ch))
guild_skills.cpp:    af.level     = ch->level;
guild_skills.cpp:    af.duration  = ch->level / 20;
guild_skills.cpp:  if (ch->clan != clan_lookup("whitecloak") && !IS_IMMORTAL(ch))
guild_skills.cpp:  if (IS_SET(ch->act, PLR_TOURNEY) && tournament.noguild)
guild_skills.cpp:  if (ch->mana < 25)
guild_skills.cpp:    af.level     = ch->level;
guild_skills.cpp:    af.duration  = ch->level / 10;
guild_skills.cpp:    ch->mana -= 25;
guild_skills.cpp:    ch->mana -= 25;
guild_skills.cpp:  if (ch->clan != clan_lookup("Whitecloak") && !IS_IMMORTAL(ch))
guild_skills.cpp:      dam = ch->level * (number_percent() / 35);
guild_skills.cpp:      dam = ch->level * (number_percent() / 22);    
guild_skills.cpp:    af.level     = ch->level;
guild_skills.cpp:  chance = ((number_range(1, 100) - (ch->level - 100)) + (get_skill(ch, gsn_cleanse) / 2));
guild_skills.cpp:      if (check_dispel (ch->level, victim, gsn_sanctuary))
guild_skills.cpp:  if (ch->clan != clan_lookup("Shadow") && !IS_IMMORTAL(ch))
guild_skills.cpp:  if (IS_SET(ch->act, PLR_TOURNEY) && tournament.noguild)
guild_skills.cpp:    af.level     = ch->level;
guild_skills.cpp:    af.duration  = ch->level / 10;
guild_skills.cpp:  if (ch->clan != clan_lookup("Shadow") && !IS_IMMORTAL(ch))
guild_skills.cpp:  if ( IS_SET (ch->in_room->room_flags, ROOM_SAFE) )
guild_skills.cpp:  if (IS_SET(ch->act, PLR_TOURNEY) && tournament.noguild)
guild_skills.cpp:  if ((ch->penalty.murder > 0) || ch->penalty.thief > 0)
guild_skills.cpp:  if (ch->pcdata->pk_timer >= 1)
guild_skills.cpp:  	if (ch->move < 100)
guild_skills.cpp:        af.level = ch->level;
guild_skills.cpp:        ch->move = ch->move - 100;
guild_skills.cpp:  if (ch->clan != clan_lookup("Shadow") && !IS_IMMORTAL(ch))
guild_skills.cpp:  if (IS_SET(ch->act, PLR_TOURNEY) && tournament.noguild)
guild_skills.cpp:        af.level = ch->level;
guild_skills.cpp:        af.duration = ch->level;
guild_skills.cpp:  if (ch->clan != clan_lookup("wolfbrother") && !IS_IMMORTAL(ch))
guild_skills.cpp:  if (IS_SET(ch->act, PLR_TOURNEY) && tournament.noguild)
guild_skills.cpp:  for (gch = char_list; gch != NULL; gch = gch->next)
guild_skills.cpp:         if (gch->pIndexData == get_mob_index( MOB_VNUM_GWOLF ))
guild_skills.cpp:    af.level = ch->level;
guild_skills.cpp:     char_to_room( wolf, ch->in_room );
guild_skills.cpp:    wolf->max_hit = int(ch->max_hit * .8);
guild_skills.cpp:    wolf->level = int(ch->level * .8);
guild_skills.cpp:    wolf->hitroll = int(ch->hitroll * .8);
guild_skills.cpp:    wolf->damroll = int(ch->damroll * .8);
guild_skills.cpp:    ch->pet = wolf; 
guild_skills.cpp:  if (ch->clan != clan_lookup("Tinker") && !IS_IMMORTAL(ch))
guild_skills.cpp:    if ((obj = get_obj_list(ch, arg, ch->in_room->contents)) == NULL)
guild_skills.cpp:  chance -= (obj->level - ch->level) / 5;
guild_skills.cpp:  if (str_cmp(victim->pcdata->forsaken_master, ch->name))
guild_skills.cpp:  if (ch->pcdata->isMinion)
guild_skills.cpp:    if (!str_cmp(argument, ch->pcdata->forsaken_master))
guild_skills.cpp:  ch->pcdata->forsaken_master = str_dup(argument);
guild_skills.cpp:         !str_cmp(ch->pcdata->forsaken_master, d->character->name))
guild_skills.cpp:  if (ch->clan != clan_lookup("Shadow") && !IS_IMMORTAL(ch))
guild_skills.cpp:  if (ch->clan != clan_lookup("Furies") && !IS_IMMORTAL(ch))
guild_skills.cpp:  if (!IS_SET(ch->level == LEVEL_HERO))
guild_skills.cpp:    ch->mana -= 10;
guild_skills.cpp:    ch->mana -= 50;
guild_skills.cpp:  clone->act = ch->act;
guild_skills.cpp:  sprintf(buf, "%sDream", ch->name); 
guild_skills.cpp:  sprintf(buf, "%s", ch->name);
guild_skills.cpp:  sprintf(buf, "%s is here.", ch->name);
guild_skills.cpp:  clone->max_hit = ch->max_hit;
guild_skills.cpp:  clone->hit = ch->hit;
guild_skills.cpp:  clone->max_mana = ch->max_mana;
guild_skills.cpp:  clone->mana = ch->mana;
guild_skills.cpp:  clone->max_move = ch->max_move;
guild_skills.cpp:  clone->move = ch->move;
guild_skills.cpp:  clone->level = ch->level;
guild_skills.cpp:  clone->alignment = ch->alignment;
guild_skills.cpp:  clone->sex = ch->sex;
guild_skills.cpp:  clone->cClass = ch->cClass;
guild_skills.cpp:  clone->race = ch->race;
guild_skills.cpp:    clone->perm_stat[i] = ch->perm_stat[i];
guild_skills.cpp:    clone->mod_stat[i] = ch->mod_stat[i];
guild_skills.cpp:  char_to_room(clone, ch->in_room);
guild_skills.cpp:  if (ch->desc->editor != 0)
guild_skills.cpp:  if (ch->desc == NULL)
guild_skills.cpp:  if (ch->desc->original != NULL)
guild_skills.cpp:  sprintf(buf, "%sDream", ch->name); 
guild_skills.cpp:   ch->desc->character = victim;
guild_skills.cpp:   ch->desc->original = ch;
guild_skills.cpp:   victim->desc = ch->desc;
guild_skills.cpp:   ch->desc = NULL;
guild_skills.cpp:   if (ch->prompt != NULL)
guild_skills.cpp:     victim->prompt = str_dup(ch->prompt);
guild_skills.cpp:   victim->comm = ch->comm;
guild_skills.cpp:   victim->lines = ch->lines;
guild_skills.cpp:    if (ch->clan == clan_lookup("tinker") && strcmp(argument, "yes"))
guild_skills.cpp:    if (ch->clan == clan_lookup("Tinker") && !str_cmp(argument, "yes"))
guild_skills.cpp:      ch->max_hit = int(ch->max_hit*.8);
guild_skills.cpp:      ch->max_mana = int(ch->max_mana*.8);
guild_skills.cpp:      ch->pcdata->perm_hit = int(ch->pcdata->perm_hit*.8);
guild_skills.cpp:      ch->pcdata->perm_mana = int(ch->pcdata->perm_mana*.8);
guild_skills.cpp:    if (ch->clan == 0)
guild_skills.cpp:          if (skill_table[sn].name != NULL && ch->pcdata->learned[sn] > 0)
guild_skills.cpp:            if (ch->pcdata->learned[sn] > 30)
guild_skills.cpp:              ch->pcdata->learned[sn] -= 30;
guild_skills.cpp:              ch->pcdata->learned[sn] = 1;
guild_skills.cpp:        for (i = 0 ; i < clan_table[ch->clan].top_gskill; i++)
guild_skills.cpp:          if (clan_table[ch->clan].gskill[i] != NULL)
guild_skills.cpp:           sn = skill_lookup(clan_table[ch->clan].gskill[i]);
guild_skills.cpp:           ch->pcdata->learned[sn] = 0;
guild_skills.cpp:        remove_member(ch->name, ch->clan);
guild_skills.cpp:        ch->clan = 0;
guild_skills.cpp:  if (ch->sex != 2)
guild_skills.cpp:  if (ch->clan != clan_lookup("aessedai"))
guild_skills.cpp:  if (ch->rank == 0)
guild_skills.cpp:  if (ch->rank == 1)
guild_skills.cpp:    send_to_char(ch->pcdata->bond, ch);
guild_skills.cpp:  victim->pcdata->bond = str_dup(ch->name);
guild_skills.cpp:  if (ch->pcdata->bond[0] == '\0')
guild_skills.cpp:    free_string(ch->pcdata->bond);
guild_skills.cpp:    ch->pcdata->bond = str_dup(victim->name);
guild_skills.cpp:    strcat(buf, ch->pcdata->bond);
guild_skills.cpp:    free_string(ch->pcdata->bond); 
guild_skills.cpp:    ch->pcdata->bond = str_dup(buf); 
guild_skills.cpp:  if (IS_NULLSTR(ch->pcdata->bond))
guild_skills.cpp:  if (ch->clan != clan_lookup("aessedai") && ch->clan != clan_lookup("Rebel")  && ch->clan != clan_lookup("warder"))
guild_skills.cpp:  if (ch->clan == clan_lookup("warder") || ch->clan == clan_lookup("aessedai"))
guild_skills.cpp:    if ((victim = get_char_world(ch, ch->pcdata->bond)) == NULL)
guild_skills.cpp:    if (ch->in_room->area == victim->in_room->area)
guild_skills.cpp:  if ((ch->clan == clan_lookup("aessedai") && (ch->sex = 2)) || ch->clan == clan_lookup("Rebel") )
guild_skills.cpp:    bonded = str_dup(ch->pcdata->bond);
guild_skills.cpp:      if (ch->in_room->area == victim->in_room->area)
guild_skills.cpp:  bonded = str_dup(ch->pcdata->bond);
guild_skills.cpp:    damage(ch, victim, (ch->max_hit / 20), 1047, DAM_ENERGY, TRUE, FALSE);
guild_skills.cpp:  if (ch->clan != clan_lookup("seanchan") && !IS_IMMORTAL(ch))
guild_skills.cpp:  if (IS_SET(ch->act, PLR_TOURNEY) && tournament.noguild)
guild_skills.cpp:  for (gch = char_list; gch != NULL; gch = gch->next)
guild_skills.cpp:         if (gch->pIndexData == get_mob_index( MOB_VNUM_DAMANE ))
guild_skills.cpp:    af.level = ch->level + 5;
guild_skills.cpp:     char_to_room( damane, ch->in_room );
guild_skills.cpp:    damane->max_hit = int(ch->max_hit * .9);
guild_skills.cpp:    damane->level = ch->level + 5;
guild_skills.cpp:    damane->hitroll = int(ch->hitroll * .9);
guild_skills.cpp:    damane->damroll = int(ch->damroll * .9);
guild_skills.cpp:    ch->pet = damane; 
guild_skills.cpp:  if (IS_SET(ch->in_room->room_flags, ROOM_INDOORS) &&
guild_skills.cpp:       ch->in_room->vnum != TINKER_SAFE) 
guild_skills.cpp:  if (IS_SET(ch->in_room->room_flags, ROOM_SAFE) && 
guild_skills.cpp:       ch->in_room->vnum != TINKER_SAFE) 
guild_skills.cpp:    obj_to_room(obj, ch->in_room);
guild_skills.cpp:      obj_to_room(obj, ch->in_room);
guild_skills.cpp:  obj = create_object(get_obj_index(STANDARD_FIRE), ch->level);
guild_skills.cpp:  obj_to_room(obj, ch->in_room);
guild_skills.cpp:  if ((obj = get_obj_list(ch, "unlit fire", ch->in_room->contents)) == NULL)
guild_skills.cpp:  obj_to_room(obj, ch->in_room);
guild_skills.cpp:  if (ch->clan != clan_lookup("furie"))
guild_skills.cpp:    ch->simskill = "tinker";
guild_skills.cpp:    ch->simskill = "sedai";
guild_skills.cpp:    ch->simskill = "aiel";
guild_skills.cpp:    ch->simskill = "gleeman";
guild_skills.cpp:    ch->simskill = "shadow";
guild_skills.cpp:    ch->simskill = "redhand";
guild_skills.cpp:    ch->simskill = "sedai";
guild_skills.cpp:    ch->simskill = "wolfbrother";
guild_skills.cpp:    ch->simskill = "seanchan";
guild_skills.cpp:  if (ch->clan != clan_lookup("Wolfbrother") && !IS_IMMORTAL(ch))
guild_skills.cpp:  if (IS_SET(ch->act, PLR_TOURNEY) && tournament.noguild)
guild_skills.cpp:  if (ch->mana < 50)
guild_skills.cpp:    af.level     = ch->level;
guild_skills.cpp:    af.duration  = ch->level / 5;
guild_skills.cpp:    af.modifier  = ch->level / 5;
guild_skills.cpp:    ch->mana -= 50;
guild_skills.cpp:    ch->mana -= 50;
guild_skills.cpp:  if (ch->clan != clan_lookup("Redhand") && !IS_IMMORTAL(ch))
guild_skills.cpp:  if (IS_SET(ch->act, PLR_TOURNEY) && tournament.noguild)
guild_skills.cpp:  if (ch->mana < 50)
guild_skills.cpp:    af.level     = ch->level;
guild_skills.cpp:    af.duration  = ch->level / 6;
guild_skills.cpp:    af.modifier  = ch->level / 6;
guild_skills.cpp:    ch->mana -= 50;
guild_skills.cpp:    ch->mana -= 50;
handler.cpp:  if (IS_AFFECTED(victim, AFF_DIEMCLOAK) && !str_cmp(ch->name, "Asmodeus"))
handler.cpp:    if (ch->clan == clan_lookup("argument"))
handler.cpp:        if (IS_SET (ch->off_flags, ASSIST_PLAYERS))
handler.cpp:    if (IS_SET (ch->off_flags, ASSIST_ALL))
handler.cpp:    if (ch->group && ch->group == victim->group)
handler.cpp:    if (IS_SET (ch->off_flags, ASSIST_VNUM)
handler.cpp:        && ch->pIndexData == victim->pIndexData)
handler.cpp:    if (IS_SET (ch->off_flags, ASSIST_RACE) && ch->race == victim->race)
handler.cpp:    if (IS_SET (ch->off_flags, ASSIST_ALIGN)
handler.cpp:        && !IS_SET (ch->act, ACT_NOALIGN)
handler.cpp:  if ((flag = flag_value(class_flags, class_table[ch->cClass].name)))
handler.cpp:    level = IS_FORSAKEN(ch) ? ch->level + 1 : IS_DRAGON(ch) ? ch->level + 1 : ch->level;
handler.cpp:    for (fch = obj->in_room->people; fch != NULL; fch = fch->next_in_room)
handler.cpp:        if (fch->on == obj)
handler.cpp:	location = ch->in_room;
handler.cpp:	for (CHAR_DATA *wch = location->people; wch; wch = wch->next_in_room)
handler.cpp:			&& wch->position != POS_SLEEPING
handler.cpp:			&& !IS_SET (wch->comm, COMM_AFK)
handler.cpp:			&& wch->timer < 10 && can_see(ch, wch))
handler.cpp:        if (IS_SET (ch->imm_flags, IMM_WEAPON))
handler.cpp:        else if (IS_SET (ch->res_flags, RES_WEAPON))
handler.cpp:        else if (IS_SET (ch->vuln_flags, VULN_WEAPON))
handler.cpp:        if (IS_SET (ch->imm_flags, IMM_MAGIC))
handler.cpp:        else if (IS_SET (ch->res_flags, RES_MAGIC))
handler.cpp:        else if (IS_SET (ch->vuln_flags, VULN_MAGIC))
handler.cpp:    if (IS_SET (ch->imm_flags, bit))
handler.cpp:    else if (IS_SET (ch->res_flags, bit) && immune != IS_IMMUNE)
handler.cpp:    else if (IS_SET (ch->vuln_flags, bit))
handler.cpp:    return ch->clan;
handler.cpp:   return (ch->clan == victim->clan);
handler.cpp:    if (ch->pIndexData == NULL)
handler.cpp:    else if (ch->pIndexData->new_format)
handler.cpp:        skill = ch->level * 5 / 2;
handler.cpp:        if (ch->level < skill_table[sn].skill_level[ch->cClass])
handler.cpp:            skill = ch->pcdata->learned[sn];
handler.cpp:            skill = 40 + 2 * ch->level;
handler.cpp:            skill = ch->level * 2 + 20;
handler.cpp:        else if ((sn == gsn_dodge && IS_SET (ch->off_flags, OFF_DODGE))
handler.cpp:                 || (sn == gsn_parry && IS_SET (ch->off_flags, OFF_PARRY)))
handler.cpp:            skill = ch->level * 2;
handler.cpp:            skill = 10 + 2 * ch->level;
handler.cpp:        else if (sn == gsn_second_attack && (IS_SET (ch->act, ACT_WARRIOR)
handler.cpp:                                             || IS_SET (ch->act, ACT_THIEF)))
handler.cpp:            skill = 10 + 3 * ch->level;
handler.cpp:        else if (sn == gsn_third_attack && IS_SET (ch->act, ACT_WARRIOR))
handler.cpp:            skill = 4 * ch->level - 40;
handler.cpp:            skill = 40 + 2 * ch->level;
handler.cpp:        else if (sn == gsn_trip && IS_SET (ch->off_flags, OFF_TRIP))
handler.cpp:            skill = 10 + 3 * ch->level;
handler.cpp:        else if (sn == gsn_bash && IS_SET (ch->off_flags, OFF_BASH))
handler.cpp:            skill = 10 + 3 * ch->level;
handler.cpp:        else if (sn == gsn_disarm && (IS_SET (ch->off_flags, OFF_DISARM)
handler.cpp:                                      || IS_SET (ch->act, ACT_WARRIOR)
handler.cpp:                                      || IS_SET (ch->act, ACT_THIEF)))
handler.cpp:            skill = 20 + 3 * ch->level;
handler.cpp:        else if (sn == gsn_berserk && IS_SET (ch->off_flags, OFF_BERSERK))
handler.cpp:            skill = 3 * ch->level;
handler.cpp:            skill = 10 + 3 * ch->level;
handler.cpp:        else if (sn == gsn_backstab && IS_SET (ch->act, ACT_THIEF))
handler.cpp:            skill = 20 + 2 * ch->level;
handler.cpp:            skill = 40 + ch->level;
handler.cpp:            skill = 40 + ch->level;
handler.cpp:            skill = 40 + 5 * ch->level / 2;
handler.cpp:    if (ch->daze > 0)
handler.cpp:    if (!IS_NPC (ch) && ch->pcdata->condition[COND_DRUNK] > 10)
handler.cpp:            skill = 3 * ch->level;
handler.cpp:            skill = 40 + 2 * ch->level;
handler.cpp:            skill = 40 + 5 * ch->level / 2;
handler.cpp:            skill = 3 * ch->level;
handler.cpp:            skill = ch->pcdata->learned[sn];
handler.cpp:    if (ch->clan >= top_clan)
handler.cpp:      ch->clan = clan_lookup("Outcast");
handler.cpp:    if (ch->pcdata->perm_hit == 0
handler.cpp:        || ch->pcdata->perm_mana == 0
handler.cpp:        || ch->pcdata->perm_move == 0 || ch->pcdata->last_level == 0)
handler.cpp:                            ch->sex -= mod;
handler.cpp:                            if (ch->sex < 0 || ch->sex > 2)
handler.cpp:                                ch->sex =
handler.cpp:                                    IS_NPC (ch) ? 0 : ch->pcdata->true_sex;
handler.cpp:                            ch->max_mana -= mod;
handler.cpp:                            ch->max_hit -= mod;
handler.cpp:                            ch->max_move -= mod;
handler.cpp:                        ch->sex -= mod;
handler.cpp:                        ch->max_mana -= mod;
handler.cpp:                        ch->max_hit -= mod;
handler.cpp:                        ch->max_move -= mod;
handler.cpp:        ch->pcdata->perm_hit = ch->max_hit;
handler.cpp:        ch->pcdata->perm_mana = ch->max_mana;
handler.cpp:        ch->pcdata->perm_move = ch->max_move;
handler.cpp:        ch->pcdata->last_level = ch->played / 3600;
handler.cpp:        if (ch->pcdata->true_sex < 0 || ch->pcdata->true_sex > 2)
handler.cpp:            if (ch->sex > 0 && ch->sex < 3)
handler.cpp:                ch->pcdata->true_sex = ch->sex;
handler.cpp:                ch->pcdata->true_sex = 0;
handler.cpp:        ch->mod_stat[stat] = 0;
handler.cpp:    if (ch->pcdata->true_sex < 0 || ch->pcdata->true_sex > 2)
handler.cpp:        ch->pcdata->true_sex = 0;
handler.cpp:    ch->sex = ch->pcdata->true_sex;
handler.cpp:    ch->max_hit = ch->pcdata->perm_hit;
handler.cpp:    ch->max_mana = ch->pcdata->perm_mana;
handler.cpp:    ch->max_move = ch->pcdata->perm_move;
handler.cpp:        ch->armor[i] = 100;
handler.cpp:    ch->hitroll = 0;
handler.cpp:    ch->damroll = 0;
handler.cpp:    ch->saving_throw = 0;
handler.cpp:            ch->armor[i] -= apply_ac (obj, loc, i);
handler.cpp:                        ch->mod_stat[STAT_STR] += mod;
handler.cpp:                        ch->mod_stat[STAT_DEX] += mod;
handler.cpp:                        ch->mod_stat[STAT_INT] += mod;
handler.cpp:                        ch->mod_stat[STAT_WIS] += mod;
handler.cpp:                        ch->mod_stat[STAT_CON] += mod;
handler.cpp:                        ch->sex += mod;
handler.cpp:                        ch->max_mana += mod;
handler.cpp:                        ch->max_hit += mod;
handler.cpp:                        ch->max_move += mod;
handler.cpp:                            ch->armor[i] += mod;
handler.cpp:                        ch->hitroll += mod;
handler.cpp:                        ch->damroll += mod;
handler.cpp:                        ch->saving_throw += mod;
handler.cpp:                        ch->saving_throw += mod;
handler.cpp:                        ch->saving_throw += mod;
handler.cpp:                        ch->saving_throw += mod;
handler.cpp:                        ch->saving_throw += mod;
handler.cpp:                        ch->mod_stat[STAT_STR] += mod;
handler.cpp:                        ch->mod_stat[STAT_DEX] += mod;
handler.cpp:                        ch->mod_stat[STAT_INT] += mod;
handler.cpp:                        ch->mod_stat[STAT_WIS] += mod;
handler.cpp:                        ch->mod_stat[STAT_CON] += mod;
handler.cpp:                        ch->sex += mod;
handler.cpp:                        ch->max_mana += mod;
handler.cpp:                        ch->max_hit += mod;
handler.cpp:                        ch->max_move += mod;
handler.cpp:                            ch->armor[i] += mod;
handler.cpp:                        ch->hitroll += mod;
handler.cpp:                        ch->damroll += mod;
handler.cpp:                        ch->saving_throw += mod;
handler.cpp:                        ch->saving_throw += mod;
handler.cpp:                        ch->saving_throw += mod;
handler.cpp:                        ch->saving_throw += mod;
handler.cpp:                        ch->saving_throw += mod;
handler.cpp:                    ch->mod_stat[STAT_STR] += mod;
handler.cpp:                    ch->mod_stat[STAT_DEX] += mod;
handler.cpp:                    ch->mod_stat[STAT_INT] += mod;
handler.cpp:                    ch->mod_stat[STAT_WIS] += mod;
handler.cpp:                    ch->mod_stat[STAT_CON] += mod;
handler.cpp:                    ch->sex += mod;
handler.cpp:                    ch->max_mana += mod;
handler.cpp:                    ch->max_hit += mod;
handler.cpp:                    ch->max_move += mod;
handler.cpp:                        ch->armor[i] += mod;
handler.cpp:                    ch->hitroll += mod;
handler.cpp:                    ch->damroll += mod;
handler.cpp:                    ch->saving_throw += mod;
handler.cpp:                    ch->saving_throw += mod;
handler.cpp:                    ch->saving_throw += mod;
handler.cpp:                    ch->saving_throw += mod;
handler.cpp:                    ch->saving_throw += mod;
handler.cpp:                    ch->mod_stat[STAT_STR] += mod;
handler.cpp:                    ch->mod_stat[STAT_DEX] += mod;
handler.cpp:                    ch->mod_stat[STAT_INT] += mod;
handler.cpp:                    ch->mod_stat[STAT_WIS] += mod;
handler.cpp:                    ch->mod_stat[STAT_CON] += mod;
handler.cpp:                    ch->sex += mod;
handler.cpp:                    ch->max_mana += mod;
handler.cpp:                    ch->max_hit += mod;
handler.cpp:                    ch->max_move += mod;
handler.cpp:                        ch->armor[i] += mod;
handler.cpp:                    ch->hitroll += mod;
handler.cpp:                    ch->damroll += mod;
handler.cpp:                    ch->saving_throw += mod;
handler.cpp:                    ch->saving_throw += mod;
handler.cpp:                    ch->saving_throw += mod;
handler.cpp:                    ch->saving_throw += mod;
handler.cpp:                    ch->saving_throw += mod;
handler.cpp:    for (af = ch->affected; af != NULL; af = af->next)
handler.cpp:                ch->mod_stat[STAT_STR] += mod;
handler.cpp:                ch->mod_stat[STAT_DEX] += mod;
handler.cpp:                ch->mod_stat[STAT_INT] += mod;
handler.cpp:                ch->mod_stat[STAT_WIS] += mod;
handler.cpp:                ch->mod_stat[STAT_CON] += mod;
handler.cpp:                ch->sex += mod;
handler.cpp:                ch->max_mana += mod;
handler.cpp:                ch->max_hit += mod;
handler.cpp:                ch->max_move += mod;
handler.cpp:                    ch->armor[i] += mod;
handler.cpp:                ch->hitroll += mod;
handler.cpp:                ch->damroll += mod;
handler.cpp:                ch->saving_throw += mod;
handler.cpp:                ch->saving_throw += mod;
handler.cpp:                ch->saving_throw += mod;
handler.cpp:                ch->saving_throw += mod;
handler.cpp:                ch->saving_throw += mod;
handler.cpp:                ch->mod_stat[STAT_STR] += mod;
handler.cpp:                ch->mod_stat[STAT_DEX] += mod;
handler.cpp:                ch->mod_stat[STAT_INT] += mod;
handler.cpp:                ch->mod_stat[STAT_WIS] += mod;
handler.cpp:                ch->mod_stat[STAT_CON] += mod;
handler.cpp:                ch->sex += mod;
handler.cpp:                ch->max_mana += mod;
handler.cpp:                ch->max_hit += mod;
handler.cpp:                ch->max_move += mod;
handler.cpp:                    ch->armor[i] += mod;
handler.cpp:                ch->hitroll += mod;
handler.cpp:                ch->damroll += mod;
handler.cpp:                ch->saving_throw += mod;
handler.cpp:                ch->saving_throw += mod;
handler.cpp:                ch->saving_throw += mod;
handler.cpp:                ch->saving_throw += mod;
handler.cpp:                ch->saving_throw += mod;
handler.cpp:    if (ch->clan >= top_clan)
handler.cpp:      ch->clan = clan_lookup("Outcast");
handler.cpp:    if (ch->sex < 0 || ch->sex > 2)
handler.cpp:        ch->sex = ch->pcdata->true_sex;
handler.cpp:      if (ch->pcdata->learned[sn1] > 0 && ch->pcdata->learned[sn2] < 2)
handler.cpp:        ch->pcdata->learned[sn2] = ch->pcdata->learned[sn1];
handler.cpp:        sn1 = ch->pcdata->couple[i].cast;   
handler.cpp:        sn2 = ch->pcdata->couple[i].couple;   
handler.cpp:        if (ch->pcdata->learned[sn1] < 1 || ch->pcdata->learned[sn2] < 1)
handler.cpp:          ch->pcdata->couple[i].cast = 0;   
handler.cpp:          ch->pcdata->couple[i].couple = 0;   
handler.cpp:    if (ch->desc != NULL && ch->desc->original != NULL)
handler.cpp:        ch = ch->desc->original;
handler.cpp:    if (ch->trust)
handler.cpp:        return ch->trust;
handler.cpp:    if (IS_NPC (ch) && ch->level >= LEVEL_HERO)
handler.cpp:        return ch->level;
handler.cpp:    return 17 + (ch->played + (int) (current_time - ch->logon)) / 72000;
handler.cpp:    max = pc_race_table[ch->race].modstats[stat] + class_table[ch->cClass].modstat[stat];
handler.cpp:    return URANGE (3, ch->perm_stat[stat] + ch->mod_stat[stat], max);
handler.cpp:   if (ch->mod_stat[stat] >= 0)    
handler.cpp:     return URANGE (18, ch->perm_stat[stat], max);
handler.cpp:     temp = URANGE (18 + ch->mod_stat[stat], ch->perm_stat[stat] + ch->mod_stat[stat] , max);
handler.cpp:  sum = class_table[ch->cClass].weaves[stat];
handler.cpp:  sum += sex_table[ch->sex].weaves[stat];
handler.cpp:  sum += ch->pcdata->weaves[stat];
handler.cpp:    if (IS_NPC (ch) || ch->level > LEVEL_IMMORTAL)
handler.cpp:    max = pc_race_table[ch->race].max_stats[stat];
handler.cpp:    if (class_table[ch->cClass].attr_prime == stat)
handler.cpp:        if (ch->race == race_lookup ("human"))
handler.cpp:    if (!IS_NPC (ch) && ch->level >= LEVEL_IMMORTAL)
handler.cpp:    if (IS_NPC (ch) && IS_SET (ch->act, ACT_PET))
handler.cpp:    return MAX_WEAR + 2 * get_curr_stat (ch, STAT_DEX) + ch->level;
handler.cpp:    if (!IS_NPC (ch) && ch->level >= LEVEL_IMMORTAL)
handler.cpp:    if (IS_NPC (ch) && IS_SET (ch->act, ACT_PET))
handler.cpp:    return str_app[get_curr_stat (ch, STAT_STR)].carry * 10 + ch->level * 25;
handler.cpp:                STR_SET_BIT (ch->affected_by, paf->bitvector);
handler.cpp:        //        STR_SET_BIT (ch->affected, paf->bitvector);
handler.cpp:                SET_BIT (ch->imm_flags, paf->bitvector);
handler.cpp:                SET_BIT (ch->res_flags, paf->bitvector);
handler.cpp:                SET_BIT (ch->vuln_flags, paf->bitvector);
handler.cpp:                STR_REMOVE_BIT (ch->affected_by, paf->bitvector);
handler.cpp:        //        REMOVE_BIT (ch->simaff, paf->bitvector);
handler.cpp:                REMOVE_BIT (ch->imm_flags, paf->bitvector);
handler.cpp:                REMOVE_BIT (ch->res_flags, paf->bitvector);
handler.cpp:                REMOVE_BIT (ch->vuln_flags, paf->bitvector);
handler.cpp:            ch->mod_stat[STAT_STR] += mod;
handler.cpp:            ch->mod_stat[STAT_DEX] += mod;
handler.cpp:            ch->mod_stat[STAT_INT] += mod;
handler.cpp:            ch->mod_stat[STAT_WIS] += mod;
handler.cpp:            ch->mod_stat[STAT_CON] += mod;
handler.cpp:            ch->sex += mod;
handler.cpp:            ch->max_mana += mod;
handler.cpp:            ch->max_hit += mod;
handler.cpp:            ch->max_move += mod;
handler.cpp:                ch->armor[i] += mod;
handler.cpp:            ch->hitroll += mod;
handler.cpp:            ch->damroll += mod;
handler.cpp:            ch->saving_throw += mod;
handler.cpp:            ch->saving_throw += mod;
handler.cpp:            ch->saving_throw += mod;
handler.cpp:            ch->saving_throw += mod;
handler.cpp:            ch->saving_throw += mod;
handler.cpp:            ch->mod_stat[STAT_STR] += mod;
handler.cpp:            ch->mod_stat[STAT_DEX] += mod;
handler.cpp:            ch->mod_stat[STAT_INT] += mod;
handler.cpp:            ch->mod_stat[STAT_WIS] += mod;
handler.cpp:            ch->mod_stat[STAT_CON] += mod;
handler.cpp:            ch->sex += mod;
handler.cpp:            ch->max_mana += mod;
handler.cpp:            ch->max_hit += mod;
handler.cpp:            ch->max_move += mod;
handler.cpp:                ch->armor[i] += mod;
handler.cpp:            ch->hitroll += mod;
handler.cpp:            ch->damroll += mod;
handler.cpp:            ch->saving_throw += mod;
handler.cpp:            ch->saving_throw += mod;
handler.cpp:            ch->saving_throw += mod;
handler.cpp:            ch->saving_throw += mod;
handler.cpp:            ch->saving_throw += mod;
handler.cpp:            if (!IS_SET(ch->act, PLR_TOURNEY) && !IS_SET(ch->act, PLR_QUESTING))
handler.cpp:              obj_to_room (wield, ch->in_room);
handler.cpp:    for (paf = ch->affected; paf != NULL; paf = paf->next)
handler.cpp:                    STR_SET_BIT (ch->affected_by, vector);
handler.cpp:         //           SET_BIT (ch->simaff, vector);
handler.cpp:                    SET_BIT (ch->imm_flags, vector);
handler.cpp:                    SET_BIT (ch->res_flags, vector);
handler.cpp:                    SET_BIT (ch->vuln_flags, vector);
handler.cpp:    for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
handler.cpp:                        STR_SET_BIT (ch->affected_by, vector);
handler.cpp:          //              SET_BIT (ch->simaff, vector);
handler.cpp:                        SET_BIT (ch->imm_flags, vector);
handler.cpp:                        SET_BIT (ch->res_flags, vector);
handler.cpp:                        SET_BIT (ch->vuln_flags, vector);
handler.cpp:                        STR_SET_BIT (ch->affected_by, vector);
handler.cpp:             //           SET_BIT (ch->simaff, vector);
handler.cpp:                        SET_BIT (ch->imm_flags, vector);
handler.cpp:                        SET_BIT (ch->res_flags, vector);
handler.cpp:                        SET_BIT (ch->vuln_flags, vector);
handler.cpp:    paf_new->next = ch->affected;
handler.cpp:    ch->affected = paf_new;
handler.cpp:  for (paf = ch->affected; paf != NULL; paf = paf_next)
handler.cpp:    af.level = ch->level;
handler.cpp:    paf->next = ch->affected;
handler.cpp:    ch->affected = paf;
handler.cpp:    if (ch->affected == NULL)
handler.cpp:    if (paf == ch->affected)
handler.cpp:        ch->affected = paf->next;
handler.cpp:        for (prev = ch->affected; prev != NULL; prev = prev->next)
handler.cpp:    for (paf = ch->affected; paf != NULL; paf = paf_next)
handler.cpp:    for (paf = ch->affected; paf != NULL; paf = paf_next)
handler.cpp:    for (paf = ch->affected; paf != NULL; paf = paf->next)
handler.cpp:    for (paf_old = ch->affected; paf_old != NULL; paf_old = paf_old->next)
handler.cpp:    if (ch->in_room == NULL)
handler.cpp:        --ch->in_room->area->nplayer;
handler.cpp:        && obj->value[2] != 0 && ch->in_room->light > 0)
handler.cpp:        --ch->in_room->light;
handler.cpp:    if (ch == ch->in_room->people)
handler.cpp:        ch->in_room->people = ch->next_in_room;
handler.cpp:        for (prev = ch->in_room->people; prev; prev = prev->next_in_room)
handler.cpp:                prev->next_in_room = ch->next_in_room;
handler.cpp:    ch->in_room = NULL;
handler.cpp:    ch->next_in_room = NULL;
handler.cpp:    ch->on = NULL;                /* sanity check! */
handler.cpp:    ch->in_room = pRoomIndex;
handler.cpp:    ch->next_in_room = pRoomIndex->people;
handler.cpp:        if (!getbit(ch->pcdata->explored, ch->in_room->vnum))
handler.cpp:          setbit( ch->pcdata->explored, ch->in_room->vnum );
handler.cpp:            update_room(ch->name, count);
handler.cpp:          if (!IS_SET(ch->act2, PLR_NOEXP))
handler.cpp:        if (ch->in_room->area->empty)
handler.cpp:            ch->in_room->area->empty = FALSE;
handler.cpp:            ch->in_room->area->age = 0;
handler.cpp:        ++ch->in_room->area->nplayer;
handler.cpp:        ++ch->in_room->light;
handler.cpp:    for ( obj = ch->in_room->contents; obj != NULL; obj = obj->next_content )
handler.cpp:        for (af = ch->affected; af != NULL; af = af->next)
handler.cpp:            STR_REMOVE_BIT (ch->affected_by, AFF_PLAGUE);
handler.cpp:        for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
handler.cpp:    obj->next_content = ch->carrying;
handler.cpp:    ch->carrying = obj;
handler.cpp:    ch->carry_number += get_obj_number (obj);
handler.cpp:    ch->carry_weight += get_obj_weight (obj);
handler.cpp:    if (ch->carrying == obj)
handler.cpp:        ch->carrying = obj->next_content;
handler.cpp:        for (prev = ch->carrying; prev != NULL; prev = prev->next_content)
handler.cpp:    ch->carry_number -= get_obj_number (obj);
handler.cpp:    ch->carry_weight -= get_obj_weight (obj);
handler.cpp:    for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
handler.cpp:    for (paf = ch->affected; paf != NULL; paf = paf_next)
handler.cpp:		iWear, ch->short_descr, ch->in_room->name);
handler.cpp:        obj_to_room (obj, ch->in_room);
handler.cpp:        ch->armor[i] -= apply_ac (obj, iWear, i);
handler.cpp:        && obj->value[2] != 0 && ch->in_room != NULL) ++ch->in_room->light;
handler.cpp:        ch->armor[i] += apply_ac (obj, obj->wear_loc, i);
handler.cpp:                for (lpaf = ch->affected; lpaf != NULL; lpaf = lpaf_next)
handler.cpp:            for (lpaf = ch->affected; lpaf != NULL; lpaf = lpaf_next)
handler.cpp:        && ch->in_room != NULL
handler.cpp:        && ch->in_room->light > 0) --ch->in_room->light;
handler.cpp:    for (ch = in_room->people; ch != NULL; ch = ch->next_in_room)
handler.cpp:        if (ch->on == obj)
handler.cpp:            ch->on = NULL;
handler.cpp:       if ( ch->in_room == NULL )
handler.cpp:    ch->pet = NULL;                /* just in case */
handler.cpp:    for (obj = ch->carrying; obj != NULL; obj = obj_next)
handler.cpp:    if (ch->in_room != NULL)
handler.cpp:        --ch->pIndexData->count;
handler.cpp:    if (ch->desc != NULL && ch->desc->original != NULL)
handler.cpp:        ch->desc = NULL;
handler.cpp:    for (wch = char_list; wch != NULL; wch = wch->next)
handler.cpp:        if (wch->oreply == ch)
handler.cpp:            wch->oreply = NULL;
handler.cpp:        if (ch->mprog_target == wch)
handler.cpp:            wch->mprog_target = NULL;
handler.cpp:        char_list = ch->next;
handler.cpp:                prev->next = ch->next;
handler.cpp:    if (ch->desc != NULL)
handler.cpp:        ch->desc->character = NULL;
handler.cpp:        rch = ch->in_room->people;
handler.cpp:    for (; rch != NULL; rch = rch->next_in_room)
handler.cpp:            (!IS_NPC(rch) || !is_name(arg, rch->name)) ) &&
handler.cpp:        if (!ch && !is_name( arg, rch->name ) )
handler.cpp:    for (ch = char_list; ch != NULL; ch = ch->next)
handler.cpp:        if (ch->id == id)
handler.cpp:  for ( ach = char_list; ach != NULL ; ach = ach->next )
handler.cpp:      if ( ach->in_room->area != ch->in_room->area
handler.cpp:            && (!IS_NPC(ach) || !is_name(arg, ach->name)) ) )
handler.cpp:  for (wch = char_list; wch != NULL; wch = wch->next)
handler.cpp:      if (ch && (wch->in_room == NULL || !can_see (ch, wch)
handler.cpp:      if (!ch && (wch->in_room == NULL || !is_name(arg, wch->name)))
handler.cpp:    for (wch = char_list; wch != NULL; wch = wch->next)
handler.cpp:       if (ch && (wch->in_room == NULL || !can_see (ch, wch)
handler.cpp:            && (!IS_NPC(wch) || !is_name(arg, wch->name)) ) ))
handler.cpp:      if (!ch && (wch->in_room == NULL || !is_name(arg, wch->name)))
handler.cpp:      if (!is_name(arg, wch->name))
handler.cpp:      if (wch->in_room == NULL || !can_see (ch, wch)
handler.cpp:          || !is_name (arg, wch->name))
handler.cpp:    for (wch = char_list; wch != NULL; wch = wch->next)
handler.cpp:        if (wch->in_room == NULL || !can_see (ch, wch)
handler.cpp:            || !is_name (arg, wch->name))
handler.cpp:    for (wch = char_list; wch != NULL; wch = wch->next)
handler.cpp:        if (!is_name (argument, wch->name))
handler.cpp:    for (wch = char_list; wch != NULL; wch = wch->next)
handler.cpp:        if (!IS_NPC(wch) || wch->pIndexData->vnum != vnum || !can_see(ch, wch))
handler.cpp:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.cpp:    for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
handler.cpp:    for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
handler.cpp:        obj = get_obj_list( ch, argument, ch->in_room->contents );
handler.cpp:    silver = UMIN (ch->silver, cost);
handler.cpp:    ch->gold -= gold;
handler.cpp:    ch->silver -= silver;
handler.cpp:    if (ch->gold < 0)
handler.cpp:        bug ("deduct costs: gold %d < 0", ch->gold);
handler.cpp:        ch->gold = 0;
handler.cpp:    if (ch->silver < 0)
handler.cpp:        bug ("deduct costs: silver %d < 0", ch->silver);
handler.cpp:        ch->silver = 0;
handler.cpp:    return is_name (ch->name, room->owner);
handler.cpp:         rch = rch->next_in_room)
handler.cpp:         && (((ch->level < 76) && !IS_FORSAKEN(ch) && !IS_DRAGON(ch)) || 
handler.cpp:           (ch->pcdata->pk_timer != 0 &&  
handler.cpp:	   !IS_SET(ch->in_room->room_flags, ROOM_HEROES_ONLY))) )
handler.cpp:        && ch->level > 10 && !IS_IMMORTAL (ch) && ch->clan != clan_lookup("Guide"))
handler.cpp:    if (!IS_IMMORTAL (ch) && pRoomIndex->clan && ch->clan != pRoomIndex->clan)
handler.cpp:			(ch->clan != clan_lookup("Aiel") ) )
handler.cpp:			(ch->clan != clan_lookup("Shadow") ) )
handler.cpp:			(ch->clan != clan_lookup("Warder") ) )
handler.cpp:			(ch->clan != clan_lookup("Aessedai") ) )
handler.cpp:			(ch->clan != clan_lookup("Whitecloak") ) )
handler.cpp:			(ch->clan != clan_lookup("Ashaman") ) )
handler.cpp:			(ch->clan != clan_lookup("Shaido") ) )
handler.cpp:  if (ch->clan == clan_lookup("Wolfbrother") && !furies_imm(ch, victim))
handler.cpp:    if (ch->position == POS_MEDITATING)
handler.cpp:  if (ch->clan == clan_lookup("Wolfbrother") && !furies_imm(ch, victim))
handler.cpp:    if (ch->position == POS_MEDITATING)
handler.cpp:  if (ch->clan == victim->clan) /*|| ch->clan == clan_lookup("whitecloak"))*/
handler.cpp:    if (ch->position == POS_MEDITATING)
handler.cpp:      if (!IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT))
handler.cpp:        && ch->in_room != victim->in_room) 
handler.cpp:    if ((!IS_NPC (ch) && IS_SET (ch->act, PLR_HOLYLIGHT))
handler.cpp:    if (IS_SET(ch->act2, PLR_DREAM) 
handler.cpp:    if (!IS_SET(ch->act2, PLR_DREAM) 
handler.cpp:    if (room_is_dark (ch->in_room) && !IS_AFFECTED (ch, AFF_INFRARED))
handler.cpp:        && ch->in_room != victim->in_room) 
handler.cpp:    if ((!IS_NPC (ch) && IS_SET (ch->act, PLR_HOLYLIGHT))
handler.cpp:    if (IS_SET(ch->act2, PLR_DREAM) 
handler.cpp:    if (!IS_SET(ch->act2, PLR_DREAM) 
handler.cpp:    if (room_is_dark (ch->in_room) && !IS_AFFECTED (ch, AFF_INFRARED))
handler.cpp:         ( !IS_AFFECTED(victim, AFF_SHROUD) || ch->clan == victim->clan ) 
handler.cpp:    if (!IS_NPC (ch) && IS_SET (ch->act, PLR_HOLYLIGHT))
handler.cpp:        && (ch->clan != clan_lookup("Wolfbrother")) )
handler.cpp:    if (room_is_dark (ch->in_room) && !IS_AFFECTED (ch, AFF_DARK_VISION))
handler.cpp:    if (!IS_NPC (ch) && ch->level >= LEVEL_IMMORTAL)
handler.cpp:    if (!ch->pcdata)
handler.cpp:    if (IS_NPC (ch) || !ch->pcdata)
handler.cpp:        count += bitcount( ch->pcdata->explored[index] );
handler.cpp:        count += bitcount( ch->pcdata->mobbed[index] );
handler.cpp:    if ( ( ch->in_room == NULL ) ||
handler.cpp:         ( ch->in_room->area == NULL ) )
handler.cpp:    for ( index = ch->in_room->area->min_vnum;
handler.cpp:          index <= ch->in_room->area->max_vnum; index++ )
handler.cpp:        count += getbit( ch->pcdata->explored, index );
handler.cpp:    if ( ( ch->in_room == NULL ) ||
handler.cpp:         ( ch->in_room->area == NULL ) )
handler.cpp:    for ( index = ch->in_room->area->min_vnum;
handler.cpp:          index <= ch->in_room->area->max_vnum; index++ )
handler.cpp:   if (!str_cmp("archer", class_table[ch->cClass].name))
handler.cpp:   if (ch->clan == clan_lookup("Tinker"))
handler.cpp:	ch->hit -= number_range( 1, 100 );
handler.cpp:        ch->mana -= number_range( 1, 100 );
handler.cpp:        ch->move = ch->move * 3 / 4;
healer.cpp:    for (mob = ch->in_room->people; mob; mob = mob->next_in_room)
healer.cpp:    if (!IS_NPC(ch) && ch->clan == 0)
healer.cpp:    else if (!IS_NPC(ch) && IS_SET(ch->act, PLR_TOURNEY))
healer.cpp:    if (cost > (ch->gold * 100 + ch->silver))
healer.cpp:        ch->mana += dice (5, 12) + mob->level / 2;
healer.cpp:        ch->mana = UMIN (ch->mana, ch->max_mana);
hedit.cpp:		had = ch->in_room->area->helps;
hedit.cpp:        	had->filename	= str_dup(ch->in_room->area->file_name);
hedit.cpp:		had->area	= ch->in_room->area;
hedit.cpp:		ch->in_room->area->helps = had;
hedit.cpp:		SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED);
hedit.cpp:	SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED);
hedit.cpp:	ch->desc->pEdit		= (HELP_DATA *) help;
hedit.cpp:	ch->desc->editor	= ED_HELP;
hedit.cpp:    if (ch->pcdata->security < 8)
hedit.cpp:	ch->desc->pEdit		= (void *) pHelp;
hedit.cpp:	ch->desc->editor	= ED_HELP;
hedit.cpp:		if ( ch->in_room->area->helps == NULL )
hedit.cpp:		for ( pHelp = ch->in_room->area->helps->first; pHelp; pHelp = pHelp->next_area )
help.cpp:     sprintf(query_string, "SELECT h.name FROM helps h, help_categories c WHERE (h.catID = c.catID && c.name = '%s' and h.level <= %d)", argument, ch->level);
help.cpp:                        "WHERE (h.catID = c.catID and h.level <= %d and (h.keyword LIKE '%%%s%%' or h.name = '%s'))", ch->level,  arg1, arg1);
help.cpp:     sprintf(query_string, "SELECT h.name FROM helps h, help_categories c WHERE (h.catID = c.catID && c.name = '%s' and h.level <= %d)", argument, ch->level);
help.cpp:                        "WHERE (h.catID = c.catID and h.level <= %d and (h.keyword LIKE '%%%s%%' or h.name = '%s'))", ch->level,  arg1, arg1);
herb.cpp:  charlevel = ch->level;
hunt.cpp:    for ( remember = ch->memory ; remember != NULL ; remember = remember->next )
hunt.cpp:    remember->next = ch->memory;
hunt.cpp:    ch->memory = remember;
hunt.cpp:    if ( ch->memory == NULL )
hunt.cpp:    for ( remember = ch->memory ; remember != NULL ; remember = remember_next )
hunt.cpp:	&&  ch->hunting == NULL
hunt.cpp:    if ( ch->memory == NULL )
hunt.cpp:    for ( remember = ch->memory ; remember != NULL ; remember = remember_next )
hunt.cpp:	&&  ch->hunting == NULL
hunt.cpp:    if ( memory == ch->memory )
hunt.cpp:	ch->memory = memory->next;
hunt.cpp:	for ( prev = ch->memory ; prev != NULL ; prev = prev->next )
hunt.cpp:    if(( ch->in_room == victim->in_room) && ch->level <= 0 )
hunt.cpp:      ch->hunting = victim;
hunt.cpp:    if ( ch->memory == NULL )
hunt.cpp:    for ( remember = ch->memory ; remember != NULL ; remember = remember_next )
hunt.cpp:  if( ch->in_room == victim->in_room )
hunt.cpp:  if( ch->move > 2 )
hunt.cpp:    ch->move -= 3;
hunt.cpp:  direction = find_path( ch->in_room->vnum, victim->in_room->vnum,
hunt.cpp:  if( ( IS_NPC (ch) && number_percent () > ch->pcdata->learned[gsn_track] )    
hunt.cpp:     || (!IS_NPC (ch) && number_percent () > ch->pcdata->learned[gsn_track] ) )
hunt.cpp:      while( ( ch->in_room->exit[direction] == NULL )
hunt.cpp:	    || ( ch->in_room->exit[direction]->u1.to_room == NULL) );
hunt.cpp:   	       (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vo, target);
hunt.cpp:   	       (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vo, target);
hunt.cpp:   	       (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vo, target);
hunt.cpp:  if( ch == NULL || ch->hunting == NULL || !IS_NPC(ch)  )
hunt.cpp:    if( ch->hunting == tmp )
hunt.cpp:  if( !found || !can_see( ch, ch->hunting ) )
hunt.cpp:      mob_remember(ch,ch->hunting,MEM_HOSTILE);
hunt.cpp:      ch->hunting = NULL;
hunt.cpp:  if ((IS_SET (ch->act, ACT_WIMPY) && number_bits (2) == 0)
hunt.cpp:	  || ch->hit < ch->max_hit / 5
hunt.cpp:      || (IS_AFFECTED (ch, AFF_CHARM) && ch->master != NULL
hunt.cpp:      && ch->master->in_room != ch->in_room))
hunt.cpp:	    mob_remember(ch,ch->hunting,MEM_AFRAID);
hunt.cpp:			ch->hunting = NULL;
hunt.cpp:  if( ch->in_room == ch->hunting->in_room )
hunt.cpp:	  ch, NULL, ch->hunting, TO_NOTVICT );
hunt.cpp:	  ch, NULL, ch->hunting, TO_VICT );
hunt.cpp:	  ch, NULL, ch->hunting, TO_CHAR);
hunt.cpp:      multi_hit( ch, ch->hunting, TYPE_UNDEFINED );
hunt.cpp:      //ch->hunting = NULL;
hunt.cpp:  dir = find_path( ch->in_room->vnum, ch->hunting->in_room->vnum,
hunt.cpp:      act( "$n says '`!Damn!  Lost $M`*!'", ch, NULL, ch->hunting, TO_ROOM );
hunt.cpp:      mob_remember(ch,ch->hunting,MEM_HOSTILE);
hunt.cpp:      ch->hunting = NULL;
hunt.cpp:      while( ( ch->in_room->exit[dir] == NULL )
hunt.cpp:	    || ( ch->in_room->exit[dir]->u1.to_room == NULL ) );
hunt.cpp:  if( IS_SET( ch->in_room->exit[dir]->exit_info, EX_CLOSED ) )
hunt.cpp:  if( IS_SET(ch->in_room->exit[dir]->u1.to_room->room_flags, ROOM_SAFE ))
hunt.cpp:  act( "$n looks around for someone with death in his eyes.", ch, NULL, ch->hunting, TO_ROOM );
hunt.cpp:			&& !str_cmp(ch->name, obj->owner))
hunt.cpp:		obj_to_room(find_plrcorpse(ch), get_room_index( ch->in_room->vnum ));	
hunt.cpp:		sprintf(buf, "A bunch of shifty looking labourers wheel a %s upon a cart and drops it at %s's feet!", find_plrcorpse(ch)->short_descr,ch->name);
hunt.cpp:	int getgold = ch->level + (20*ch->level);
hunt.cpp:		if (ch->pcdata->safe_timer > 0)
hunt.cpp:			if(ch->gold_in_bank > getgold)
hunt.cpp:				ch->gold_in_bank -= getgold;
hunt.cpp:			else if (ch->gold_in_bank < getgold 
hunt.cpp:				&& (ch->gold_in_bank + ((ch->silver_in_bank)/convsilver))> getgold)
hunt.cpp:				getgold -= ch->gold_in_bank;
hunt.cpp:				ch->gold_in_bank = 0;
hunt.cpp:				ch->silver_in_bank -= getgold*convsilver;
hunt.cpp:		if (ch->pcdata->safe_timer > 0)
interp.cpp:    if (IS_SET(ch->comm, COMM_AFK) && str_cmp(ch->name, "Plaid") && !IS_IMMORTAL(ch))
interp.cpp:       REMOVE_BIT(ch->comm, COMM_AFK);
interp.cpp:    REMOVE_BIT (ch->affected_by, AFF_HIDE);
interp.cpp:    if (!IS_NPC (ch) && IS_SET (ch->act, PLR_FREEZE))
interp.cpp:        IS_NPC(ch) ? ch->pIndexData->vnum : 0,
interp.cpp:        IS_NPC(ch) ? ch->short_descr : IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name,       
interp.cpp:        ch->in_room ? ch->in_room->vnum : 0,
interp.cpp:        ch->in_room ? ch->in_room->name : "(not in a room)",
interp.cpp:            (!IS_SWITCHED(ch) && !IS_NPC(ch) && strstr(ch->pcdata->granted, cmd_table[cmd].name)) ))
interp.cpp:    if ((!IS_NPC (ch) && IS_SET (ch->act, PLR_LOG))
interp.cpp:        sprintf (log_buf, "Log %s: %s", ch->name, logline);
interp.cpp:    if (ch->desc != NULL && ch->desc->snoop_by != NULL)
interp.cpp:        write_to_buffer (ch->desc->snoop_by, "% ", 2);
interp.cpp:        write_to_buffer (ch->desc->snoop_by, logline, 0);
interp.cpp:        write_to_buffer (ch->desc->snoop_by, "\n\r", 2);
interp.cpp:    if (ch->position < cmd_table[cmd].position)
interp.cpp:        switch (ch->position)
interp.cpp:        IS_NPC(ch) ? ch->pIndexData->vnum : 0,
interp.cpp:        IS_NPC(ch) ? ch->short_descr : IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name,       
interp.cpp:        ch->in_room ? ch->in_room->vnum : 0,
interp.cpp:        ch->in_room ? ch->in_room->name : "(not in a room)",
interp.cpp:	"Memcheck : Increase in strings :: %s : %s", ch->name, cmd_copy) ;
interp.cpp:	"Increase in perms :: %s : %s", ch->name, cmd_copy) ;
interp.cpp:    if (!IS_NPC (ch) && IS_SET (ch->comm, COMM_NOEMOTE))
interp.cpp:      switch (ch->position)
ispell.cpp:    str = *ch->desc->pString;
kyt.cpp:    if( IS_SET( ch->act, PLR_HOLYLIGHT ) )
kyt.cpp:    was_in_room = ch->in_room;
kyt.cpp:	if( ( pexit = ch->in_room->exit[door] ) != NULL
kyt.cpp:	    ch->in_room = pexit->u1.to_room;
kyt.cpp:	    list = ch->in_room->people;
kyt.cpp:	    for( rch = list; rch != NULL; rch = rch->next_in_room )
kyt.cpp:    ch->in_room = was_in_room;
kyt.cpp:    	    if ( ( pexit   = ch->in_room->exit[dir] ) == NULL
kyt.cpp:    	if ( ( pexit   = ch->in_room->exit[dir] ) == NULL
kyt.cpp:	    if ( p->clan == ch->clan )
kyt.cpp:	    sprintf( buf, "%s waves the white flag!", clan_table[ ch->clan ].display );
kyt.cpp:    	sprintf( buf, "War ended by %s!", ch->name );
kyt.cpp:    if ( i == ch->clan )
kyt.cpp:    if ( at_war( ch->clan ) )
kyt.cpp:    p->clan	= ch->clan;
kyt.cpp:    	p->enemy	= ch->clan;
kyt.cpp:	clan_table[ ch->clan ].display,
kyt.h:#define IS_CLAN( ch, ck_clan ) ( ch->clan == clan_lookup( ck_clan ) )
lookup.cpp:    if (ch->penalty.murder > 0)
lookup.cpp:  if (ch->penalty.jail > 0)
lookup.cpp:    if (ch->penalty.thief > 0)
lookup.cpp:    if (ch->clan != 0)
lookup.cpp:    if (ch->rank >= (clan_table[ch->clan].top_rank-2) || IS_SET(ch->act2, PLR_GUILDLEADER))
lookup.cpp:  if (!str_cmp(class_table[ch->cClass].name, "forsaken"))
lookup.cpp:  if (!str_cmp(class_table[ch->cClass].name, "dragon"))
lookup.cpp:         class_table[ch->cClass].hp_max; /* Max Gain */
lookup.cpp:  temp *= ch->level;  /* Multiply times level */ 
lookup.cpp:  temp += class_table[ch->cClass].mana_max;
lookup.cpp:  //if (!class_table[ch->cClass].fMana)
lookup.cpp:  temp *= ch->level;
magic2.cpp:        || (IS_SET (ch->in_room->room_flags, ROOM_NOPORT_FROM))
magic2.cpp:        || (IS_SET (ch->in_room->area->area_flags, AREA_NO_PORT_FROM))
magic2.cpp:        || (!IS_NPC(victim) && ((IS_IMMORTAL(victim)) && (ch->level < victim->level))))
magic2.cpp:    	if ((IS_SET (victim->in_room->room_flags, ROOM_PRIVATE) && (victim->pcdata->pk_timer == 0|| ch->pcdata->pk_timer == 0))
magic2.cpp:        || (IS_SET (victim->in_room->room_flags, ROOM_SOLITARY) && (victim->pcdata->pk_timer == 0|| ch->pcdata->pk_timer == 0))
magic2.cpp:        || (IS_AFFECTED(ch, AFF_DOME) && (victim->pcdata->pk_timer == 0 || ch->pcdata->pk_timer == 0))
magic2.cpp:        || (IS_SET(victim->in_room->room_flags, ROOM_NOPORT)&& (victim->pcdata->pk_timer == 0 || ch->pcdata->pk_timer == 0))
magic2.cpp:    obj_to_room (portal, ch->in_room);
magic2.cpp:    from_room = ch->in_room;
magic2.cpp:        || (IS_SET (ch->in_room->room_flags, ROOM_NOPORT_FROM))
magic2.cpp:        || (IS_SET (ch->in_room->area->area_flags, AREA_NO_PORT_FROM))
magic2.cpp:        || (!IS_NPC(victim) && ((IS_IMMORTAL(victim)) && (ch->level < victim->level)))  
magic2.cpp:  if (ch->fighting!=NULL)
magic.cpp:            if (ch->level >= skill_table[sn].skill_level[ch->cClass]
magic.cpp:                && ch->pcdata->learned[sn] > 0)
magic.cpp:    if (!IS_SET(ch->act2, PLR_NOWEAVE))
magic.cpp:    for (rch = ch->in_room->people; rch; rch = rch->next_in_room)
magic.cpp:        if (ch->sex == rch->sex || IS_IMMORTAL(rch))
magic.cpp:	     ch->cClass == rch->cClass ? skill_table[sn].name : 
magic.cpp:          if (!IS_SET(rch->act2, PLR_NOWEAVE))
magic.cpp:          if (!IS_SET(rch->act2, PLR_NOWEAVE))
magic.cpp:  iReturn = ch->level + (iSum - 10);
magic.cpp:    if (ch->level + 2 == level)
magic.cpp:    return UMAX (min_mana, (100 / (2 + ch->level - level)));
magic.cpp:    if (IS_NPC (ch) && ch->desc == NULL)
magic.cpp:                                                       && (ch->level <
magic.cpp:                                                           [ch->cClass]
magic.cpp:                                                           || ch->
magic.cpp:    if ( (IS_SET(ch->in_room->room_flags, ROOM_NOMAGIC) || IS_SET(ch->in_room->area->area_flags, AREA_NO_MAGIC)) && (ch->pcdata->pk_timer == 0) && !IS_IMMORTAL(ch) )
magic.cpp:    	if (ch->position < skill_table[sn].minimum_position)
magic.cpp:    if (ch->level + 2 == skill_table[sn].skill_level[ch->cClass])
magic.cpp:    	if (ch->cClass==0)
magic.cpp:                     100 / (2 + ch->level -
magic.cpp:                            skill_table[sn].skill_level[ch->cClass]));
magic.cpp:                if ((victim = ch->fighting) == NULL)
magic.cpp:            if (IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)
magic.cpp:                    ch->pcdata->pk_timer = 120;
magic.cpp:                    ch->pcdata->safe_timer = 0;
magic.cpp:              if (ch->clan == (clan_lookup("Tinker") && !IS_SET(ch->act2, PLR_TOURNEY)) && victim->pcdata->pk_timer >= 1 && victim != ch)
magic.cpp:            if (arg2[0] != '\0' && !is_name (target_name, ch->name))
magic.cpp:                if ((victim = ch->fighting) == NULL)
magic.cpp:                    ch->pcdata->pk_timer = 120;
magic.cpp:                    ch->pcdata->safe_timer = 0;
magic.cpp:                if (IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)
magic.cpp:                if (ch->clan == (clan_lookup("Tinker")) && victim->pcdata->pk_timer >= 1 && victim != ch)
magic.cpp:    if (!IS_NPC (ch) && ch->mana < mana)
magic.cpp:        ch->mana -= mana / 2;
magic.cpp:            if ((temp = get_char_room (ch, NULL, ch->pcdata->manadrainee)) != NULL &&
magic.cpp:            for (wch = ch->in_room->people ; wch != NULL ; wch = wch->next_in_room)
magic.cpp:        ch->mana -= mana;
magic.cpp:            || ((class_table[ch->cClass].fMana==FMANA_CHANNEL) 
magic.cpp:            ||class_table[ch->cClass].fMana==FMANA_BOTH))
magic.cpp:        if (!IS_NPC(ch) && ch->clan == clan_lookup("rebel") && ch->clan == clan_lookup("sedai"))
magic.cpp:        for (vch = ch->in_room->people; vch; vch = vch_next)
magic.cpp:            vch_next = vch->next_in_room;
magic.cpp:	if ( IS_SET(ch->in_room->room_flags, ROOM_NOMAGIC) || IS_SET(ch->in_room->area->area_flags, AREA_NO_MAGIC))
magic.cpp:	if (IS_NPC(ch) || ch->pcdata->pk_timer == 0)
magic.cpp:                victim = ch->fighting;
magic.cpp:                if (ch->fighting != NULL)
magic.cpp:                    victim = ch->fighting;
magic.cpp:        for (vch = ch->in_room->people; vch; vch = vch_next)
magic.cpp:            vch_next = vch->next_in_room;
magic.cpp:    af.duration = 24 + ch->level/5;
magic.cpp:    if (ch->level != MAX_LEVEL - 5)
magic.cpp:            ch->saving_throw -= 1;
magic.cpp:    if (str_cmp(ch->name, "Demiscus"))
magic.cpp:            ch->saving_throw -= 1;
magic.cpp:        vch_next = vch->next;
magic.cpp:        if (vch->in_room == NULL)
magic.cpp:        if (vch->in_room == ch->in_room)
magic.cpp:        if (vch->in_room->area == ch->in_room->area && IS_OUTSIDE (vch)
magic.cpp:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
magic.cpp:        if (vch->position == POS_FIGHTING)
magic.cpp:                mlevel += vch->level;
magic.cpp:                mlevel += vch->level / 2;
magic.cpp:            high_level = UMAX (high_level, vch->level);
magic.cpp:        for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
magic.cpp:            if (IS_NPC (vch) && (IS_SET (vch->imm_flags, IMM_MAGIC) ||
magic.cpp:                                 IS_SET (vch->act, ACT_UNDEAD)) || is_safe_spell(ch, vch, TRUE))
magic.cpp:            if (vch->fighting || vch->position == POS_FIGHTING)
magic.cpp:	if ( IS_NPC(vch) && vch->hunting != NULL )
magic.cpp:		vch->hunting = NULL;	
magic.cpp://	if (IS_NPC(vch) && vch->memory != NULL )
magic.cpp:         !(IS_AFFECTED (ch, AFF_CHARM) && ch->master == victim)) ||
magic.cpp:      (ch->pcdata->pk_timer > 0 || victim->pcdata->pk_timer > 0))
magic.cpp:        for (tmp_vict = ch->in_room->people;
magic.cpp:    if (count_charmed(ch) >= ch->level / 12)
magic.cpp:    obj_to_room (light, ch->in_room);
magic.cpp:    obj_to_room (mushroom, ch->in_room);
magic.cpp:    obj_to_room (spring, ch->in_room);
magic.cpp:            ch->saving_throw += 1;
magic.cpp:    if ((ch->level < LEVEL_HERO && !IS_DRAGON(ch) && !IS_FORSAKEN(ch)
magic.cpp:        || !IS_SET(ch->act2, PLR_NOEXP)) && !IS_SET(ch->act, PLR_QUESTING))
magic.cpp:      ch->alignment = UMAX (-1000, ch->alignment - 50);
magic.cpp:    if (victim->hit > (ch->level * 4))
magic.cpp:    if (victim->hit > (ch->level * 4))
magic.cpp:    if (saves_spell (int(ch->level * 1.2), victim, DAM_OTHER))
magic.cpp:        vch_next = vch->next;
magic.cpp:        if (vch->in_room == NULL)
magic.cpp:        if (vch->in_room == ch->in_room)
magic.cpp:        if (vch->in_room->area == ch->in_room->area)
magic.cpp:           ((ch->level < LEVEL_HERO && !IS_DRAGON(ch) && !IS_FORSAKEN(ch))
magic.cpp:            || !IS_SET(ch->act2, PLR_NOEXP)))
magic.cpp:       ch->alignment = UMAX (-1000, ch->alignment - 50);
magic.cpp:        dam = ch->hit + 1;
magic.cpp:        ch->hit += dam;
magic.cpp:    for (tmp_vict = ch->in_room->people;tmp_vict != NULL; tmp_vict = next_vict)
magic.cpp:                ch->mana = ch->mana - 20;           
magic.cpp:    for (ich = ch->in_room->people; ich != NULL; ich = ich->next_in_room)
magic.cpp:        if (ich->invis_level > 0)
magic.cpp:        STR_REMOVE_BIT (ich->affected_by, AFF_HIDE);
magic.cpp:        STR_REMOVE_BIT (ich->affected_by, AFF_INVISIBLE);
magic.cpp:        STR_REMOVE_BIT (ich->affected_by, AFF_SNEAK);
magic.cpp:    disc->value[0] = ch->level * 10;    /* 10 pounds per level capacity */
magic.cpp:    disc->value[3] = ch->level * 5;    /* 5 pounds per level max per item */
magic.cpp:    disc->timer = ch->level * 2 - number_range (0, level / 2);
magic.cpp:        || IS_SET (ch->in_room->room_flags, ROOM_NO_RECALL)
magic.cpp:        || IS_SET (ch->in_room->area->area_flags, AREA_NO_SUMMON_FROM)
magic.cpp:    if (ch->pet != NULL && ch->in_room == ch->pet->in_room)
magic.cpp:        act ("$n steps through a gate and vanishes.", ch->pet, NULL, NULL,
magic.cpp:        send_to_char ("You step through a gate and vanish.\n\r", ch->pet);
magic.cpp:        char_from_room (ch->pet);
magic.cpp:        char_to_room (ch->pet, victim->in_room);
magic.cpp:        act ("$n has arrived through a gate.", ch->pet, NULL, NULL, TO_ROOM);
magic.cpp:        do_function (ch->pet, &do_look, "auto");
magic.cpp:    for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
magic.cpp:        vch_next = vch->next_in_room;
magic.cpp:    ch->move = 0;
magic.cpp:    ch->hit /= 2;
magic.cpp:        chlevel = IS_HERO(ch) ? 110 : ch->level;
magic.cpp:    flush = ch->level / 7;
magic.cpp:    for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room)
magic.cpp:			if (!IS_NPC(ch) && ch->pcdata->condition[COND_BLEEDING] == 1 )
magic.cpp:    for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room)
magic.cpp:    if (!IS_NPC(ch) && ch->pcdata->pk_timer > 0)
magic.cpp:    ch->hit = UMIN (ch->hit + heal, ch->max_hit);
magic.cpp:    if ((ch->level < LEVEL_HERO && !IS_DRAGON(ch) && !IS_FORSAKEN(ch)
magic.cpp:         || !IS_SET(ch->act2, PLR_NOEXP)) && !IS_SET(ch->act, PLR_QUESTING)) 
magic.cpp:      ch->alignment = UMAX (-1000, ch->alignment - 25);
magic.cpp:        || IS_SET (ch->in_room->room_flags, ROOM_NO_MOB)
magic.cpp:    char_to_room (victim, ch->in_room);
magic.cpp:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
magic.cpp:        if (!is_exact_name (speaker, vch->name) && IS_AWAKE (vch))
magic.cpp:    if (ch->pcdata->pk_timer > 0)
magic.cpp:    ch->move /= 2;
magic.cpp:if ((IS_SET(ch->act, PLR_TOURNEY)) || (IS_SET(ch->act, PLR_TAG)) ||  IS_SET(ch->act, PLR_IT))
magic.cpp:    hpch = URANGE (12, ch->hit, 4000);
magic.cpp:    dam = hp_dam + dice_dam + (ch->level / 5) - 20;
magic.cpp:    hpch = URANGE (12, ch->hit, 4000);
magic.cpp:    dam = hp_dam + dice_dam + (ch->level / 2 ) -15;
magic.cpp:    hpch = URANGE (12, ch->hit, 4000);
magic.cpp:    dam = hp_dam + dice_dam + (ch->level / 2) - 15;
magic.cpp:    hpch = URANGE (12, ch->hit, 4000);
magic.cpp:    dam = hp_dam + dice_dam + (ch->level / 2) - 15;
magic.cpp:  //  poison_effect (ch->in_room, level, dam, TARGET_ROOM);
magic.cpp:    for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
magic.cpp:        vch_next = vch->next_in_room;
magic.cpp:                && (ch->fighting == vch || vch->fighting == ch)))
magic.cpp:    hpch = URANGE (12, ch->hit, 4000);
magic.cpp:    dam = hp_dam + dice_dam + (ch->level / 2) - 15;
magic.cpp:    ch->interdimension = number_range(get_curr_stat (ch, STAT_WIS)/8, get_curr_stat(ch, STAT_WIS)/4);
magic.cpp:    life = ch->hit / 2;
magic.cpp:    ch->hit /= 2;
magic.cpp:    if (ch->hit > ch->max_hit/3)
magic.cpp:	ch->mana += number_range(100,200);
mark.cpp:    if (ch->clan == clan_lookup("Furies"))
mark.cpp:    if (!str_cmp(mark->contractor,ch->name))
mark.cpp:    	mark->contractor = ch->name;
mark.cpp:    	ch->desc->editor = ED_MARK;
mark.cpp:    	ch->desc->pEdit = mark;
mark.cpp:    	ch->desc->editor = ED_MARK;
mark.cpp:    	ch->desc->pEdit = mark;
mark.cpp:    	ch->desc->editor = ED_NONE;
mccp.cpp:    if (!ch->desc) {
mccp.cpp:    if (!ch->desc->out_compress) {
mccp.cpp:        if (!compressStart(ch->desc)) {
mccp.cpp:            ch->pcdata->compressed = FALSE;
mccp.cpp:        ch->pcdata->compressed = TRUE;
mccp.cpp:        if (!compressEnd(ch->desc)) {
mccp.cpp:            ch->pcdata->compressed = FALSE;
mccp.cpp:        ch->pcdata->compressed = FALSE;
merc.h:                    ch->pcdata->type[0] = NORMAL;        \
merc.h:                    ch->pcdata->type[1] = RED;            \
merc.h:                    ch->pcdata->type[0] = BRIGHT;        \
merc.h:                    ch->pcdata->type[1] = RED;            \
merc.h:                    ch->pcdata->type[0] = NORMAL;        \
merc.h:                    ch->pcdata->type[1] = GREEN;        \
merc.h:                    ch->pcdata->type[0] = BRIGHT;        \
merc.h:                    ch->pcdata->type[1] = GREEN;        \
merc.h:                    ch->pcdata->type[0] = NORMAL;        \
merc.h:                    ch->pcdata->type[1] = YELLOW;        \
merc.h:                    ch->pcdata->type[0] = BRIGHT;        \
merc.h:                    ch->pcdata->type[1] = YELLOW;        \
merc.h:                    ch->pcdata->type[0] = NORMAL;        \
merc.h:                    ch->pcdata->type[1] = BLUE;        \
merc.h:                    ch->pcdata->type[0] = BRIGHT;        \
merc.h:                    ch->pcdata->type[1] = BLUE;        \
merc.h:                    ch->pcdata->type[0] = NORMAL;        \
merc.h:                    ch->pcdata->type[1] = MAGENTA;        \
merc.h:                    ch->pcdata->type[0] = BRIGHT;        \
merc.h:                    ch->pcdata->type[1] = MAGENTA;        \
merc.h:                    ch->pcdata->type[0] = NORMAL;        \
merc.h:                    ch->pcdata->type[1] = CYAN;            \
merc.h:                    ch->pcdata->type[0] = BRIGHT;        \
merc.h:                    ch->pcdata->type[1] = CYAN;            \
merc.h:                    ch->pcdata->type[0] = NORMAL;        \
merc.h:                    ch->pcdata->type[1] = WHITE;        \
merc.h:                    ch->pcdata->type[0] = BRIGHT;        \
merc.h:                    ch->pcdata->type[1] = WHITE;        \
merc.h:                    ch->pcdata->type[0] = BRIGHT;        \
merc.h:                    ch->pcdata->type[1] = BLACK;        \
merc.h:                    ch->pcdata->type[2] = 1;            \
merc.h:                    ch->pcdata->type[2] = 0;            \
merc.h:#define SHOW_DF(ch, victim)   ( victim->pcdata->isMinion && (ch->level == MAX_LEVEL || IS_FORSAKEN(ch) \
merc.h:#define IS_MINION(ch) (!IS_NPC(ch) && ch->pcdata->isMinion)
merc.h:#define SEE_TAG(ch, wch) ( IS_IMMORTAL(ch) || ch->clan == clan_lookup("Guide") || wch->clan == clan_lookup("Guide") || wch->clan == clan_lookup("furies") )
merc.h:#define IS_TINKER(ch)      ch->clan == clan_lookup("Tinker")
merc.h:#define IS_GOOD(ch)        (ch->alignment >= 350)
merc.h:#define IS_EVIL(ch)        (ch->alignment <= -350)
merc.h:#define IS_AWAKE(ch)        (ch->position > POS_SLEEPING)
merc.h:#define IS_SWITCHED( ch )       ( ch->desc && ch->desc->original )
merc.h:                ( ch->pcdata->security >= Area->security  \
merc.h:                || strstr( Area->builders, ch->name )      \
merc.h:#define IS_MOUNTED(ch)     (ch->is_mounted) 
mkwSys.cpp:	if ( format != NULL && format[0] && ch->desc != NULL )
mkwSys.cpp:		write_to_buffer( ch->desc, buf, nChars );
mob_cmds.cpp:    if ( ch->desc != NULL && get_trust(ch) < MAX_LEVEL )
mob_cmds.cpp:	IS_NPC(ch) ? ch->pIndexData->vnum : 0, command );
mob_cmds.cpp:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:      if (list->ch_id == ch->id)
mob_cmds.cpp:     list->ch_id = ch->id;
mob_cmds.cpp:    if (list->ch_id == ch->id)
mob_cmds.cpp:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:    if ( ch->in_room == NULL )
mob_cmds.cpp:	&&   d->character->in_room->area == ch->in_room->area )
mob_cmds.cpp:    was_in_room = ch->in_room;
mob_cmds.cpp:	    ch->in_room = pexit->u1.to_room;
mob_cmds.cpp:    ch->in_room = was_in_room;
mob_cmds.cpp:    if ( victim == ch || IS_NPC(victim) || ch->position == POS_FIGHTING )
mob_cmds.cpp:    if ( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
mob_cmds.cpp:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:    if ( victim == ch || ch->fighting != NULL || victim->fighting == NULL )
mob_cmds.cpp:      	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
mob_cmds.cpp:    if ( ch->in_room == NULL || arg[0] == '\0' || !is_number(arg) )
mob_cmds.cpp:	    vnum, IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:    char_to_room( victim, ch->in_room );
mob_cmds.cpp:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:	obj_to_room( obj, ch->in_room );
mob_cmds.cpp:	    IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:	obj_to_room( obj, ch->in_room );
mob_cmds.cpp:	for ( victim = ch->in_room->people; victim != NULL; victim = vnext )
mob_cmds.cpp:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:    if ( ch->fighting != NULL )
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:    original = ch->in_room;
mob_cmds.cpp:    on = ch->on;
mob_cmds.cpp:    for ( wch = char_list; wch != NULL; wch = wch->next )
mob_cmds.cpp:	    ch->on = on;
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:	for ( victim = ch->in_room->people; victim != NULL; victim = victim_next )
mob_cmds.cpp:	location = ch->in_room;
mob_cmds.cpp:	        IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:    for ( victim = ch->in_room->people; victim; victim = victim_next )
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:	    vch_next = vch->next;
mob_cmds.cpp:	    if ( vch->in_room == ch->in_room
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:	vch_next = vch->next_in_room;
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:    (*skill_table[sn].spell_fun)( sn, ch->level, ch, victim,
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:	for( victim = ch->in_room->people; victim; victim = victim_next )
mob_cmds.cpp:	ch->mprog_target = get_char_world( ch, arg );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:    ch->mprog_target = NULL;
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:    //ch->mprog_delay = atoi( arg );
mob_cmds.cpp:  // ch->mprog_delay = -1;
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:    if ( ch->fighting != NULL )
mob_cmds.cpp:    if ( (was_in = ch->in_room) == NULL )
mob_cmds.cpp:        if ( ch->in_room != was_in )
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:		IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
mob_cmds.cpp:    for ( ; vch; vch = vch->next_in_room )
mob_cmds.cpp:	    vch_next = vch->next;
mob_cmds.cpp:	    if ( ((obj->in_room && vch->in_room == obj->in_room)
mob_cmds.cpp:		|| (obj->carried_by && vch->in_room == obj->carried_by->in_room))
mob_cmds.cpp:	vch_next = vch->next_in_room;
mob_cmds.cpp:	    level = ch->level + atoi( arg1 );
mob_cmds.cpp:	    level = ch->level - atoi( arg1 );
mob_cmds.cpp:	    level = ch->level * atoi( arg1 );
mob_cmds.cpp:	    level = ch->level / atoi( arg1 );
mob_cmds.cpp:	    condition = ch->level + atoi( arg2 );
mob_cmds.cpp:	    condition = ch->level - atoi( arg2 );
mob_cmds.cpp:	    condition = ch->level * atoi( arg2 );
mob_cmds.cpp:	    condition = ch->level / atoi( arg2 );
mob_cmds.cpp:	    value0 = ch->level + atoi( arg3 );
mob_cmds.cpp:	    value0 = ch->level - atoi( arg3 );
mob_cmds.cpp:	    value0 = ch->level * atoi( arg3 );
mob_cmds.cpp:	    value0 = ch->level / atoi( arg3 );
mob_cmds.cpp:	    value1 = ch->level + atoi( arg4 );
mob_cmds.cpp:	    value1 = ch->level - atoi( arg4 );
mob_cmds.cpp:	    value1 = ch->level * atoi( arg4 );
mob_cmds.cpp:	    value1 = ch->level / atoi( arg4 );
mob_cmds.cpp:	    value2 = ch->level + atoi( arg5 );
mob_cmds.cpp:	    value2 = ch->level - atoi( arg5 );
mob_cmds.cpp:	    value2 = ch->level * atoi( arg5 );
mob_cmds.cpp:	    value2 = ch->level / atoi( arg5 );
mob_cmds.cpp:	    value3 = ch->level + atoi( arg6 );
mob_cmds.cpp:	    value3 = ch->level - atoi( arg6 );
mob_cmds.cpp:	    value3 = ch->level * atoi( arg6 );
mob_cmds.cpp:	    value3 = ch->level / atoi( arg6 );
mob_cmds.cpp:	    value4 = ch->level + atoi( arg7 );
mob_cmds.cpp:	    value4 = ch->level - atoi( arg7 );
mob_cmds.cpp:	    value4 = ch->level * atoi( arg7 );
mob_cmds.cpp:	    value4 = ch->level / atoi( arg7 );
mob_cmds.cpp:	room = ch->in_room;
mob_cmds.cpp:	    vch_next = vch->next;
mob_cmds.cpp:	    if ( vch->in_room == room && !IS_IMMORTAL( vch ) )
mob_cmds.cpp:	vch_next = vch->next_in_room;
mob.dmp:#15400   1 active   0 killed     the Arch-Villan Darathorn
mob_prog.cpp:    for( ; vch; vch = vch->next_in_room )
mob_prog.cpp:    for ( count = 0; vch; vch = vch->next_in_room )
mob_prog.cpp:	    && mob->pIndexData->vnum == vch->pIndexData->vnum )
mob_prog.cpp:	vch = ch->in_room->people;
mob_prog.cpp:	for ( i = 0; vch; vch = vch->next_in_room )
mob_prog.cpp:	      &&   vch->pIndexData->vnum == ch->pIndexData->vnum )
mob_prog.cpp:    for ( obj = ch->carrying; obj; obj = obj->next_content )
mob_prog.cpp:	mob = ch->in_room->people;
mob_prog.cpp:	vobj = ch->in_room->contents;
mob_prog.cpp:            	    one_argument( ch->name, fname );
mob_prog.cpp:		? ( IS_NPC( ch ) ? ch->short_descr : ch->name )
mob_prog.cpp:            	     one_argument( vch->name, fname );
mob_prog.cpp:		? ( IS_NPC( vch ) ? vch->short_descr : vch->name )
mob_prog.cpp:                    one_argument( rch->name, fname );
mob_prog.cpp:		? ( IS_NPC( ch ) ? ch->short_descr : ch->name )
mob_prog.cpp:		? he_she  [URANGE(0, ch->sex, 2)]        
mob_prog.cpp:		? he_she  [URANGE(0, vch->sex, 2)]        
mob_prog.cpp:		? he_she  [URANGE(0, rch->sex, 2)]        
mob_prog.cpp:            	    one_argument( ch->name, fname );
mob_prog.cpp:		? ( IS_NPC( ch ) ? ch->short_descr : ch->name )
mob_prog.cpp:            	     one_argument( vch->name, fname );
mob_prog.cpp:		? ( IS_NPC( vch ) ? vch->short_descr : vch->name )
mob_prog.cpp:                    one_argument( rch->name, fname );
mob_prog.cpp:		? ( IS_NPC( ch ) ? ch->short_descr : ch->name )
mob_prog.cpp:		? he_she  [URANGE(0, ch->sex, 2)]        
mob_prog.cpp:		? he_she  [URANGE(0, vch->sex, 2)]        
mob_prog.cpp:		? he_she  [URANGE(0, rch->sex, 2)]        
mob_prog.cpp:		? him_her [URANGE(0, ch->sex, 2)]
mob_prog.cpp:		? him_her [URANGE(0, vch->sex, 2)]        
mob_prog.cpp:	for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
mob_prog.cpp:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj->next_content )
mob_prog.cpp:	for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
mob_prog.cpp:	room = ch->in_room;
mob_prog.cpp:	for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
mob_prog.cpp:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj->next_content )
mob_prog.cpp:	for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
mob_prog.cpp:	room = ch->in_room;
mount.cpp:    if (ch->pcdata->condition[COND_DRUNK] < 10 )
mount.cpp:  if (ch->is_mounted)
mount.cpp:    ch->is_mounted = TRUE;
mount.cpp:    ch->mount = mount;
mount.cpp:  if ((mount = ch->mount) == NULL)
mount.cpp:  af.level = ch->level;
mount.cpp:  af.duration = ch->level / 5;
mount.cpp:  if ((mount = ch->mount) == NULL)
mount.cpp:  if (!ch->is_mounted)
mount.cpp:  if (ch->mount)
mount.cpp:    act("$n dismounts from $N", ch, NULL, ch->mount, TO_ROOM);
mount.cpp:    act("You dismount from $N", ch, NULL, ch->mount, TO_CHAR);
mount.cpp:    ch->is_mounted = FALSE;
mount.cpp:    ch->mount->is_mounted = FALSE;
mount.cpp:    ch->mount->leader = NULL;
mount.cpp:  ch->is_mounted = FALSE;
mount.cpp:  ch->mount = NULL;
mount.cpp:  ch->is_mounted = FALSE;
music.cpp:    for (juke = ch->in_room->contents; juke != NULL;
note.cpp:                ch->pcdata->last_note = current_time;
note.cpp:                ch->pcdata->last_idea = current_time;
note.cpp:                ch->pcdata->last_guildmaster = current_time;
note.cpp:                ch->pcdata->last_news = current_time;
note.cpp:                ch->pcdata->last_changes = current_time;
note.cpp:                ch->pcdata->last_imm = current_time;
note.cpp:                ch->pcdata->last_rp = current_time;
note.cpp:                ch->pcdata->last_guide = current_time;
note.cpp:                ch->pcdata->last_store = current_time;
note.cpp:    if ((ch->clan == clan_lookup("Guide"))&&(count = count_spool (ch, guide_list)) >= 0)
note.cpp:    if (!str_cmp (ch->name, pnote->sender))
note.cpp:    if (ch->clan && is_exact_name (clan_table[ch->clan].name, pnote->to_list))
note.cpp:    if (is_exact_name (ch->name, pnote->to_list))
note.cpp:    if (pnote->type == NOTE_IDEA && !IS_IMMORTAL(ch) && !IS_SET(ch->act2, PLR_DEVELOPER) && IS_GUILDMASTER(ch))
note.cpp:    if (pnote->type == NOTE_GUIDE && (ch->clan != clan_lookup("Guide")))
note.cpp:    if (is_exact_name ("all", pnote->to_list) && ch->pcdata->primary)
note.cpp:        (IS_SET(ch->act2, PLR_GUILDLEADER) || IS_TRUSTED (ch, IMPLEMENTOR) || IS_GUILDMASTER(ch)||IS_FORSAKEN(ch)||IS_DRAGON(ch)) )
note.cpp:    if ((ch->level == MAX_LEVEL) && (is_exact_name ("implementor", pnote->to_list)|| 
note.cpp:    if ( IS_SET(ch->act2, PLR_GUILDLEADER) && (is_exact_name( "guildleader", pnote->to_list )
note.cpp:    if (ch->clan && is_exact_name(clan_table[ch->clan].name,pnote->to_list))
note.cpp:    if (is_exact_name( ch->name, pnote->to_list ) )
note.cpp:    if (ch->pnote != NULL)
note.cpp:    pnote->sender = str_dup (ch->name);
note.cpp:    ch->pnote = pnote;
note.cpp:            if (to_one[0] != '\0' && str_cmp (ch->name, to_one))
note.cpp:        if (str_cmp (ch->name, pnote->sender) && to_new[0] != '\0')
note.cpp:            last_read = ch->pcdata->last_note;
note.cpp:            last_read = ch->pcdata->last_idea;
note.cpp:            last_read = ch->pcdata->last_guildmaster;
note.cpp:            last_read = ch->pcdata->last_news;
note.cpp:            last_read = ch->pcdata->last_changes;
note.cpp:            last_read = ch->pcdata->last_imm;
note.cpp:            last_read = ch->pcdata->last_rp;
note.cpp:            last_read = ch->pcdata->last_guide;
note.cpp:            last_read = ch->pcdata->last_store;
note.cpp:    if (!str_cmp (ch->name, pnote->sender))
note.cpp:            ch->pcdata->last_note = UMAX (ch->pcdata->last_note, stamp);
note.cpp:            ch->pcdata->last_idea = UMAX (ch->pcdata->last_idea, stamp);
note.cpp:            ch->pcdata->last_guildmaster = UMAX (ch->pcdata->last_guildmaster, stamp);
note.cpp:            ch->pcdata->last_news = UMAX (ch->pcdata->last_news, stamp);
note.cpp:            ch->pcdata->last_changes = UMAX (ch->pcdata->last_changes, stamp);
note.cpp:            ch->pcdata->last_imm = UMAX (ch->pcdata->last_imm, stamp);
note.cpp:            ch->pcdata->last_rp = UMAX (ch->pcdata->last_rp, stamp);
note.cpp:            ch->pcdata->last_guide = UMAX (ch->pcdata->last_guide, stamp);
note.cpp:            ch->pcdata->last_store = UMAX (ch->pcdata->last_store, stamp);
note.cpp:		    if (IS_SET(ch->act2, PLR_MXP))	
note.cpp:                             pnote->type == NOTE_RP ? ch->pcdata->fonts.rpnote : ch->pcdata->fonts.notes,
note.cpp:			     pnote->type == NOTE_RP ? ch->pcdata->fonts.rpnote : ch->pcdata->fonts.notes,
note.cpp:			     pnote->type == NOTE_RP ? ch->pcdata->fonts.rpnote : ch->pcdata->fonts.notes,
note.cpp:		    if (IS_SET(ch->act2, PLR_MXP))
note.cpp:                 if (IS_SET(ch->act2, PLR_MXP))
note.cpp:			 pnote->type == NOTE_RP ? ch->pcdata->fonts.rpnote : ch->pcdata->fonts.notes,
note.cpp:			 pnote->type == NOTE_RP ? ch->pcdata->fonts.rpnote : ch->pcdata->fonts.notes,
note.cpp:			 pnote->type == NOTE_RP ? ch->pcdata->fonts.rpnote : ch->pcdata->fonts.notes,
note.cpp:		if (IS_SET(ch->act2, PLR_MXP))
note.cpp:                ch->pnote->next                  = NULL;
note.cpp:                free_string(ch->pnote->subject);
note.cpp:                ch->pnote->subject               = str_dup(nBuf);
note.cpp:	        free_string( ch->pnote->text );
note.cpp:	        ch->pnote->text = str_dup( buf_string(buffer) );
note.cpp:		if (IS_SET(ch->act2, PLR_MXP))
note.cpp:                    sprintf(buf, "\e[1z<font 'lucida handwriting'>      `4%s`* Note</font>\n\r", capitalize(clan_table[ch->clan].name));
note.cpp:                    sprintf(buf, "      `4%s`* Note\n\r", capitalize(clan_table[ch->clan].name));
note.cpp:                ch->pcdata->last_note = current_time;
note.cpp:                ch->pcdata->last_idea = current_time;
note.cpp:                ch->pcdata->last_guildmaster = current_time;
note.cpp:                ch->pcdata->last_news = current_time;
note.cpp:                ch->pcdata->last_changes = current_time;
note.cpp:                ch->pcdata->last_imm = current_time;
note.cpp:                ch->pcdata->last_rp = current_time;
note.cpp:                ch->pcdata->last_guide = current_time;
note.cpp:                ch->pcdata->last_store = current_time;
note.cpp:      if ((ch->clan > 0 && ch->rank < clan_table[ch->clan].top_rank - 2) && !have_store(ch) && !IS_IMMORTAL(ch))
note.cpp:        if (ch->pnote->type != type)
note.cpp:        ch->pnote->text = format_string(ch->pnote->text);
note.cpp:        if (ch->pnote->type != type)
note.cpp:        if (strlen (ch->pnote->text) + strlen (argument) >= 4096)
note.cpp:        add_buf (buffer, ch->pnote->text);
note.cpp:        free_string (ch->pnote->text);
note.cpp:        ch->pnote->text = str_dup (buf_string (buffer));
note.cpp:        if (ch->pnote->type != type)
note.cpp:        string_append(ch, &ch->pnote->text);
note.cpp:        if (ch->pnote->type != type)
note.cpp:        if (ch->pnote->text == NULL || ch->pnote->text[0] == '\0')
note.cpp:        strcpy (buf, ch->pnote->text);
note.cpp:                    free_string (ch->pnote->text);
note.cpp:                    ch->pnote->text = str_dup (buf);
note.cpp:        free_string (ch->pnote->text);
note.cpp:        ch->pnote->text = str_dup (buf);
note.cpp:        if (ch->pnote->type != type)
note.cpp:        free_string (ch->pnote->subject);
note.cpp:        ch->pnote->subject = str_dup (argument);
note.cpp:        if (ch->pnote->type != type)
note.cpp:        free_string (ch->pnote->to_list);
note.cpp:        ch->pnote->to_list = str_dup (argument);
note.cpp:        if (ch->pnote->type != type)
note.cpp:        free_string (ch->pnote->sender);
note.cpp:        ch->pnote->sender = str_dup (argument);
note.cpp:        if (ch->pnote != NULL)
note.cpp:            free_note (ch->pnote);
note.cpp:            ch->pnote = NULL;
note.cpp:        if (ch->pnote == NULL)
note.cpp:        if (ch->pnote->type != type)
note.cpp:	if (IS_SET(ch->act2, PLR_MXP))
note.cpp:			ch->pnote->type == NOTE_RP ? ch->pcdata->fonts.rpnote : ch->pcdata->fonts.notes,
note.cpp:                        ch->pnote->sender, ch->pnote->subject, 
note.cpp:			ch->pnote->type == NOTE_RP ? ch->pcdata->fonts.rpnote : ch->pcdata->fonts.notes,
note.cpp:			ch->pnote->to_list);
note.cpp:                 ch->pnote->sender, ch->pnote->subject, ch->pnote->to_list);
note.cpp:	if (IS_SET(ch->act2, PLR_MXP))
note.cpp:	  page_to_char(fontnote(ch->pnote->text, ch, ch->pnote->type), ch);
note.cpp:          send_to_char (ch->pnote->text, ch);
note.cpp:        if (ch->pnote == NULL)
note.cpp:        if (ch->pnote->type != type)
note.cpp:        if (!str_cmp (ch->pnote->to_list, ""))
note.cpp:        if (!str_cmp (ch->pnote->subject, ""))
note.cpp:        ch->pnote->next = NULL;
note.cpp:        ch->pnote->date = str_dup (strtime);
note.cpp:        ch->pnote->date_stamp = current_time;
note.cpp:        note_echo(ch->pnote, ch);
note.cpp:        append_note (ch->pnote);
note.cpp:        ch->pnote = NULL;
note.cpp:       if (ch != NULL && !str_cmp(ch->name, pnote->sender))
notes.not:if ( victim->in_room == ch->in_room )
obj.dmp:#3428   1 active   0 reset      the pitch-black flaming longsword
olc_act.cpp:    pArea = ch->in_room->area;
olc_act.cpp:    pArea = ch->in_room->area;
olc_act.cpp:    pArea = ch->in_room->area;
olc_act.cpp:        ch->desc->pEdit = (void *) pMob;
olc_act.cpp:    ch->desc->pEdit = (void *) ch->in_room;
olc_act.cpp:        ch->desc->pEdit = (void *) pObj;
olc_act.cpp:    ch->desc->pEdit = (void *) ch->in_room;
olc_act.cpp:    ch->desc->pEdit = (void *) pArea;
olc_act.cpp:    if (value > ch->pcdata->security || value < 0)
olc_act.cpp:        if (ch->pcdata->security != 0)
olc_act.cpp:            sprintf (buf, "Security is 0-%d.\n\r", ch->pcdata->security);
olc_act.cpp:    for (rch = pRoom->people; rch; rch = rch->next_in_room)
olc_act.cpp:        one_argument (rch->name, buf);
olc_act.cpp:    ch->desc->pEdit = (void *) pRoom;
olc_act.cpp:    ch->desc->pEdit = (void *) pObj;
olc_act.cpp:    ch->desc->pEdit = (void *) pMob;
olc_act.cpp:  ch->desc->pEdit = (void *) guild;
olc_act.cpp:     if (wch->clan == clan)
olc_act.cpp:       wch->clan = clan_lookup("Outcast");
olc_act.cpp:  ch->desc->pEdit = (void *) quest;
olc.cpp:    switch (ch->desc->editor)
olc.cpp:    switch (ch->desc->editor)
olc.cpp:            pArea = (AREA_DATA *) ch->desc->pEdit;
olc.cpp:            pRoom = ch->in_room;
olc.cpp:            pObj = (OBJ_INDEX_DATA *) ch->desc->pEdit;
olc.cpp:            pMob = (MOB_INDEX_DATA *) ch->desc->pEdit;
olc.cpp:            pMprog = (PROG_CODE *) ch->desc->pEdit;
olc.cpp:            pOprog = (PROG_CODE *)ch->desc->pEdit;
olc.cpp:            pRprog = (PROG_CODE *)ch->desc->pEdit;
olc.cpp:            pHelp = (HELP_DATA *) ch->desc->pEdit;
olc.cpp:            pGuild = (CLAN_DATA *) ch->desc->pEdit;
olc.cpp:    switch (ch->desc->editor)
olc.cpp:    ch->desc->pEdit = NULL;
olc.cpp:    ch->desc->editor = 0;
olc.cpp:    pArea = ch->in_room->area;
olc.cpp:    if (ch->pcdata->security < 10)
olc.cpp:    pArea = ch->in_room->area;
olc.cpp:        if (ch->pcdata->security < 9)
olc.cpp:        ch->desc->editor = ED_AREA;
olc.cpp:    ch->desc->pEdit = (void *) pArea;
olc.cpp:    ch->desc->editor = ED_AREA;
olc.cpp:    pRoom = ch->in_room;
olc.cpp:            ch->desc->editor = ED_ROOM;
olc.cpp:            char_to_room (ch, (ROOM_INDEX_DATA *) ch->desc->pEdit);
olc.cpp:            SET_BIT (((ROOM_INDEX_DATA *) ch->desc->pEdit)->area->area_flags,
olc.cpp:    ch->desc->pEdit = (void *) pRoom;
olc.cpp:    ch->desc->editor = ED_ROOM;
olc.cpp:    guild = &clan_table[ch->clan];
olc.cpp:            ch->desc->editor = ED_GUILD;
olc.cpp:    ch->desc->pEdit = (void *) guild;
olc.cpp:    ch->desc->editor = ED_GUILD;
olc.cpp:            ch->desc->editor = ED_QUEST;
olc.cpp:    ch->desc->pEdit = (void *) quest;
olc.cpp:    ch->desc->editor = ED_QUEST;
olc.cpp:        ch->desc->pEdit = (void *) pObj;
olc.cpp:        ch->desc->editor = ED_OBJECT;
olc.cpp:                ch->desc->editor = ED_OBJECT;
olc.cpp:        ch->desc->pEdit = (void *) pMob;
olc.cpp:        ch->desc->editor = ED_MOBILE;
olc.cpp:                ch->desc->editor = ED_MOBILE;
olc.cpp:    if (!IS_BUILDER (ch, ch->in_room->area))
olc.cpp:        if (ch->in_room->reset_first)
olc.cpp:        ROOM_INDEX_DATA *pRoom = ch->in_room;
olc.cpp:            if (!ch->in_room->reset_first)
olc.cpp:            if (!ch->in_room->reset_first)
olc.cpp:                pReset->arg3 = ch->in_room->vnum;
olc.cpp:                    pReset->arg3 = ch->in_room->vnum;
olc.cpp:            add_reset (ch->in_room, pReset, atoi (arg1));
olc.cpp:            SET_BIT (ch->in_room->area->area_flags, AREA_CHANGED);
olc.cpp:            pReset->arg1 = ch->in_room->vnum;
olc.cpp:            add_reset (ch->in_room, pReset, atoi (arg1));
olc.cpp:            SET_BIT (ch->in_room->area->area_flags, AREA_CHANGED);
olc_mpcode.cpp:	ch->desc->pEdit		= (void *)pMcode;
olc_mpcode.cpp:	ch->desc->editor	= ED_MPCODE;
olc_mpcode.cpp:	ch->desc->pEdit		= (void *)pOcode;
olc_mpcode.cpp:	ch->desc->editor	= ED_OPCODE;
olc_mpcode.cpp:	ch->desc->pEdit		= (void *)pRcode;
olc_mpcode.cpp:	ch->desc->editor	= ED_RPCODE;
olc_mpcode.cpp:    ch->desc->pEdit		= (void *)pMcode;
olc_mpcode.cpp:    ch->desc->editor		= ED_MPCODE;
olc_mpcode.cpp:    ch->desc->pEdit		= (void *)pOcode;
olc_mpcode.cpp:    ch->desc->editor		= ED_OPCODE;
olc_mpcode.cpp:    ch->desc->pEdit		= (void *)pRcode;
olc_mpcode.cpp:    ch->desc->editor		= ED_RPCODE;
olc_mpcode.cpp:	if ( fAll || ENTRE(ch->in_room->area->min_vnum, mprg->vnum, ch->in_room->area->max_vnum) )
olc_mpcode.cpp:	if ( fAll || ENTRE(ch->in_room->area->min_vnum, oprg->vnum, ch->in_room->area->max_vnum) )
olc_mpcode.cpp:	if ( fAll || ENTRE(ch->in_room->area->min_vnum, rprg->vnum, ch->in_room->area->max_vnum) )
olc_save.cpp:        sec = ch->pcdata->security;
olc_save.cpp:        if (!ch || !ch->desc)
olc_save.cpp:        if (ch->desc->editor == ED_NONE)
olc_save.cpp:        switch (ch->desc->editor)
olc_save.cpp:                pArea = (AREA_DATA *) ch->desc->pEdit;
olc_save.cpp:                pArea = ch->in_room->area;
olc_save.cpp:                pArea = ((OBJ_INDEX_DATA *) ch->desc->pEdit)->area;
olc_save.cpp:                pArea = ((MOB_INDEX_DATA *) ch->desc->pEdit)->area;
olc_save.cpp:                pArea = ch->in_room->area;
quest2.cpp:  for (list = ch->pcdata->quests; list != NULL; list = list->next)
quest2.cpp:  list->next = ch->pcdata->quests;
quest2.cpp:  ch->pcdata->quests = list;
quest2.cpp:  for (list = ch->pcdata->quests; list != NULL; list = list->next)
quest2.cpp:  for (list = ch->pcdata->quests; list != NULL; list = list->next)
quest2.cpp:  for (list = ch->pcdata->quests; list != NULL; list = list->next)
quest2.cpp:  for (list = ch->pcdata->quests; list != NULL; list = list->next)
quest2.cpp:  for (list = ch->pcdata->quests; list != NULL; list = list->next)
quest2.cpp:  for (list = ch->pcdata->quests; list != NULL; list = list->next)
quest.cpp:	if (IS_SET(ch->act, PLR_QUESTOR))
quest.cpp:	    if (ch->questmob == -1 && ch->questgiver->short_descr != NULL)
quest.cpp:		sprintf(buf, "Your quest is ALMOST complete!\n\rGet back to %s before your time runs out!\n\r",ch->questgiver->short_descr);
quest.cpp:	    else if (ch->questobj > 0)
quest.cpp:                questinfoobj = get_obj_index(ch->questobj);
quest.cpp:                    if (!IS_NULLSTR(ch->pcdata->questarea) && !IS_NULLSTR(ch->pcdata->questroom))
quest.cpp:                         ch->pcdata->questarea,
quest.cpp:                         ch->pcdata->questroom);
quest.cpp:	    else if (ch->questmob > 0)
quest.cpp:                questinfo = get_mob_index(ch->questmob);
quest.cpp:	    else if (ch->questriddle > 0)
quest.cpp:              if ((riddle = get_riddle_index(ch->questriddle)) == NULL)
quest.cpp:	sprintf(buf, "You have %ld quest points.\n\r",ch->questpoints);
quest.cpp:	if (!IS_SET(ch->act, PLR_QUESTOR))
quest.cpp:	    if (ch->nextquest > 1)
quest.cpp:		sprintf(buf, "There are %d minutes remaining until you can go on another quest.\n\r",ch->nextquest);
quest.cpp:	    else if (ch->nextquest == 1)
quest.cpp:        else if (ch->countdown > 0)
quest.cpp:	    sprintf(buf, "Time left for current quest: %d\n\r",ch->countdown);
quest.cpp:    for ( questman = ch->in_room->people; questman != NULL; questman = questman->next_in_room )
quest.cpp:        obj = create_object(get_obj_index(qprize_table[quest_list[prize]].vnum),ch->level);
quest.cpp:          ch->questpoints += prize;
quest.cpp:          logf("QP TURNIN: %s turned in quest token worth %d", ch->name, prize);
quest.cpp:            sprintf(buf, "%s lost out on a prize coupon.", ch->name); 
quest.cpp:          obj = create_object(pObjIndex, ch->level);
quest.cpp:          ch->pcdata->learned[sn] = 75;
quest.cpp:          if (ch->pcdata->pk_timer > 0)
quest.cpp:          do_restore(questman, ch->name);
quest.cpp:            sprintf (buf,"%s tried to buy a token worth %d. Hmm..\n\r",ch->name,points);
quest.cpp:          if (value > ch->questpoints)
quest.cpp:	  if ((obj = create_object(get_obj_index(TOKEN_VNUM), ch->level)) == NULL)
quest.cpp:          logf("%s: %s bought quest token worth %d", ch->level >= 78 ? "IMMORTAL QP" : "MORTAL QP", ch->name, points);
quest.cpp:	  ch->questpoints -= value;
quest.cpp:        if (ch->questpoints < qprize_table[quest_list[prize]].cost)   
quest.cpp:	  sprintf(buf, "Sorry, %s, but you don't have enough quest points for that.", ch->name);
quest.cpp:	ch->questpoints -= qprize_table[quest_list[prize]].cost;
quest.cpp:	  obj = create_object(get_obj_index(qprize_table[quest_list[prize]].vnum),ch->level);
quest.cpp:            ch->gold += 1000;
quest.cpp:            ch->practice += 10;
quest.cpp:        if (ch->position < POS_RESTING)
quest.cpp:	if (IS_SET(ch->act, PLR_QUESTOR))
quest.cpp:	if (ch->nextquest > 0)
quest.cpp:	    sprintf(buf, "%s You're very brave, but let someone else have a chance.",ch->name);
quest.cpp:	    sprintf(buf, "%s Come back later.", ch->name);
quest.cpp:	sprintf(buf, "%s Thank you, brave %s!",ch->name, ch->name);
quest.cpp:        ch->questmob = 0;
quest.cpp:        ch->questobj = 0;
quest.cpp:        ch->questriddle = 0;
quest.cpp:        if (ch->questmob > 0 || ch->questobj > 0 || ch->questriddle > 0)
quest.cpp:            ch->countdown = number_range(30,40);
quest.cpp:	    SET_BIT(ch->act, PLR_QUESTOR);
quest.cpp:	    sprintf(buf, "%s You have %d minutes to complete this quest.",ch->name, ch->countdown);
quest.cpp:	    sprintf(buf, "%s May the gods go with you!", ch->name);
quest.cpp:        ch->questgiver = questman;
quest.cpp:	if (ch->questgiver != questman)
quest.cpp:	    sprintf(buf, "%s I never sent you on a quest! Perhaps you're thinking of someone else.", ch->name);
quest.cpp:	if (IS_SET(ch->act, PLR_QUESTOR))
quest.cpp:	    if (ch->questmob == -1 && ch->countdown > 0)
quest.cpp:                pointreward += (ch->countdown / 2);
quest.cpp:		sprintf(buf, "%s Congratulations on completing your quest!", ch->name);
quest.cpp:		sprintf(buf,"%s As a reward, I am giving you %d quest points, and %d gold.", ch->name, pointreward,reward);
quest.cpp:                if (ch->clan > 0)
quest.cpp:		  clan_table[ch->clan].roster.questpoints += qp;
quest.cpp:                  ch->practice += pracreward;
quest.cpp:	        REMOVE_BIT(ch->act, PLR_QUESTOR);
quest.cpp:	        ch->questgiver = NULL;
quest.cpp:	        ch->countdown = 0;
quest.cpp:	        ch->questmob = 0;
quest.cpp:	        ch->rescuemob = 0;
quest.cpp: 		ch->questobj = 0;
quest.cpp:	        ch->nextquest = xp_bonus.on ? 15 : number_range(15,35);
quest.cpp:		ch->gold += reward;
quest.cpp:		ch->questpoints += pointreward;
quest.cpp:	    else if (ch->questobj > 0 && ch->countdown > 0)
quest.cpp:    		for (obj = ch->carrying; obj != NULL; obj= obj_next)
quest.cpp:		    if (obj != NULL && obj->pIndexData->vnum == ch->questobj)
quest.cpp:                    free_string(ch->pcdata->questarea);
quest.cpp:                    free_string(ch->pcdata->questroom);
quest.cpp:                    ch->pcdata->questarea = str_dup("");
quest.cpp:                    ch->pcdata->questroom = str_dup("");
quest.cpp:	    	    sprintf(buf, "%s Congratulations on completing your quest!", ch->name);
quest.cpp:		    sprintf(buf,"%s As a reward, I am giving you %d quest points, and %d gold.", ch->name, pointreward,reward);
quest.cpp:                    if (ch->clan > 0)
quest.cpp:   		       clan_table[ch->clan].roster.questpoints += qp;
quest.cpp:	            REMOVE_BIT(ch->act, PLR_QUESTOR);
quest.cpp:	            ch->questgiver = NULL;
quest.cpp:	            ch->countdown = 0;
quest.cpp:	            ch->questmob = 0;
quest.cpp:		    ch->questobj = 0;
quest.cpp:	            ch->nextquest = xp_bonus.on ? 15 : number_range(15,35);
quest.cpp:		    ch->gold += reward;
quest.cpp:		    ch->questpoints += pointreward;
quest.cpp:		    sprintf(buf, "%s You haven't completed the quest yet, but there is still time!", ch->name);
quest.cpp:	    else if ((ch->questmob > 0 || ch->questobj > 0) && ch->countdown > 0)
quest.cpp:		sprintf(buf, "%s You haven't completed the quest yet, but there is still time!", ch->name);
quest.cpp:	if (ch->nextquest > 0)
quest.cpp:	    sprintf(buf,"%sBut you didn't complete your quest in time!", ch->name);
quest.cpp:	else sprintf(buf, "%s You have to REQUEST a quest first, %s.", ch->name, ch->name);
quest.cpp:      if (!IS_SET(ch->act, PLR_QUESTOR))
quest.cpp:      REMOVE_BIT(ch->act, PLR_QUESTOR);
quest.cpp:      ch->questgiver = NULL;
quest.cpp:      ch->countdown = 0;
quest.cpp:      ch->questmob = 0;
quest.cpp:      ch->questobj = 0;
quest.cpp:      if (ch->rescuemob > 0)
quest.cpp:      ch->rescuemob = 0;
quest.cpp:      free_string(ch->pcdata->questarea);     
quest.cpp:      free_string(ch->pcdata->questroom);
quest.cpp:      ch->pcdata->questarea = str_dup("");
quest.cpp:      ch->pcdata->questroom = str_dup("");
quest.cpp:        ch->nextquest = xp_bonus.on ? 15 : number_range(15,35);
quest.cpp:        ch->nextquest = 0;
quest.cpp:      sprintf(buf, "Quest aborted %d minutes till you can quest again.\n\r", ch->nextquest);
quest.cpp:      if (!IS_SET(ch->act, PLR_QUESTOR))
quest.cpp:      if (ch->questriddle == 0)
quest.cpp:      if ((riddle = get_riddle_index(ch->questriddle)) == NULL)
quest.cpp:        REMOVE_BIT(ch->act, PLR_QUESTOR);
quest.cpp:        ch->nextquest = 0;
quest.cpp:        ch->questriddle = 0;
quest.cpp:        ch->questgiver = NULL;
quest.cpp:	ch->countdown = 0;
quest.cpp:	ch->questmob = 0;
quest.cpp:	ch->questobj = 0;
quest.cpp:         pointreward += (ch->countdown / 2);
quest.cpp:	sprintf(buf, "%s Congratulations on completing your quest!", ch->name);
quest.cpp:	sprintf(buf,"%s As a reward, I am giving you %d quest points, and %d gold.", ch->name, pointreward,reward);
quest.cpp:        if (ch->clan > 0)
quest.cpp:   	  clan_table[ch->clan].roster.questpoints += qp;
quest.cpp:	ch->gold += reward;
quest.cpp:	ch->questpoints += pointreward;
quest.cpp:	  sprintf(buf, "%s You gain %d practices!\n\r", ch->name, pracreward);
quest.cpp:                  ch->practice += pracreward;
quest.cpp:        REMOVE_BIT(ch->act, PLR_QUESTOR);
quest.cpp:        ch->nextquest = 0;
quest.cpp:        ch->questriddle = 0;
quest.cpp:        ch->questgiver = NULL;
quest.cpp:	ch->countdown = 0;
quest.cpp:	ch->questmob = 0;
quest.cpp:	ch->questobj = 0;
quest.cpp:        ch->nextquest = xp_bonus.on ? 15 : number_range(15,35);
quest.cpp:      	sprintf(buf, "%s Sorry, but that is not the correct answer.\n\r", ch->name); 
quest.cpp: 	sprintf(buf, "%s I'm sorry, but I don't have any quests for you at this time.", ch->name);
quest.cpp:	sprintf(buf, "%s Try again later.", ch->name);
quest.cpp:	ch->nextquest = 0;
quest.cpp:        sprintf(buf, "%s Your quest is to solve the following riddle:", ch->name);
quest.cpp:        SET_BIT(ch->act, PLR_QUESTOR);
quest.cpp:        ch->questriddle = riddle->vnum;
quest.cpp:	    level_diff = vsearch->level - ch->level;
quest.cpp:	    if ( ((ch->level < 10 && level_diff < 7 && level_diff > -5)
quest.cpp:                 || (ch->level < 40 && level_diff < 15 && level_diff > -5)
quest.cpp:                 || (ch->level < 90 && level_diff < 35 && level_diff > -5)
quest.cpp:		&& vsearch->pShop == NULL
quest.cpp:		&& !IS_SET(vsearch->area->area_flags, AREA_NOQUEST)
quest.cpp:		&& !IS_SET(vsearch->area->area_flags, AREA_UNLINKED)
quest.cpp:    		&& !IS_SET(vsearch->act,ACT_TRAIN)
quest.cpp:    		&& !IS_SET(vsearch->act,ACT_PRACTICE)
quest.cpp:    		&& !IS_SET(vsearch->act,ACT_IS_HEALER)
quest.cpp:                && !IS_SET(vsearch->act,ACT_NOQUEST))
quest.cpp:    if ( vsearch == NULL || ( victim = get_char_world_vnum( ch, vsearch->vnum ) ) == NULL )
quest.cpp:	sprintf(buf, "%s I'm sorry, but I don't have any quests for you at this time.", ch->name);
quest.cpp:	sprintf(buf, "%s Try again later.", ch->name);
quest.cpp:	ch->nextquest = 0;
quest.cpp:	sprintf(buf, "%s I'm sorry, but I don't have any quests for you at this time.", ch->name);
quest.cpp:	sprintf(buf, "%s Try again later.", ch->name);
quest.cpp:	ch->nextquest = 0;
quest.cpp:        questitem = create_object( get_obj_index(objvnum), ch->level );
quest.cpp:        questitem->owner = str_dup(ch->name);
quest.cpp:	ch->questobj = questitem->pIndexData->vnum;
quest.cpp:	sprintf(buf, "%s A rouge has stolen %s from the White Tower!", ch->name, questitem->short_descr);
quest.cpp:	sprintf(buf, "%s My apprentice has been able to locate its position.", ch->name);
quest.cpp:	sprintf(buf, "%s The scry has located it in %s very close to %s!", ch->name, room->area->name, room->name);
quest.cpp:        free_string(ch->pcdata->questarea);
quest.cpp:        free_string(ch->pcdata->questroom);
quest.cpp:        ch->pcdata->questarea = str_dup(room->area->name);
quest.cpp:        ch->pcdata->questroom = str_dup(room->name);
quest.cpp:        sprintf(buf, "%s Your quest is to eliminate %s. They have been threatening the city for days now.", ch->name, victim->short_descr);
quest.cpp:        sprintf(buf, "%s You must end their attacks and bring peace to the city!", ch->name);
quest.cpp:	sprintf(buf, "%s This city's most wanted criminal, %s, has escaped from prison!", ch->name, victim->short_descr);
quest.cpp:	sprintf(buf, "%s Since the escape, %s has murdered %d travellers!", ch->name, victim->short_descr, number_range(2,20));
quest.cpp:	sprintf(buf, "%s The penalty for this crime is death, and you are to deliver the sentence!", ch->name);
quest.cpp:        sprintf(buf, "%s Seek %s out somewhere in the vicinity of %s!",ch->name, victim->short_descr,room->name);
quest.cpp:	sprintf(buf, "%s That location is in the general area of %s.", ch->name, room->area->name);
quest.cpp:    ch->questmob = victim->pIndexData->vnum;
quest.cpp:    ch->questobj = 0;
quest.cpp:	if (ch->nextquest > 0) 
quest.cpp:	    ch->nextquest--;
quest.cpp:	    if (ch->nextquest == 0)
quest.cpp:        else if (IS_SET(ch->act,PLR_QUESTOR))
quest.cpp:	    if (--ch->countdown <= 0)
quest.cpp:	        ch->nextquest = xp_bonus.on ? 20 : 35;
quest.cpp:	        sprintf(buf, "You have run out of time for your quest!\n\rYou may quest again in %d minutes.\n\r",ch->nextquest);
quest.cpp:	        REMOVE_BIT(ch->act, PLR_QUESTOR);
quest.cpp:                ch->questgiver = NULL;
quest.cpp:                ch->countdown = 0;
quest.cpp:                ch->questmob = 0;
quest.cpp:                if (ch->rescuemob != 0)
quest.cpp:                ch->rescuemob = 0;
quest.cpp:                free_string(ch->pcdata->questarea);
quest.cpp:                free_string(ch->pcdata->questroom);
quest.cpp:                ch->pcdata->questarea = str_dup("");
quest.cpp:                ch->pcdata->questroom = str_dup("");
quest.cpp:	    if (ch->countdown > 0 && ch->countdown < 6)
quest.cpp:  if (IS_SET(ch->act, PLR_QUESTOR))
quest.cpp:      REMOVE_BIT(ch->act, PLR_QUESTOR);
quest.cpp:      ch->questgiver = NULL;
quest.cpp:      ch->countdown = 0;
quest.cpp:      ch->questmob = 0;
quest.cpp:      ch->questobj = 0;
quest.cpp:      ch->nextquest = xp_bonus.on ? 20 : 35;
quest.cpp:     sprintf(buf2, "%s %s", ch->name, buf);
quest.cpp:  sprintf(buf, "%s What am I?", ch->name);
quest.cpp:	    level_diff = vsearch->level - ch->level;
quest.cpp:	    if ( ((ch->level <= 10 && level_diff < 7 && level_diff > -5)
quest.cpp:                 || (ch->level > 10 && ch->level <= 40 && level_diff < 20 && level_diff > -5)
quest.cpp:                 || (ch->level > 40 && ch->level <= 81 && level_diff < 35 && level_diff > -5))
quest.cpp:		&& (!IS_SET(vsearch->area->area_flags, AREA_NOQUEST))
quest.cpp:		&& (!IS_SET(vsearch->area->area_flags, AREA_UNLINKED))
quest.cpp:		&& vsearch->pShop == NULL
quest.cpp:    		&& !IS_SET(vsearch->act,ACT_TRAIN)
quest.cpp:    		&& !IS_SET(vsearch->act,ACT_PRACTICE)
quest.cpp:    		&& !IS_SET(vsearch->act,ACT_IS_HEALER)
quest.cpp:		&& !IS_SET(vsearch->act,ACT_NOQUEST))
quest.cpp:            	if (IS_SET(vsearch->act,ACT_NOQUEST))
quest.cpp:                if (vsearch->alignment >= 0)
quest.cpp:                    rescue.vnumGood[good] = vsearch->vnum;
quest.cpp:                    rescue.vnumEvil[evil] = vsearch->vnum;
quest.cpp:        sprintf(buf, "%s I'm sorry, but I don't have any quests for you at this time.", ch->name);
quest.cpp:        sprintf(buf, "%s Try again later.", ch->name);
quest.cpp:      ch->nextquest = 0;
quest.cpp:        sprintf(buf, "%s I'm sorry, but I don't have any quests for you at this time.", ch->name);
quest.cpp:        sprintf(buf, "%s Try again later.", ch->name);
quest.cpp:      ch->nextquest = 0;
quest.cpp:        sprintf(buf, "%s I'm sorry, but I don't have any quests for you at this time.", ch->name);
quest.cpp:        sprintf(buf, "%s Try again later.", ch->name);
quest.cpp:      ch->nextquest = 0;
quest.cpp:        sprintf(buf, "%s I'm sorry, but I don't have any quests for you at this time.", ch->name);
quest.cpp:        sprintf(buf, "%s Try again later.", ch->name);
quest.cpp:      ch->nextquest = 0;
quest.cpp:        sprintf(buf, "%s I'm sorry, but I don't have any quests for you at this time.", ch->name);
quest.cpp:        sprintf(buf, "%s Try again later.", ch->name);
quest.cpp:      ch->nextquest = 0;
quest.cpp:	         ch->name, goodMob->short_descr, evilMob->short_descr);
quest.cpp:                ch->name, goodMob->short_descr);
quest.cpp:		ch->name, evilMob->short_descr, room->name);
quest.cpp:	        ch->name, room->area->name);
quest.cpp:    ch->rescuemob = goodMob->pIndexData->vnum;
quest.cpp:    ch->questmob = evilMob->pIndexData->vnum;  
quest.cpp:    evilMob->attacking = ch->rescuemob;
quest.cpp:    ch->pcdata->questarea = str_dup(room->area->name);
quest.cpp:    ch->pcdata->questarea = str_dup(room->name);
quest.cpp:  for (wch = char_list; wch != NULL; wch = wch->next)
quest.cpp:    if (wch->rescuer == ch)
quest.cpp:      wch->rescuer = NULL;
quest.cpp:      wch->spec_fun = wch->pIndexData->spec_fun;
quest.cpp:      if (wch->attacker)
quest.cpp:        if (bPullAttacker && get_char_exists(wch->attacker)) 
quest.cpp:          extract_char(wch->attacker, TRUE);
quest.cpp:        wch->attacker = NULL;
quest.cpp:  if (ch->countdown <= 0 || ch->rescuemob != mob->pIndexData->vnum)
quest.cpp:  ch->nextquest = xp_bonus.on ? 20 : 35;
quest.cpp:  REMOVE_BIT(ch->act, PLR_QUESTOR);
quest.cpp:  ch->questgiver = NULL;
quest.cpp:  ch->rescuemob = 0;
quest.cpp:  ch->countdown = 0;
quest.cpp:  ch->questmob = 0;
quest.cpp:  sprintf(buf, "You may quest again in %d minutes.\n\r",ch->nextquest);
quest.cpp:  free_string(ch->pcdata->questarea);
quest.cpp:  free_string(ch->pcdata->questroom);
quest.cpp:  ch->pcdata->questarea = str_dup("");
quest.cpp:  ch->pcdata->questroom = str_dup("");
recycle.cpp:    ch->name = &str_empty[0];
recycle.cpp:    ch->short_descr = &str_empty[0];
recycle.cpp:    ch->long_descr = &str_empty[0];
recycle.cpp:    ch->description = &str_empty[0];
recycle.cpp:    ch->prompt = &str_empty[0];
recycle.cpp:    ch->prefix = &str_empty[0];
recycle.cpp:    ch->logon = current_time;
recycle.cpp:    ch->lines = PAGELEN;
recycle.cpp:        ch->armor[i] = 100;
recycle.cpp:    ch->position = POS_STANDING;
recycle.cpp:    ch->stunned = 0;
recycle.cpp:    ch->hit = 20;
recycle.cpp:    ch->max_hit = 20;
recycle.cpp:    ch->mana = 100;
recycle.cpp:    ch->max_mana = 100;
recycle.cpp:    ch->move = 100;
recycle.cpp:    ch->max_move = 100;
recycle.cpp:        ch->perm_stat[i] = 13;
recycle.cpp:        ch->mod_stat[i] = 0;
recycle.cpp:    for (obj = ch->carrying; obj != NULL; obj = obj_next)
recycle.cpp:    for (paf = ch->affected; paf != NULL; paf = paf_next)
recycle.cpp:    free_string (ch->name);
recycle.cpp:    free_string (ch->short_descr);
recycle.cpp:    free_string (ch->long_descr);
recycle.cpp:    free_string (ch->description);
recycle.cpp:    free_string (ch->prompt);
recycle.cpp:    free_string (ch->prefix);
recycle.cpp:    free_note (ch->pnote);
recycle.cpp:    free_pcdata (ch->pcdata);
recycle.cpp:    ch->next = char_free;
rent.cpp:    if ( IS_SET(ch->in_room->room_flags, ROOM_RENTAL) )
rent.cpp:     if ( IS_SET(ch->act, PLR_TENNANT))
rent.cpp:     ch->pcdata->rentroom = ch->in_room->vnum;
rent.cpp:     REMOVE_BIT(ch->in_room->room_flags, ROOM_RENTAL);
rent.cpp:     SET_BIT(ch->in_room->room_flags, ROOM_PRIVATE);
rent.cpp:     SET_BIT(ch->in_room->room_flags, ROOM_RENTED);
rent.cpp:     SET_BIT(ch->act, PLR_TENNANT);
rent.cpp:     ch->gold -= 10;
rent.cpp:    if ( IS_SET(ch->in_room->room_flags, ROOM_RENTED) )
rent.cpp:     if ( IS_SET(ch->act, PLR_TENNANT) && ch->pcdata->rentroom == ch->in_room->vnum)
rent.cpp:       REMOVE_BIT(ch->act, PLR_TENNANT);
rent.cpp:       REMOVE_BIT(ch->in_room->room_flags, ROOM_RENTED);
rent.cpp:       SET_BIT(ch->in_room->room_flags, ROOM_RENTAL);
rent.cpp:       ch->pcdata->rentroom = 0;
riddles.cpp:  ch->desc->editor = ED_RIDDLE;
riddles.cpp:  ch->desc->pEdit = riddle;
riddles.cpp:    ch->desc->editor = ED_NONE;
riddles.cpp:  ch->desc->editor = ED_RIDDLE;
riddles.cpp:  ch->desc->pEdit = riddle;
roleprize.cpp:  temp = con_app[ch->perm_stat[STAT_CON]].hitp +
roleprize.cpp:         class_table[ch->cClass].hp_max; /* Max Gain */
roleprize.cpp:  temp = (ch->perm_stat[STAT_INT] /5);
roleprize.cpp:  temp += class_table[ch->cClass].mana_max;
roleprize.cpp:  //if (!class_table[ch->cClass].fMana)
roleprize.cpp:   if (ch->level >= 76)
roleprize.cpp:	        UMAX(0, rp_max_hp(ch) - ch->pcdata->perm_hit),
roleprize.cpp:		UMAX(0, rp_max_mana(ch) - ch->pcdata->perm_mana));
roleprize.cpp:	        UMAX(0, 10000 - ch->gold),
roleprize.cpp:		UMAX(0, 12 - ch->rplevel));
roleprize.cpp:	if (!IS_NPC(ch) && !IS_SET(ch->in_room->room_flags, ROOM_ROLEPRIZE))
roleprize.cpp:	  if (ch->cClass == class_lookup("forsaken") || ch->cClass == class_lookup("dragon"))
roleprize.cpp:      	if ((ch->level <= 74)
roleprize.cpp:	|| (ch->rplevel < 12)
roleprize.cpp:	|| (ch->gold < 10000) 
roleprize.cpp:        || (ch->pcdata->perm_hit < rp_max_hp(ch))
roleprize.cpp:        || (ch->pcdata->perm_mana < rp_max_mana(ch)))
roleprize.cpp:           sprintf(buf, "You dont meet the %s class requirements.\n\r", class_table[ch->cClass].name);
roleprize.cpp:	else if(ch->level <= 75)
roleprize.cpp:	  	ch->gold = ch->gold - 10000;
roleprize.cpp:        if (ch->rp_points < rp_prize_table[prize].cost)   
roleprize.cpp:		ch->rp_points -= rp_prize_table[prize].cost;
roleprize.cpp:			ch->gold += 10000;
roleprize.cpp:            ch->train += 2; 
roleprize.cpp:            ch->practice += 10; 
roleprize.cpp:          if (ch->cClass == class_lookup("forsaken") || ch->cClass == class_lookup("dragon"))
roleprize.cpp:        if ((ch->level <= 74))
roleprize.cpp:       /* || (ch->rplevel < 12)
roleprize.cpp:        || (ch->gold < 10000)
roleprize.cpp:        || (ch->pcdata->perm_hit < rp_max_hp(ch))
roleprize.cpp:        || (ch->pcdata->perm_mana < rp_max_mana(ch))) */
roleprize.cpp:           sprintf(buf, "You dont meet the %s class requirements.\n\r", class_table[ch->cClass].name);
roleprize.cpp:        else if(ch->level <= 75)
roleprize.cpp:	        ch->max_hit = rp_max_hp(ch);
roleprize.cpp:		ch->max_mana = rp_max_mana(ch);
roleprize.cpp:                ch->gold = ch->gold - 10000;
roleprize.cpp:			if (ch->level < (MAX_LEVEL - 6))
roleprize.cpp:				sprintf(buf, "You are now level %d",ch->level);
roleprize.cpp:				ch->rp_points += rp_prize_table[prize].cost;
roleprize.cpp:			if (ch->rplevel<=MAX_RPLEVEL)
roleprize.cpp:				sprintf(buf, "You are now at roleplaying level %d",ch->rplevel);
roleprize.cpp:				ch->rp_points += rp_prize_table[prize].cost;
roster.cpp:    if (ch->level == MAX_LEVEL)
roster.cpp:  clan = ch->clan;
roster.cpp:  if (str_cmp(clan_table[ch->clan].roster.requestor, ch->name))
roster.cpp:  clan_table[ch->clan].roster.withdraw = 0;
roster.cpp:  clan_table[ch->clan].roster.approve = TRUE;
roster.cpp:   if (clan_table[ch->clan].roster.withdraw < 1)
roster.cpp:   if (!str_cmp(clan_table[ch->clan].roster.requestor, ch->name))
roster.cpp:   clan_table[ch->clan].roster.withdraw = 0;
roster.cpp:   clan_table[ch->clan].roster.approve = FALSE;
roster.cpp:    if (clan_table[ch->clan].roster.withdraw < 1)
roster.cpp:    if (clan_table[ch->clan].roster.approve == TRUE)
roster.cpp:    if (!str_cmp(clan_table[ch->clan].roster.requestor, ch->name))
roster.cpp:    clan_table[ch->clan].roster.approve = TRUE;  
roster.cpp:    logf("ROSTER: %s approved a withdrawl of %d quest points.\n\r", ch->name, clan_table[ch->clan].roster.withdraw); 
roster.cpp:    if (ch->rank < clan_table[ch->clan].top_rank - 2 &&
roster.cpp:		 !IS_SET(ch->act2, PLR_GUILDLEADER))
roster.cpp:    for (mbr = clan_table[ch->clan].roster.member; \
roster.cpp:    if (ch->rank >= clan_table[ch->clan].top_rank - 2)
roster.cpp:      sprintf(buf, "`&Roster for `*%s`&:`*\n\r", clan_table[ch->clan].who_name);    
roster.cpp:              clan_table[ch->clan].roster.questpoints);
roster.cpp:      if (clan_table[ch->clan].roster.withdraw > 0)
roster.cpp:                 clan_table[ch->clan].roster.requestor, 
roster.cpp:                 clan_table[ch->clan].roster.withdraw);
roster.cpp:		clan_table[ch->clan].roster.approve ? "been approved." : 
roster.cpp:      for (mbr = clan_table[ch->clan].roster.member; \
roster.cpp:	length = strlen(clan_table[ch->clan].rank[mbr->rank - 1]) - 
roster.cpp:		 colorstrlen(clan_table[ch->clan].rank[mbr->rank -1]);
roster.cpp:		    clan_table[ch->clan].rank[mbr->rank - 1], 
roster.cpp:      sprintf(buf, "`&Roster for `*%s`&:`*\n\r", clan_table[ch->clan].who_name);    
roster.cpp:		    clan_table[ch->clan].roster.questpoints);
roster.cpp:      if (clan_table[ch->clan].roster.withdraw > 0)
roster.cpp:                     clan_table[ch->clan].roster.requestor, 
roster.cpp:		     clan_table[ch->clan].roster.withdraw);
roster.cpp:		clan_table[ch->clan].roster.approve ? "been approved." : "not been approved.");   
roster.cpp:      for (mbr = clan_table[ch->clan].roster.member; 
roster.cpp:	length = strlen(clan_table[ch->clan].rank[mbr->rank - 1]) - 
roster.cpp:		 colorstrlen(clan_table[ch->clan].rank[mbr->rank -1]);
roster.cpp:		    clan_table[ch->clan].rank[mbr->rank - 1],
roster.cpp:      if (!IS_IMMORTAL(ch) && ch->rank < 4)
roster.cpp:                str_cmp(clan_table[ch->clan].roster.requestor, 
roster.cpp:		ch->name))
roster.cpp:        clan_table[ch->clan].roster.withdraw = 0;
roster.cpp:        clan_table[ch->clan].roster.approve = FALSE;
roster.cpp:        clan_table[ch->clan].roster.requestor = str_dup("None");
roster.cpp:      if (clan_table[ch->clan].roster.withdraw > 0)
roster.cpp:        if (clan_table[ch->clan].roster.approve == TRUE)
roster.cpp:                str_cmp(clan_table[ch->clan].roster.requestor, 
roster.cpp:			ch->name))
roster.cpp:          if ((token = create_object(get_obj_index(TOKEN_VNUM), ch->level)) == NULL)
roster.cpp:          points = clan_table[ch->clan].roster.withdraw;
roster.cpp:          clan_table[ch->clan].roster.questpoints -= points;
roster.cpp:          clan_table[ch->clan].roster.withdraw = 0;
roster.cpp:          clan_table[ch->clan].roster.approve = FALSE;
roster.cpp:          clan_table[ch->clan].roster.requestor = str_dup("None");
roster.cpp:     if (points < 0 || points > clan_table[ch->clan].roster.questpoints)
roster.cpp:     clan_table[ch->clan].roster.withdraw = points;
roster.cpp:     clan_table[ch->clan].roster.approve = FALSE;
roster.cpp:     clan_table[ch->clan].roster.requestor = str_dup(ch->name);
roster.cpp:    if (!IS_IMMORTAL(ch) && ch->rank < 4)
roster.cpp:    if ((member = find_member(name, ch->clan)) == NULL)
roster.cpp:      if (ch->clan == clan_lookup("Tinker"))
roster.cpp:      if ((rank - 1) >= ch->rank) 
roster.cpp:      if (rank - 1 >= ch->rank) 
roster.cpp:      for (i = 0; i < clan_table[ch->clan].top_gskill; i++)
roster.cpp:        if (!str_cmp(arg, clan_table[ch->clan].gskill[i]))
roster.cpp:    clan_table[ch->clan].roster.questpoints = points;
roster.cpp:    if (ch->level < MAX_LEVEL)
roster.cpp:  if ((mbr = find_member(ch->name, ch->clan)) == NULL)
roster.cpp:  if ((member = find_member(ch->name, ch->clan)) == NULL)
roster.cpp:  member->rp = ch->rplevel;  
roster.cpp:    remove_member(ch->name, ch->clan);
roster.cpp:    ch->clan = clan_lookup("Outcast");
roster.cpp:    ch->rank = 0;
roster.cpp:    ch->rank = rank - 1;
roster.cpp:    sprintf(buf, "You have been promoted to %s.\n\r", clan_table[ch->clan].rank[ch->rank]);
roster.cpp:    change_member(ch->name, rank, ch->clan);
roster.cpp:    ch->rank = rank - 1;
roster.cpp:    sprintf(buf, "You have been demoted to %s.\n\r", clan_table[ch->clan].rank[ch->rank]);
roster.cpp:    change_member(ch->name, rank, ch->clan);
roster.cpp:    ch->pcdata->learned[sn] = 75;
save.cpp:    if (ch->desc != NULL && ch->desc->original != NULL)
save.cpp:        ch = ch->desc->original;
save.cpp:    if (IS_IMMORTAL (ch) || ch->level >= LEVEL_IMMORTAL)
save.cpp:        sprintf (strsave, "%s%s", GOD_DIR, capitalize (ch->name));
save.cpp:                 ch->level, get_trust (ch), ch->name, ch->pcdata->title);
save.cpp:    sprintf (strsave, "%s%s", PLAYER_DIR, capitalize (IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name));
save.cpp:        if (ch->carrying != NULL)
save.cpp:            fwrite_obj (ch, ch->carrying, fp, 0);
save.cpp:  /*       if (ch->pet != NULL && ch->pet->in_room == ch->in_room)
save.cpp:            fwrite_pet (ch->pet, fp); */
save.cpp:        fwrite_rle(ch->pcdata->explored, fp);
save.cpp:        fwrite_rle(ch->pcdata->mobbed, fp);
save.cpp:    fprintf (fp, "Name %s~\n", IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name);
save.cpp:    fprintf (fp, "Id   %ld\n", ch->id);
save.cpp:    if (ch->short_descr[0] != '\0')
save.cpp:        fprintf (fp, "ShD  %s~\n", IS_DISGUISED(ch)?ch->pcdata->disguise.orig_short:ch->short_descr);
save.cpp:    if (ch->long_descr[0] != '\0')
save.cpp:        fprintf (fp, "LnD  %s~\n", IS_DISGUISED(ch)?ch->pcdata->disguise.orig_long:ch->long_descr);
save.cpp:    if (ch->description[0] != '\0')
save.cpp:        fprintf (fp, "Desc %s~\n", IS_DISGUISED(ch)?ch->pcdata->disguise.orig_desc:ch->description);
save.cpp:    if (ch->prompt != NULL || !str_cmp (ch->prompt, "<%hhp %mm %vmv> <%T>")
save.cpp:        || !str_cmp (ch->prompt, "{c<%hhp %mm %vmv>{x "))
save.cpp:        fprintf (fp, "Prom %s~\n", ch->prompt);
save.cpp:    fprintf (fp, "Host %s~\n", IS_SET(ch->act2, PLR_NOIP) ? "Unknown" : IS_NULLSTR(ch->pcdata->Host) ? "Missing" : ch->pcdata->Host); 
save.cpp:    fprintf (fp, "Race %s~\n", pc_race_table[ch->race].name);
save.cpp:    fprintf (fp, "XpMultFac %d\n", ch->pcdata->xpmultiplier.factor);
save.cpp:    fprintf (fp, "XpMultTim %d\n", ch->pcdata->xpmultiplier.time);
save.cpp:    if (ch->clan > 0)
save.cpp:        fprintf (fp, "Clan %s~\n", clan_table[ch->clan].name);
save.cpp:        fprintf (fp, "ClanN %d\n", ch->clan);
save.cpp:    fprintf (fp, "Rank %d\n", ch->rank);
save.cpp:    fprintf (fp, "Sex  %d\n", ch->sex);
save.cpp:    fprintf (fp, "Cla  %d\n", ch->cClass);
save.cpp:    fprintf (fp, "Murd %d\n", ch->penalty.murder);
save.cpp:    fprintf (fp, "Thief %d\n", ch->penalty.thief);
save.cpp:    fprintf (fp, "Jail %d\n", ch->penalty.jail);
save.cpp:    fprintf (fp, "Punish %d\n", ch->penalty.punishment);
save.cpp:    fprintf (fp, "Levl %d\n", ch->level);
save.cpp:    fprintf (fp, "BarO %d\n", ch->pcdata->barOn ? 1 : 0);
save.cpp:    fprintf (fp, "MinO %d\n", ch->pcdata->isMinion ? 1 : 0);
save.cpp:    fprintf (fp, "FontN %s~\n", ch->pcdata->fonts.notes);
save.cpp:    fprintf (fp, "FontR %s~\n", ch->pcdata->fonts.rpnote);
save.cpp:    fprintf (fp, "Stance %d\n", ch->pcdata->stance);
save.cpp:    fprintf (fp, "TKills %d\n", ch->pcdata->tournament.kills);
save.cpp:    fprintf (fp, "TDeaths %d\n", ch->pcdata->tournament.deaths);
save.cpp:    fprintf (fp, "TRep %d\n", ch->pcdata->tournament.reputation);
save.cpp:    fprintf (fp, "TRank %d\n", ch->pcdata->tournament.rank);
save.cpp:    fprintf (fp, "TLRank %d\n", ch->pcdata->tournament.last_rank);    
save.cpp:    fprintf (fp, "TLKill %ld\n", ch->pcdata->tournament.last_killed);    
save.cpp:    fprintf (fp, "Forsaken %s~\n", ch->pcdata->forsaken_master);
save.cpp:   if (ch->trust != 0)
save.cpp:        fprintf (fp, "Tru  %d\n", ch->trust);
save.cpp:    fprintf (fp, "Sec  %d\n", ch->pcdata->security);    /* OLC */
save.cpp:    if (ch->questpoints != 0)
save.cpp:        fprintf( fp, "QuestPnts %ld\n",  ch->questpoints );
save.cpp:        fprintf( fp, "GameTick %d\n", ch->gametick );
save.cpp:        fprintf( fp, "BrkTit %s~\n", ch->plaid );
save.cpp:        fprintf( fp, "RpLevel %d\n",  ch->rplevel );
save.cpp:        fprintf( fp, "RpExp   %d\n",  ch->rpexp );
save.cpp:	fprintf( fp, "RlExp   %d\n",  ch->realexp );
save.cpp:        fprintf( fp, "Simskill  %s~\n",  ch->simskill );
save.cpp:	fprintf (fp, "Mapsz %d\n", ch->mapsize);
save.cpp:    if (ch->nextquest != 0)
save.cpp:        fprintf( fp, "QuestNext %d\n",  ch->nextquest   );
save.cpp:    else if (ch->countdown != 0)
save.cpp:	fprintf(fp, "RP %d\n",ch->rp_points); /*RP POINTS*/
save.cpp:    fprintf (fp, "Plyd %d\n", ch->played + (int) (current_time -
save.cpp:ch->logon));
save.cpp:             ch->pcdata->last_note, ch->pcdata->last_idea,
save.cpp:             ch->pcdata->last_guildmaster, ch->pcdata->last_news,
save.cpp:             ch->pcdata->last_changes, ch->pcdata->last_imm,
save.cpp:             ch->pcdata->last_rp);
save.cpp:    fprintf (fp, "NoTG %ld\n", ch->pcdata->last_guide);
save.cpp:    fprintf (fp, "NoTS %ld\n", ch->pcdata->last_store);
save.cpp:              ch->pcdata->couple[i].cast,
save.cpp:              ch->pcdata->couple[i].couple);
save.cpp:              ch->pcdata->weaves[i]);
save.cpp:    fprintf (fp, "Scro %d\n", ch->lines);
save.cpp:    fprintf (fp, "Fame %d\n", ch->fame);
save.cpp:    fprintf (fp, "Honor %d\n", ch->honor);
save.cpp:    fprintf (fp, "Update %d\n", ch->update);
save.cpp:    if (!IS_NULLSTR(ch->pretit))	
save.cpp:      fprintf (fp, "Pretitle %s~\n", ch->pretit);
save.cpp:    fprintf (fp, "Room %ld\n", (ch->in_room == get_room_index (ROOM_VNUM_LIMBO)
save.cpp:                               && ch->was_in_room != NULL)
save.cpp:             ? ch->was_in_room->vnum
save.cpp:             : ch->in_room == NULL ? 3001 : ch->in_room->vnum);
save.cpp:             ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move,
save.cpp:             ch->max_move);
save.cpp:    if (ch->gold > 0)
save.cpp:        fprintf (fp, "Gold %ld\n", ch->gold);
save.cpp:    if (ch->silver > 0)
save.cpp:        fprintf (fp, "Silv %ld\n", ch->silver);
save.cpp:    fprintf( fp, "GoldB %ld", ch->gold_in_bank);
save.cpp:    fprintf( fp, "SilvB %ld", ch->silver_in_bank);
save.cpp:    fprintf (fp, "Exp  %d\n", ch->exp);
save.cpp:    if (ch->act != 0)
save.cpp:        fprintf (fp, "Act  %s\n", print_flags (ch->act));
save.cpp:    if (ch->act2 != 0)
save.cpp:        fprintf (fp, "Act2  %s\n", print_flags (ch->act2));
save.cpp:    if (!STR_IS_ZERO(ch->affected_by, AFF_FLAGS) )
save.cpp:        fprintf (fp, "AfBy %s\n", str_print_flags (ch->affected_by, AFF_FLAGS));
save.cpp:    fprintf (fp, "Comm %s\n", print_flags (ch->comm));
save.cpp:    if (ch->wiznet)
save.cpp:        fprintf (fp, "Wizn %s\n", print_flags (ch->wiznet));
save.cpp:    if (ch->invis_level)
save.cpp:        fprintf (fp, "Invi %d\n", ch->invis_level);
save.cpp:    if (ch->incog_level)
save.cpp:        fprintf (fp, "Inco %d\n", ch->incog_level);
save.cpp:             ch->position == POS_FIGHTING ? POS_STANDING : ch->position);
save.cpp:    if (ch->practice != 0)
save.cpp:        fprintf (fp, "Prac %d\n", ch->practice);
save.cpp:    if (ch->train != 0)
save.cpp:        fprintf (fp, "Trai %d\n", ch->train);
save.cpp:    if (ch->saving_throw != 0)
save.cpp:        fprintf (fp, "Save  %d\n", ch->saving_throw);
save.cpp:    fprintf (fp, "Alig  %d\n", ch->alignment);
save.cpp:    if (ch->hitroll != 0)
save.cpp:        fprintf (fp, "Hit   %d\n", ch->hitroll);
save.cpp:    if (ch->damroll != 0)
save.cpp:        fprintf (fp, "Dam   %d\n", ch->damroll);
save.cpp:             ch->armor[0], ch->armor[1], ch->armor[2], ch->armor[3]);
save.cpp:    if (ch->wimpy != 0)
save.cpp:        fprintf (fp, "Wimp  %d\n", ch->wimpy);
save.cpp:             ch->perm_stat[STAT_STR],
save.cpp:             ch->perm_stat[STAT_INT],
save.cpp:             ch->perm_stat[STAT_WIS],
save.cpp:             ch->perm_stat[STAT_DEX], ch->perm_stat[STAT_CON]);
save.cpp:             ch->mod_stat[STAT_STR],
save.cpp:             ch->mod_stat[STAT_INT],
save.cpp:             ch->mod_stat[STAT_WIS],
save.cpp:             ch->mod_stat[STAT_DEX], ch->mod_stat[STAT_CON]);
save.cpp:        fprintf (fp, "Vnum %ld\n", ch->pIndexData->vnum);
save.cpp:        fprintf (fp, "Pass %s~\n", ch->pcdata->pwd);
save.cpp:        if (ch->pcdata->bamfin[0] != '\0')
save.cpp:            fprintf (fp, "Bin  %s~\n", ch->pcdata->bamfin);
save.cpp:        if (ch->pcdata->bamfout[0] != '\0')
save.cpp:            fprintf (fp, "Bout %s~\n", ch->pcdata->bamfout);
save.cpp:        fprintf (fp, "Titl %s~\n", IS_DISGUISED(ch)?ch->pcdata->disguise.orig_title:ch->pcdata->title);
save.cpp:        fprintf (fp, "Pnts %d\n", ch->pcdata->points);
save.cpp:        fprintf (fp, "TSex %d\n", ch->pcdata->true_sex);
save.cpp:        fprintf (fp, "LLev %d\n", ch->pcdata->last_level);
save.cpp:        if (!IS_NULLSTR(ch->pcdata->account))
save.cpp:          fprintf (fp, "Account %s~\n", ch->pcdata->account);
save.cpp:        fprintf (fp, "HMVP %ld %d %d\n", ch->pcdata->perm_hit,
save.cpp:                 ch->pcdata->perm_mana, ch->pcdata->perm_move);
save.cpp:                 ch->pcdata->condition[0],
save.cpp:                 ch->pcdata->condition[1],
save.cpp:                 ch->pcdata->condition[2], 
save.cpp:		 ch->pcdata->condition[3]);
save.cpp:		fprintf (fp,"BldCND %d\n", ch->pcdata->condition[4]);
save.cpp:       /*if (ch->pcdata->rentroom != 0)
save.cpp:       fprintf( fp, "Rroom %d\n",  ch->pcdata->rentroom  );    Room Rental */  
save.cpp:            if (ch->pcdata->alias[pos] == NULL
save.cpp:                || ch->pcdata->alias_sub[pos] == NULL)
save.cpp:            fprintf (fp, "Alias %s %s~\n", ch->pcdata->alias[pos],
save.cpp:                     ch->pcdata->alias_sub[pos]);
save.cpp:            if (skill_table[sn].name != NULL && ch->pcdata->learned[sn] > 0)
save.cpp:                         ch->pcdata->learned[sn], skill_table[sn].name);
save.cpp:            if (group_table[gn].name != NULL && ch->pcdata->group_known[gn])
save.cpp:    fprintf( fp, "Granted %s~\n", ch->pcdata->granted );
save.cpp:    fprintf( fp, "Bond %s~\n", ch->pcdata->bond );
save.cpp:    for (paf = ch->affected; paf != NULL; paf = paf->next)
save.cpp:    for( names = ch->pcdata->names; names; names = names->next )
save.cpp:    for (QUEST_DATA *quest = ch->pcdata->quests; quest != NULL; quest = quest->next)
save.cpp:/*    if ((ch->level < obj->level - 2 && obj->item_type != ITEM_CONTAINER)
save.cpp:    ch->pcdata = new_pcdata ();
save.cpp:    ch->desc = d;
save.cpp:    ch->name = str_dup (name);
save.cpp:    ch->mount = NULL;
save.cpp:    ch->ireply = NULL;
save.cpp:    ch->oreply = NULL;
save.cpp:    ch->is_mounted = FALSE;
save.cpp:    ch->id = get_pc_id ();
save.cpp:    ch->race = race_lookup ("human");
save.cpp:    ch->act = PLR_NOSUMMON;
save.cpp:    SET_BIT(ch->act, PLR_AUTOEXIT);
save.cpp:    SET_BIT(ch->act, PLR_AUTOLOOT);
save.cpp:    SET_BIT(ch->act, PLR_AUTOSAC);
save.cpp:    SET_BIT(ch->act, PLR_AUTOGOLD);
save.cpp:    SET_BIT(ch->act, PLR_AUTOSPLIT);
save.cpp:    ch->comm = COMM_COMBINE | COMM_PROMPT;
save.cpp:    ch->prompt = str_dup ("<%hhp %mm %vmv> <%T>");
save.cpp:    ch->pretit = str_dup("");
save.cpp:    sprintf(ch->pcdata->explored, " ");
save.cpp:    ch->pcdata->primary = TRUE;
save.cpp:    ch->pcdata->damInflicted = 0;
save.cpp:    ch->pcdata->damReceived = 0;
save.cpp:    ch->pcdata->xpmultiplier.on = FALSE;
save.cpp:    ch->pcdata->xpmultiplier.factor = 0;
save.cpp:    ch->pcdata->confirm_delete = FALSE;
save.cpp:    ch->pcdata->confirm_pkon = FALSE;
save.cpp:    ch->pcdata->pwd = str_dup ("");
save.cpp:    ch->pcdata->bamfin = str_dup ("");
save.cpp:    ch->pcdata->bamfout = str_dup ("");
save.cpp:    ch->pcdata->account = str_dup("");
save.cpp:    ch->pcdata->title = str_dup ("");
save.cpp:    ch->pcdata->questroom = str_dup ("");
save.cpp:    ch->pcdata->questarea = str_dup ("");
save.cpp:    ch->pcdata->client = str_dup ("");
save.cpp:    ch->pcdata->clientVersion = str_dup ("");
save.cpp:    ch->pcdata->mxpVersion = str_dup ("");
save.cpp:    ch->pcdata->bond = str_dup ("");
save.cpp:    ch->pcdata->fonts.rpnote = str_dup ("lucida handwriting");
save.cpp:    ch->pcdata->fonts.notes = str_dup ("lucida handwriting");
save.cpp:    ch->pcdata->manadrainee = str_dup ("");
save.cpp:    ch->pcdata->last_guide = 0;
save.cpp:    ch->pcdata->last_store = 0;
save.cpp:    ch->pcdata->initiator = 0;
save.cpp:        ch->perm_stat[stat] = 13;
save.cpp:    ch->pcdata->condition[COND_THIRST] = 48;
save.cpp:    ch->pcdata->condition[COND_FULL] = 48;
save.cpp:    ch->pcdata->condition[COND_HUNGER] = 48;
save.cpp:    ch->pcdata->condition[COND_GOBLIND] = 0;
save.cpp:    ch->pcdata->condition[COND_HORNY] = 30;
save.cpp:    ch->pcdata->stance                  = 0;
save.cpp:	ch->pcdata->condition[COND_BLEEDING] = 0;
save.cpp:    ch->pcdata->names = NULL;
save.cpp:      ch->pcdata->couple[i].cast = 0;
save.cpp:      ch->pcdata->couple[i].couple = 0;
save.cpp:      ch->pcdata->weaves[i] = 2;
save.cpp:    ch->mapsize = 15;
save.cpp:    ch->pcdata->security = 0;    /* OLC */
save.cpp:    ch->pcdata->granted = str_dup("none");
save.cpp:    ch->pcdata->forsaken_master = str_dup("");
save.cpp:    ch->pcdata->ignore = str_dup("");
save.cpp:    ch->pcdata->isMinion = FALSE;
save.cpp:      SET_BIT(ch->act2, PLR_MXP);
save.cpp:    ch->pcdata->barOn = TRUE;
save.cpp:    ch->pcdata->tournament.reputation = 0;
save.cpp:    ch->pcdata->tournament.deaths = 0;
save.cpp:    ch->pcdata->tournament.kills = 0;
save.cpp:    ch->pcdata->tournament.rank = 0;
save.cpp:    ch->pcdata->tournament.last_rank = 0;
save.cpp:    ch->pcdata->tournament.last_killed = 0;
save.cpp:                fread_rle (ch->pcdata->explored, fp);
save.cpp:                fread_rle (ch->pcdata->mobbed, fp);
save.cpp:        if (ch->race == 0)
save.cpp:            ch->race = race_lookup ("human");
save.cpp:        ch->size = pc_race_table[ch->race].size;
save.cpp:        ch->dam_type = 17;        /*punch */
save.cpp:            if (pc_race_table[ch->race].skills[i] == NULL)
save.cpp:            group_add (ch, pc_race_table[ch->race].skills[i], FALSE);
save.cpp:        STR_OR_STR( ch->affected_by, race_table[ch->race].aff, AFF_FLAGS);
save.cpp:        ch->imm_flags = ch->imm_flags | race_table[ch->race].imm;
save.cpp:        ch->res_flags = ch->res_flags | race_table[ch->race].res;
save.cpp:        ch->vuln_flags = ch->vuln_flags | race_table[ch->race].vuln;
save.cpp:        ch->form = race_table[ch->race].form;
save.cpp:        ch->parts = race_table[ch->race].parts;
save.cpp:    if (found && ch->version < 2)
save.cpp:        group_add (ch, class_table[ch->cClass].base_group, FALSE);
save.cpp:        group_add (ch, class_table[ch->cClass].default_group, TRUE);
save.cpp:        ch->pcdata->learned[gsn_recall] = 50;
save.cpp:    if (found && ch->version < 3 && (ch->level > 35 || ch->trust > 35))
save.cpp:        switch (ch->level)
save.cpp:                ch->level = 60;
save.cpp:                ch->level = 58;
save.cpp:                ch->level = 56;
save.cpp:                ch->level = 53;
save.cpp:        switch (ch->trust)
save.cpp:                ch->trust = 60;
save.cpp:                ch->trust = 58;
save.cpp:                ch->trust = 56;
save.cpp:                ch->trust = 53;
save.cpp:                ch->trust = 51;
save.cpp:    if (found && ch->version < 4)
save.cpp:        ch->gold /= 100;
save.cpp:      REMOVE_BIT(ch->act2, PLR_MXP); 
save.cpp:    sprintf (buf, "Loading %s.", ch->name);
save.cpp:                KEYS ("Account", ch->pcdata->account, fread_string(fp));
save.cpp:                KEY ("Act", ch->act, fread_flag (fp));
save.cpp:                KEY ("Act2", ch->act2, fread_flag (fp));
save.cpp:                KEY ("Alignment", ch->alignment, fread_number (fp));
save.cpp:                KEY ("Alig", ch->alignment, fread_number (fp));
save.cpp:                if ( ch->version < 6)
save.cpp:                   KEYF("AffectedBy", ch->affected_by, 
save.cpp:                   KEYF("AfBy", ch->affected_by, 
save.cpp:		  KEYF("AfBy", ch->affected_by, str_fread_flag(fp, AFF_FLAGS),
save.cpp:                    ch->pcdata->alias[count] = str_dup (fread_word (fp));
save.cpp:                    ch->pcdata->alias_sub[count] = str_dup (fread_word (fp));
save.cpp:                    ch->pcdata->alias[count] = str_dup (fread_word (fp));
save.cpp:                    ch->pcdata->alias_sub[count] = fread_string (fp);
save.cpp:                        ch->armor[i] = fread_number (fp);
save.cpp:                    paf->next = ch->affected;
save.cpp:                    ch->affected = paf;
save.cpp:                    paf->next = ch->affected;
save.cpp:                    ch->affected = paf;
save.cpp:                        ch->mod_stat[stat] = fread_number (fp);
save.cpp:                        ch->perm_stat[stat] = fread_number (fp);
save.cpp:                KEY ("Bamfin", ch->pcdata->bamfin, fread_string (fp));
save.cpp:                KEY ("Bamfout", ch->pcdata->bamfout, fread_string (fp));
save.cpp:                KEY ("Bin", ch->pcdata->bamfin, fread_string (fp));
save.cpp:                KEY ("Bout", ch->pcdata->bamfout, fread_string (fp));
save.cpp:                KEY ("BrkTit", ch->plaid, fread_string (fp));
save.cpp:                KEY ("Bond", ch->pcdata->bond, fread_string (fp));
save.cpp:                  ch->pcdata->barOn = TRUE;
save.cpp:                    ch->pcdata->barOn = FALSE;
save.cpp:				KEY ("BldCND", ch->pcdata->condition[COND_BLEEDING], fread_number (fp));
save.cpp:                KEY ("Crim", ch->penalty.thief, fread_number (fp));
save.cpp:                KEY ("Class", ch->cClass, fread_number (fp));
save.cpp:                KEY ("Cla", ch->cClass, fread_number (fp));
save.cpp:                KEY ("Comm", ch->comm, fread_flag (fp));
save.cpp:                    ch->pcdata->couple[i].cast = fread_number(fp);
save.cpp:                    ch->pcdata->couple[i].couple = fread_number(fp);
save.cpp:    		  ch->clan = clan_lookup(tmp);
save.cpp:    		  ch->clan = fread_number(fp);
save.cpp:                    ch->pcdata->condition[COND_DRUNK] = fread_number (fp);
save.cpp:                    ch->pcdata->condition[COND_FULL] = fread_number (fp);
save.cpp:                    ch->pcdata->condition[COND_THIRST] = fread_number (fp);
save.cpp:					ch->pcdata->condition[COND_HUNGER] = fread_number (fp);
save.cpp:                    ch->pcdata->condition[COND_DRUNK] = fread_number (fp);
save.cpp:                    ch->pcdata->condition[COND_FULL] = fread_number (fp);
save.cpp:                    ch->pcdata->condition[COND_THIRST] = fread_number (fp);
save.cpp:                    ch->pcdata->condition[COND_HUNGER] = fread_number (fp);
save.cpp:                KEY ("Damroll", ch->damroll, fread_number (fp));
save.cpp:                KEY ("Dam", ch->damroll, fread_number (fp));
save.cpp:                KEY ("Description", ch->description, fread_string (fp));
save.cpp:                KEY ("Desc", ch->description, fread_string (fp));
save.cpp:                        ch->hit += (ch->max_hit - ch->hit) * percent / 100;
save.cpp:                        ch->mana += (ch->max_mana - ch->mana) * percent / 100;
save.cpp:                        ch->move += (ch->max_move - ch->move) * percent / 100;
save.cpp:                KEY ("Exp", ch->exp, fread_number (fp));
save.cpp:                KEY ("Forsaken", ch->pcdata->forsaken_master, fread_string (fp));
save.cpp:		KEY ("Fame", ch->fame, fread_number (fp));
save.cpp:		KEY ("FontN", ch->pcdata->fonts.notes, fread_string (fp));
save.cpp:		KEY ("FontR", ch->pcdata->fonts.rpnote, fread_string (fp));
save.cpp:                KEY ("GameTick", ch->gametick, fread_number (fp));
save.cpp:                KEY ("Gold", ch->gold, fread_number (fp));
save.cpp:                KEY ("GoldB", ch->gold_in_bank, fread_number (fp));
save.cpp:                KEY ("Granted", ch->pcdata->granted, fread_string (fp));
save.cpp:                KEY ("Hitroll", ch->hitroll, fread_number (fp));
save.cpp:                KEY ("Hit", ch->hitroll, fread_number (fp));
save.cpp:                    ch->hit = fread_long (fp);
save.cpp:                    ch->max_hit = fread_long (fp);
save.cpp:                    ch->mana = fread_number (fp);
save.cpp:                    ch->max_mana = fread_number (fp);
save.cpp:                    ch->move = fread_number (fp);
save.cpp:                    ch->max_move = fread_number (fp);
save.cpp:                    ch->pcdata->perm_hit = fread_number (fp);
save.cpp:                    ch->pcdata->perm_mana = fread_number (fp);
save.cpp:                    ch->pcdata->perm_move = fread_number (fp);
save.cpp:                KEY ("Honor", ch->honor, fread_number (fp));
save.cpp:                if (ch->honor < 0){ch->honor = 0;}
save.cpp:                KEY ("Id", ch->id, fread_number (fp));
save.cpp:                KEY ("InvisLevel", ch->invis_level, fread_number (fp));
save.cpp:                KEY ("Inco", ch->incog_level, fread_number (fp));
save.cpp:                KEY ("Invi", ch->invis_level, fread_number (fp));
save.cpp:                KEY ("Jail", ch->penalty.jail, fread_number (fp));
save.cpp:                KEY ("LastLevel", ch->pcdata->last_level, fread_number (fp));
save.cpp:                KEY ("LLev", ch->pcdata->last_level, fread_number (fp));
save.cpp:                KEY ("Level", ch->level, fread_number (fp));
save.cpp:                KEY ("Lev", ch->level, fread_number (fp));
save.cpp:                KEY ("Levl", ch->level, fread_number (fp));
save.cpp:                KEY ("LongDescr", ch->long_descr, fread_string (fp));
save.cpp:                KEY ("LnD", ch->long_descr, fread_string (fp));
save.cpp:		KEY ("Mapsz", ch->mapsize, fread_number (fp));
save.cpp:                KEY ("Murd", ch->penalty.murder, fread_number (fp));
save.cpp:                  ch->pcdata->isMinion = TRUE;
save.cpp:                    ch->pcdata->isMinion = FALSE;
save.cpp:                KEYS ("Name", ch->name, fread_string (fp));
save.cpp:                KEY ("Note", ch->pcdata->last_note, fread_number (fp));
save.cpp:                    ch->pcdata->last_note = fread_number (fp);
save.cpp:                    ch->pcdata->last_idea = fread_number (fp);
save.cpp:                    ch->pcdata->last_guildmaster = fread_number (fp);
save.cpp:                    ch->pcdata->last_news = fread_number (fp);
save.cpp:                    ch->pcdata->last_changes = fread_number (fp);
save.cpp:                    ch->pcdata->last_imm = fread_number(fp);
save.cpp:                    ch->pcdata->last_rp = fread_number(fp);
save.cpp:                    ch->pcdata->last_guide = fread_number(fp);
save.cpp:                    ch->pcdata->last_store = fread_number(fp);
save.cpp:                KEY ("Pretitle", ch->pretit, fread_string (fp));
save.cpp:                KEY ("Password", ch->pcdata->pwd, fread_string (fp));
save.cpp:                KEY ("Pass", ch->pcdata->pwd, fread_string (fp));
save.cpp:                KEY ("Played", ch->played, fread_number (fp));
save.cpp:                KEY ("Plyd", ch->played, fread_number (fp));
save.cpp:                KEY ("Points", ch->pcdata->points, fread_number (fp));
save.cpp:                KEY ("Pnts", ch->pcdata->points, fread_number (fp));
save.cpp:                KEY ("Position", ch->position, fread_number (fp));
save.cpp:                KEY ("Pos", ch->position, fread_number (fp));
save.cpp:                KEY ("Punish", ch->penalty.punishment, fread_number(fp));
save.cpp:                KEY ("Practice", ch->practice, fread_number (fp));
save.cpp:                KEY ("Prac", ch->practice, fread_number (fp));
save.cpp:                KEYS ("Prompt", ch->prompt, fread_string (fp));
save.cpp:                KEYS ("Prom", ch->prompt, fread_string (fp));
save.cpp:            KEY( "QuestPnts",   ch->questpoints,        fread_number( fp) );
save.cpp:            KEY( "QuestNext",   ch->nextquest,          fread_number( fp) );
save.cpp:                  quest->next = ch->pcdata->quests;
save.cpp:                  ch->pcdata->quests = quest;
save.cpp:                KEY ("RpExp", ch->rpexp, fread_number( fp) );
save.cpp:		KEY ("RlExp", ch->realexp, fread_number( fp) );
save.cpp:                KEY ("RpLevel", ch->rplevel, fread_number( fp) );
save.cpp:                KEY ("Rank", ch->rank, fread_number( fp) );
save.cpp:	//	KEY( "Rroom",    ch->pcdata->rentroom,  fread_number( fp ) );    room rental
save.cpp:     		  ch->race = race_lookup(tmp);
save.cpp:                    ch->in_room = get_room_index (fread_number (fp));
save.cpp:                    if (ch->in_room == NULL)
save.cpp:                        ch->in_room = get_room_index (ROOM_VNUM_LIMBO);
save.cpp:				KEY ("RP", ch->rp_points, fread_number(fp));
save.cpp:                KEY ("SavingThrow", ch->saving_throw, fread_number (fp));
save.cpp:                KEY ("Save", ch->saving_throw, fread_number (fp));
save.cpp:                KEY ("Scro", ch->lines, fread_number (fp));
save.cpp:                KEY ("Sex", ch->sex, fread_number (fp));
save.cpp:                KEY ("ShortDescr", ch->short_descr, fread_string (fp));
save.cpp:                KEY ("ShD", ch->short_descr, fread_string (fp));
save.cpp:                KEY ("Sec", ch->pcdata->security, fread_number (fp));    /* OLC */
save.cpp:                KEY ("Silv", ch->silver, fread_number (fp));
save.cpp:                KEY ("SilvB", ch->silver_in_bank, fread_number (fp));
save.cpp:                KEY ("Simskill", ch->simskill, fread_string (fp));
save.cpp:		KEY ("Stance", ch->pcdata->stance, fread_number( fp ) );
save.cpp:                        ch->pcdata->learned[sn] = value;
save.cpp:                KEY ("TrueSex", ch->pcdata->true_sex, fread_number (fp));
save.cpp:                KEY ("TSex", ch->pcdata->true_sex, fread_number (fp));
save.cpp:                KEY ("Trai", ch->train, fread_number (fp));
save.cpp:                KEY ("Trust", ch->trust, fread_number (fp));
save.cpp:                KEY ("Tru", ch->trust, fread_number (fp));
save.cpp:                KEY ("TKills", ch->pcdata->tournament.kills, fread_number(fp));
save.cpp:                KEY ("TDeaths", ch->pcdata->tournament.deaths, fread_number(fp));
save.cpp:                KEY ("TRep", ch->pcdata->tournament.reputation, fread_number(fp));
save.cpp:                KEY ("TRank", ch->pcdata->tournament.rank, fread_number(fp));
save.cpp:                KEY ("TLRank", ch->pcdata->tournament.last_rank, fread_number(fp));
save.cpp:                KEY ("TLKill", ch->pcdata->tournament.last_killed, fread_number(fp));
save.cpp:                KEY ("Thief", ch->penalty.thief,fread_number(fp));
save.cpp:                    ch->pcdata->title = fread_string (fp);
save.cpp:                    if (ch->pcdata->title[0] != '.'
save.cpp:                        && ch->pcdata->title[0] != ','
save.cpp:                        && ch->pcdata->title[0] != '!'
save.cpp:                        && ch->pcdata->title[0] != '?')
save.cpp:                        sprintf (buf, " %s", ch->pcdata->title);
save.cpp:                        free_string (ch->pcdata->title);
save.cpp:                        ch->pcdata->title = str_dup (buf);
save.cpp:                KEY ("Update", ch->update, fread_number (fp));
save.cpp:                KEY ("Version", ch->version, fread_number (fp));
save.cpp:                KEY ("Vers", ch->version, fread_number (fp));
save.cpp:                    ch->pIndexData = get_mob_index (fread_number (fp));
save.cpp:                KEY ("Wimpy", ch->wimpy, fread_number (fp));
save.cpp:                KEY ("Wimp", ch->wimpy, fread_number (fp));
save.cpp:                KEY ("Wizn", ch->wiznet, fread_flag (fp));
save.cpp:                    ch->pcdata->weaves[i] = fread_number(fp);
save.cpp:                  ch->pcdata->xpmultiplier.on = TRUE;
save.cpp:                  ch->pcdata->xpmultiplier.factor = fread_number(fp);
save.cpp:                  ch->pcdata->xpmultiplier.on = TRUE;
save.cpp:                  ch->pcdata->xpmultiplier.time = fread_number(fp);
save.cpp:                if (ch->version < 6)
save.cpp:                    ch->pet = pet;
scan.cpp:        scan_list (ch->in_room, ch, 0, -1);
scan.cpp:            if ((pExit = ch->in_room->exit[door]) != NULL)
scan.cpp:    scan_room = ch->in_room;
scan.cpp:    for (rch = scan_room->people; rch != NULL; rch = rch->next_in_room)
scan.cpp:        if (!IS_NPC (rch) && rch->invis_level > get_trust (ch))
skills.cpp:    for (trainer = ch->in_room->people;
skills.cpp:            if (!ch->pcdata->group_known[gn]
skills.cpp:                && group_table[gn].rating[ch->cClass] > 0)
skills.cpp:                         ch->level >= LEVEL_HERO ?
skills.cpp:                            group_table[gn].rating[ch->cClass] / 2 :
skills.cpp:                            group_table[gn].rating[ch->cClass]);
skills.cpp:            if (!ch->pcdata->learned[sn]
skills.cpp:                && skill_table[sn].rating[ch->cClass] > 0
skills.cpp:                         ch->level >= LEVEL_HERO ?
skills.cpp:                            skill_table[sn].rating[ch->cClass] / 2 :
skills.cpp:                            skill_table[sn].rating[ch->cClass]);
skills.cpp:        if (ch->practice < 10)
skills.cpp:        ch->practice -= 10;
skills.cpp:        ch->train += 1;
skills.cpp:        if (ch->train < 1)
skills.cpp:        ch->practice += 10;
skills.cpp:        ch->train -= 1;
skills.cpp:        if (ch->train < 2)
skills.cpp:        if (ch->pcdata->points <= 40)
skills.cpp:        ch->train -= 2;
skills.cpp:        ch->pcdata->points -= 1;
skills.cpp:        ch->exp = exp_per_level (ch, ch->pcdata->points) * ch->level;
skills.cpp:        if (ch->pcdata->group_known[gn])
skills.cpp:        if (group_table[gn].rating[ch->cClass] <= 0)
skills.cpp:        if ((ch->train < group_table[gn].rating[ch->cClass] && 
skills.cpp:	      ch->level < LEVEL_HERO) ||
skills.cpp:              (ch->train < group_table[gn].rating[ch->cClass] / 2))  
skills.cpp:        ch->train -= ch->level < LEVEL_HERO ? 
skills.cpp:                         group_table[gn].rating[ch->cClass] :
skills.cpp:                         group_table[gn].rating[ch->cClass] / 2;
skills.cpp:        if (ch->pcdata->learned[sn])
skills.cpp:        if (skill_table[sn].rating[ch->cClass] <= 0)
skills.cpp:        if ((ch->train < skill_table[sn].rating[ch->cClass] &&
skills.cpp:             ch->level < LEVEL_HERO) ||
skills.cpp:             (ch->train < skill_table[sn].rating[ch->cClass] / 2))
skills.cpp:        ch->pcdata->learned[sn] = 1;
skills.cpp:        ch->train -= ch->level < LEVEL_HERO ?
skills.cpp:                      skill_table[sn].rating[ch->cClass] :
skills.cpp:                      skill_table[sn].rating[ch->cClass] / 2;
skills.cpp:        if ((level = skill_table[sn].skill_level[ch->cClass]) < LEVEL_HERO + 1
skills.cpp:            && ((fAll && level <= MAX_LEVEL - 4) || level <= ch->level)
skills.cpp:            && ch->pcdata->learned[sn] > 0 &&
skills.cpp:            level = skill_table[sn].skill_level[ch->cClass];
skills.cpp:            if (ch->level < level)
skills.cpp:                             100 / (2 + ch->level - level));
skills.cpp:        if ((level = skill_table[sn].skill_level[ch->cClass]) < LEVEL_HERO + 1
skills.cpp:            && (fAll || level <= ch->level)
skills.cpp:            && ch->pcdata->learned[sn] > 0)
skills.cpp:            level = skill_table[sn].skill_level[ch->cClass];
skills.cpp:            if (ch->level < level)
skills.cpp:                         ch->pcdata->learned[sn]);
skills.cpp:        if (!ch->gen_data->group_chosen[gn]
skills.cpp:            && !ch->pcdata->group_known[gn]
skills.cpp:            && group_table[gn].rating[ch->cClass] > 0)
skills.cpp:                     group_table[gn].rating[ch->cClass]);
skills.cpp:        if (!ch->gen_data->skill_chosen[sn]
skills.cpp:            && ch->pcdata->learned[sn] == 0
skills.cpp:            && skill_table[sn].rating[ch->cClass] > 0)
skills.cpp:                     skill_table[sn].rating[ch->cClass]);
skills.cpp:    sprintf (buf, "Creation points: %d\n\r", ch->pcdata->points);
skills.cpp:             exp_per_level (ch, ch->gen_data->points_chosen));
skills.cpp:        if (ch->gen_data->group_chosen[gn]
skills.cpp:            && group_table[gn].rating[ch->cClass] > 0)
skills.cpp:                     group_table[gn].rating[ch->cClass]);
skills.cpp:        if (ch->gen_data->skill_chosen[sn]
skills.cpp:            && skill_table[sn].rating[ch->cClass] > 0)
skills.cpp:                     skill_table[sn].rating[ch->cClass]);
skills.cpp:    sprintf (buf, "Creation points: %d\n\r", ch->gen_data->points_chosen);
skills.cpp:             exp_per_level (ch, ch->gen_data->points_chosen));
skills.cpp:        return 2000 * (pc_race_table[ch->race].class_mult[ch->cClass] ?
skills.cpp:                       pc_race_table[ch->race].class_mult[ch->cClass] /
skills.cpp:    return expl * pc_race_table[ch->race].class_mult[ch->cClass] / 100;
skills.cpp:            if (ch->gen_data->group_chosen[gn] || ch->pcdata->group_known[gn])
skills.cpp:            if (group_table[gn].rating[ch->cClass] < 1)
skills.cpp:            if (ch->gen_data->points_chosen +
skills.cpp:                group_table[gn].rating[ch->cClass] > 300)
skills.cpp:            ch->gen_data->group_chosen[gn] = TRUE;
skills.cpp:            ch->gen_data->points_chosen += group_table[gn].rating[ch->cClass];
skills.cpp:            ch->pcdata->points += group_table[gn].rating[ch->cClass];
skills.cpp:            if (ch->gen_data->skill_chosen[sn] || ch->pcdata->learned[sn] > 0)
skills.cpp:            if (skill_table[sn].rating[ch->cClass] < 1
skills.cpp:		|| skill_table[sn].rating[ch->cClass] < 0)
skills.cpp:            if (ch->gen_data->points_chosen +
skills.cpp:                skill_table[sn].rating[ch->cClass] > 300)
skills.cpp:            ch->gen_data->skill_chosen[sn] = TRUE;
skills.cpp:            ch->gen_data->points_chosen += skill_table[sn].rating[ch->cClass];
skills.cpp:            ch->pcdata->learned[sn] = 1;
skills.cpp:            ch->pcdata->points += skill_table[sn].rating[ch->cClass];
skills.cpp:        if (gn != -1 && ch->gen_data->group_chosen[gn])
skills.cpp:            ch->gen_data->group_chosen[gn] = FALSE;
skills.cpp:            ch->gen_data->points_chosen -= group_table[gn].rating[ch->cClass];
skills.cpp:                if (ch->gen_data->group_chosen[gn])
skills.cpp:            ch->pcdata->points -= group_table[gn].rating[ch->cClass];
skills.cpp:        if (sn != -1 && ch->gen_data->skill_chosen[sn])
skills.cpp:            ch->gen_data->skill_chosen[sn] = FALSE;
skills.cpp:            ch->gen_data->points_chosen -= skill_table[sn].rating[ch->cClass];
skills.cpp:            ch->pcdata->learned[sn] = 0;
skills.cpp:            ch->pcdata->points -= skill_table[sn].rating[ch->cClass];
skills.cpp:            if (ch->pcdata->group_known[gn])
skills.cpp:        sprintf (buf, "Creation points: %d\n\r", ch->pcdata->points);
skills.cpp:(skill_table[skill_lookup(group_table[gn].spells[sn])].rating[ch->cClass] <
skills.cpp:    if (ch->level < skill_table[sn].skill_level[ch->cClass]
skills.cpp:        || skill_table[sn].rating[ch->cClass] == 0
skills.cpp:        || ch->pcdata->learned[sn] == 0 || ch->pcdata->learned[sn] == 100)
skills.cpp:    chance /= (multiplier * abs(skill_table[sn].rating[ch->cClass]) * 4);
skills.cpp:    chance += ch->level;
skills.cpp:        chance = URANGE (5, 100 - ch->pcdata->learned[sn], 95);
skills.cpp:            ch->pcdata->learned[sn]++;
skills.cpp:                     skill_table[sn].name, ch->pcdata->learned[sn]);
skills.cpp:            gain_exp (ch, 2 * abs(skill_table[sn].rating[ch->cClass]));
skills.cpp:        chance = URANGE (5, ch->pcdata->learned[sn] / 2, 30);
skills.cpp:            ch->pcdata->learned[sn] += number_range (1, 3);
skills.cpp:            ch->pcdata->learned[sn] = UMIN (ch->pcdata->learned[sn], 100);
skills.cpp:                     skill_table[sn].name, ch->pcdata->learned[sn]);
skills.cpp:            gain_exp (ch, 2 * abs(skill_table[sn].rating[ch->cClass]));
skills.cpp:    ch->pcdata->group_known[gn] = TRUE;
skills.cpp:    ch->pcdata->group_known[gn] = FALSE;
skills.cpp:        if (ch->pcdata->learned[sn] == 0)
skills.cpp:            ch->pcdata->learned[sn] = 1;
skills.cpp:                ch->pcdata->points += skill_table[sn].rating[ch->cClass];
skills.cpp:        if (ch->pcdata->group_known[gn] == FALSE)
skills.cpp:            ch->pcdata->group_known[gn] = TRUE;
skills.cpp:                ch->pcdata->points += group_table[gn].rating[ch->cClass];
skills.cpp:        ch->pcdata->learned[sn] = 0;
skills.cpp:    if (gn != -1 && ch->pcdata->group_known[gn] == TRUE)
skills.cpp:        ch->pcdata->group_known[gn] = FALSE;
special.cpp:  if ( ch->fighting == NULL)
special.cpp:  if (number_bits(3) == 0 && ch->rescuer && !IS_NULLSTR(ch->rescuer->name))
special.cpp:    sprintf(buf, "Help me %s, you're my only hope.", ch->rescuer->name);
special.cpp:    if ( ch->fighting != NULL )
special.cpp:    for ( victim = ch->in_room->people; victim != NULL; victim = victim->next_in_room)
special.cpp:    if ( victim->level > ch->level + 7 || IS_NPC(victim))
special.cpp:    if (!IS_AWAKE (ch) || IS_AFFECTED (ch, AFF_CALM) || ch->in_room == NULL
special.cpp:        || IS_AFFECTED (ch, AFF_CHARM) || ch->fighting != NULL)
special.cpp:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
special.cpp:        if (vch->pIndexData->vnum == MOB_VNUM_PATROLMAN)
special.cpp:        if (vch->pIndexData->group == GROUP_VNUM_OGRES
special.cpp:            && ch->level > vch->level - 2 && !is_safe (ch, vch))
special.cpp:    if (!IS_AWAKE (ch) || IS_AFFECTED (ch, AFF_CALM) || ch->in_room == NULL
special.cpp:        || IS_AFFECTED (ch, AFF_CHARM) || ch->fighting != NULL)
special.cpp:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
special.cpp:        if (vch->pIndexData->vnum == MOB_VNUM_PATROLMAN)
special.cpp:        if (vch->pIndexData->group == GROUP_VNUM_TROLLS
special.cpp:            && ch->level > vch->level - 2 && !is_safe (ch, vch))
special.cpp:    if (!IS_AWAKE (ch) || IS_AFFECTED (ch, AFF_CALM) || ch->in_room == NULL
special.cpp:        || IS_AFFECTED (ch, AFF_CHARM) || ch->fighting != NULL)
special.cpp:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
special.cpp:        if (vch->fighting != NULL)
special.cpp:                victim = (vch->level > vch->fighting->level)
special.cpp:                    ? vch : vch->fighting;
special.cpp:            && victim->spec_fun == ch->spec_fun)) return FALSE;
special.cpp:        for (vch = char_list; vch != NULL; vch = vch->next)
special.cpp:            if (vch->in_room == NULL)
special.cpp:            if (vch->in_room != ch->in_room
special.cpp:                && vch->in_room->area == ch->in_room->area)
special.cpp:    if (ch->position != POS_FIGHTING)
special.cpp:        for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.cpp:                && (victim->level > ch->level)
special.cpp:                && (victim->level < ch->level + 10))
special.cpp:                if (ch->position != POS_FIGHTING)
special.cpp:    if ((victim = ch->fighting) == NULL)
special.cpp:            ch->gold += gold;
special.cpp:    if (ch->position != POS_FIGHTING)
special.cpp:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.cpp:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, victim, TARGET_CHAR);
special.cpp:    if (ch->position != POS_FIGHTING)
special.cpp:    if (ch->position != POS_FIGHTING)
special.cpp:    if (ch->position != POS_FIGHTING)
special.cpp:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, NULL, TARGET_CHAR);
special.cpp:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.cpp:            spell_armor (skill_lookup ("armor"), ch->level, ch, victim,
special.cpp:            spell_bless (skill_lookup ("bless"), ch->level, ch, victim,
special.cpp:            spell_cure_blindness (skill_lookup ("cure blindness"), ch->level,
special.cpp:            spell_cure_light (skill_lookup ("cure light"), ch->level, ch,
special.cpp:            spell_cure_poison (skill_lookup ("cure poison"), ch->level, ch,
special.cpp:            spell_refresh (skill_lookup ("refresh"), ch->level, ch, victim,
special.cpp:            spell_cure_disease (skill_lookup ("cure disease"), ch->level, ch,
special.cpp:    if (ch->position != POS_FIGHTING)
special.cpp:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.cpp:        if (ch->level >= min_level)
special.cpp:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, victim, TARGET_CHAR);
special.cpp:    if (ch->position != POS_FIGHTING)
special.cpp:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.cpp:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, victim, TARGET_CHAR);
special.cpp:    if (ch->position != POS_FIGHTING)
special.cpp:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.cpp:        if (ch->level >= min_level)
special.cpp:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, victim, TARGET_CHAR);
special.cpp://    logf("Illuminator called by %s", ch->short_descr);
special.cpp:    if (ch->position != POS_FIGHTING)
special.cpp:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.cpp:        if (ch->level >= min_level)
special.cpp:     bomb = create_object(get_obj_index(DUMMY_BOMB), ch->level);
special.cpp:     bomb->level = ch->level;
special.cpp:     bomb->value[3] = bomb_table[bombNumber].avedam + (ch->level * 3) + number_range(1, 50);
special.cpp:     bomb->owner = str_dup(ch->name);
special.cpp:         (number_percent() > 3 * UMIN(ch->level * 2, 100) / 4))
special.cpp:    if (ch->position != POS_FIGHTING)
special.cpp:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.cpp:        if (ch->level >= min_level)
special.cpp:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, victim, TARGET_CHAR);
special.cpp:    if (!IS_AWAKE (ch) || ch->fighting != NULL)
special.cpp:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.cpp:    for (corpse = ch->in_room->contents; corpse != NULL; corpse = c_next)
special.cpp:            obj_to_room (obj, ch->in_room);
special.cpp:    if (!IS_AWAKE (ch) || ch->fighting != NULL)
special.cpp:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.cpp:    for (trash = ch->in_room->contents; trash != NULL; trash = trash_next)
special.cpp:    if (ch->fighting != NULL)
special.cpp:    if (!move || ch->position < POS_SLEEPING)
special.cpp:            ch->position = POS_STANDING;
special.cpp:            ch->position = POS_SLEEPING;
special.cpp:    if (ch->position != POS_FIGHTING
special.cpp:        || (victim = ch->fighting) == NULL
special.cpp:        || number_percent () > ch->level * 5) return FALSE;
special.cpp:    spell_poison (gsn_poison, ch->level, ch, victim, TARGET_CHAR);
special.cpp:    if (ch->position != POS_STANDING
special.cpp:       ||IS_SET (ch->in_room->room_flags, ROOM_SAFE))
special.cpp:    for (victim = ch->in_room->people; victim != NULL; victim = v_next)
special.cpp:        if (IS_AWAKE (victim) && number_range (0, ch->level) == 0)
special.cpp:                                     ch->level / 2) / 100;
special.cpp:            gold = UMIN (gold, ch->level * ch->level * 10);
special.cpp:            ch->gold += gold;
special.cpp:                                       ch->level / 2) / 100;
special.cpp:            silver = UMIN (silver, ch->level * ch->level * 25);
special.cpp:            ch->silver += silver;
special.cpp:  if (ch->fighting != NULL) 
stores.cpp:    if (!str_cmp (store->owner, IS_DISGUISED(ch)?ch->pcdata->disguise.orig_name:ch->name))
stores.cpp:      if (ch->clan > 0 && ch->rank > clan_table[ch->clan].top_rank - 2)
stores.cpp:    if (!IS_SET(ch->in_room->room_flags, ROOM_EMPTY_STORE))
stores.cpp:    else if (!guild && ch->questpoints < 1000)
stores.cpp:    else if (guild && clan_table[ch->clan].roster.questpoints < 2000)
stores.cpp:      ch->desc->editor = ED_STORE;
stores.cpp:      ch->desc->pEdit = store;
stores.cpp:    if (ch->silver + 100 * ch->gold < dues)
stores.cpp:  ch->desc->editor = ED_STORE;
stores.cpp:  ch->desc->pEdit = store;
stores.cpp:    ch->desc->editor = ED_NONE;
stores.cpp:    string_append( ch, &ch->in_room->description );
stores.cpp:  SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED);
stores.cpp:  ch->questpoints += total;
stores.cpp:  if (store->guild && ch->rank < 4)
stores.cpp:    room = ch->in_room;
stores.cpp:    store->guild = guild ? ch->clan : 0;
stores.cpp:  room = ch->in_room;
stores.cpp:    sprintf(owner, "%s", clan_table[ch->clan].display);
stores.cpp:    sprintf(owner, "%s", ch->name);
stores.cpp:  store->guild = guild ? ch->clan : 0;
stores.cpp:  store->shopkeeper.keeper = str_dup(ch->name);
stores.cpp:  ch->desc->pEdit = store;
stores.cpp:    clan_table[ch->clan].roster.questpoints -= 2000;
stores.cpp:    ch->questpoints -= 1000;
stores.cpp:  sprintf(buf, "%s bought a store", ch->name);
stores.cpp:    if (store->vnum == ch->in_room->vnum 
stores.cpp:      && (!str_cmp(store->owner, ch->name) 
stores.cpp:      && store->guild == ch->clan)|| IS_HIIMMORTAL(ch)))
stores.cpp:  store = ch->in_room->store;
stores.cpp:  store = ch->in_room->store;
stores.cpp:  if (ch->clan == clan_lookup("Tinker") && obj->pk == TRUE)
stores.cpp:  if ( ch->questpoints < cost)
stores.cpp:  if (ch->carry_number + get_obj_number(obj) > can_carry_n(ch))
stores.cpp:  if ( ch->carry_weight + get_obj_weight(obj) > can_carry_w(ch))
stores.cpp:  ch->questpoints -= cost;
stores.cpp:  sprintf( buf, "%s sells %s to %s", store->shopkeeper.keeper, obj->short_descr, ch->name); 
stores.cpp:    logf("%s sold to %s for %d qp.", obj->short_descr, ch->name, cost);
stores.cpp:  if ((ch->silver + 100 * ch->gold) < STORE_DAY_COST)
stores.cpp:  store->shopkeeper.keeper = str_dup(ch->name);
stores.cpp:  room = ch->in_room;  
stores.cpp:  ch->desc->editor = ED_NONE;
string.cpp:    ch->desc->pString = pString;
string.cpp:    ch->desc->pString = pString;
string.cpp:            free_string (*ch->desc->pString);
string.cpp:            *ch->desc->pString = str_dup ("");
string.cpp:            send_to_char (numlines (*ch->desc->pString), ch);
string.cpp:            *ch->desc->pString =
string.cpp:                string_replace (*ch->desc->pString, arg2, arg3);
string.cpp:            *ch->desc->pString = format_string (*ch->desc->pString);
string.cpp:            *ch->desc->pString =
string.cpp:                string_linedel (*ch->desc->pString, atoi (arg2));
string.cpp:            *ch->desc->pString =
string.cpp:                string_lineadd (*ch->desc->pString, tmparg3, atoi (arg2));
string.cpp:            *ch->desc->pString =
string.cpp:                string_linedel (*ch->desc->pString, atoi (arg2));
string.cpp:            *ch->desc->pString =
string.cpp:                string_lineadd (*ch->desc->pString, tmparg3, atoi (arg2));
string.cpp:        if (ch->desc->editor == ED_MPCODE)
string.cpp:        if ( ch->desc->editor == ED_OPCODE ) /* for the objprogs */
string.cpp:        if ( ch->desc->editor == ED_RPCODE ) /* for the roomprogs */
string.cpp:        ch->desc->pString = NULL;
string.cpp:    strcpy (buf, *ch->desc->pString);
string.cpp:        ch->desc->pString = NULL;
string.cpp:    free_string (*ch->desc->pString);
string.cpp:    *ch->desc->pString = str_dup (buf);
string.cpp:	         type == NOTE_RP ? ch->pcdata->fonts.rpnote : ch->pcdata->fonts.notes,
tournament.cpp:  if (ch->pcdata->tournament.reputation <= -25)
tournament.cpp:  return tournament_ranks[ch->pcdata->tournament.rank].who;
tournament.cpp:    if (ch->pcdata->pk_timer > 0)
tournament.cpp:    if (ch->level < 75)
tournament.cpp:    SET_BIT(ch->act2, PLR_TOURNAMENT_START);
tournament.cpp:    if (IS_SET(ch->act, PLR_TOURNEY) || IS_SET(ch->act2, PLR_TOURNAMENT_START))
tournament.cpp:    if (IS_SET(ch->act2, PLR_TOURNAMENT_SPECT))
tournament.cpp:    SET_BIT(ch->act2, PLR_TOURNAMENT_SPECT);
tournament.cpp:    if (ch->level <  LEVEL_HERO - 1)
tournament.cpp:    if (ch->pcdata->pk_timer > 0)
tournament.cpp:    if (IS_SET(ch->act, PLR_TOURNEY) || IS_SET(ch->act2, PLR_TOURNAMENT_START))
tournament.cpp:    if (ch->pcdata->tournament.rank > tournament.maxrank)
tournament.cpp:      SET_BIT(ch->act, PLR_TOURNEY);
tournament.cpp:      sprintf(buf, "`@%s `&has joined the tournament.`*\n\r", ch->name);
tournament.cpp:      SET_BIT(ch->act2, PLR_TOURNAMENT_START);
tournament.cpp:    if (!IS_SET(ch->act, PLR_TOURNEY) && 
tournament.cpp:        !IS_SET(ch->act2, PLR_TOURNAMENT_START) && 
tournament.cpp:        !IS_SET(ch->act2, PLR_TOURNAMENT_SPECT))
tournament.cpp:    if (!IS_SET(ch->act, PLR_TOURNEY) && 
tournament.cpp:        !IS_SET(ch->act2, PLR_TOURNAMENT_START) && 
tournament.cpp:        IS_SET(ch->act2, PLR_TOURNAMENT_SPECT))
tournament.cpp:      REMOVE_BIT(ch->act2, PLR_TOURNAMENT_SPECT);
tournament.cpp:    if (ch->pcdata->pk_timer > 0)
tournament.cpp:    sprintf(buf, "`@%s `&has left the tournament.`*\n\r", ch->name);
tournament.cpp:    if (IS_SET(ch->act, PLR_TOURNEY))
tournament.cpp:      REMOVE_BIT(ch->act, PLR_TOURNEY);
tournament.cpp:    if (IS_SET(ch->act2, PLR_TOURNAMENT_START))
tournament.cpp:      REMOVE_BIT(ch->act2, PLR_TOURNAMENT_START);
tournament.cpp:    ch->pcdata->tournament.last_killed = 0; 
tournament.cpp:    if (!IS_SET(ch->comm, COMM_NOTOURNEY))
tournament.cpp:       SET_BIT(ch->comm, COMM_NOTOURNEY);
tournament.cpp:    REMOVE_BIT(ch->comm, COMM_NOTOURNEY);
tournament.cpp:  if (victim->id == ch->pcdata->tournament.last_killed)
tournament.cpp:  ch->pcdata->tournament.last_killed = victim->id;
tournament.cpp:  rankDiff = victim->pcdata->tournament.rank - ch->pcdata->tournament.rank;
tournament.cpp:       sprintf(buf, "`@%s`& just got a new bunghole ripped by `@%s`*\n\r", victim->name, ch->name);
tournament.cpp:      sprintf(buf, "`@%s`& took the `@%s`&\'s Pepsi Challenge, and got sprayed with a can of whoopass!`*\n\r", victim->name, ch->name);
tournament.cpp:      sprintf(buf, "`@%s\'s`& head leaves a blood trail, as `@%s`& drags it behind him!`*\n\r", victim->name, ch->name);
tournament.cpp:      sprintf(buf, "`@%s`& broke his foot off in `@%s`&\'s ass!`*\n\r", ch->name, victim->name);
tournament.cpp:      sprintf(buf, "`@%s`&\'s ass is grass, and `@%s`&\'s the lawnmower!`*\n\r", victim->name, ch->name);
tournament.cpp:      sprintf(buf, "`@%s`& waves his magic wand *POOF* `@%s`& is dead!`*\n\r", ch->name, victim->name);
tournament.cpp:      sprintf(buf, "`@%s`& points to `@%s`& and says, \"Excuse the mess.\"`*\n\r", ch->name, victim->name);
tournament.cpp:      sprintf(buf, "`@%s`& ripped `@%s`& into two halves!`*\n\r", ch->name, victim->name);
tournament.cpp:      sprintf(buf, "`@%s`& mangles `@%s`& and calls it \"Modern Art\".`*\n\r", ch->name, victim->name);
tournament.cpp:      sprintf(buf, "`@%s`& gives `@%s`& the boot ... TO THE HEAD!`*\n\r", ch->name, victim->name);
tournament.cpp:      sprintf(buf, "`@%s`& fronts to `@%s`&, \"Talk to the palm, cuz you ain\'t the bomb!\"`*\n\r", ch->name, victim->name);
tournament.cpp:      sprintf(buf, "`@%s`& tosses `@%s`& a nickle. \"Buy some skills, kid.\"`*\n\r", ch->name, victim->name);
tournament.cpp:      sprintf(buf, "`@%s`& hit `@%s`& so hard, `@%s\'s`& mama fell over dead.`*\n\r", ch->name, victim->name, victim->name);
tournament.cpp:      sprintf(buf, "`@%s`& beat `@%s`& like a stuffed Pinata(sp).`*\n\r", ch->name, victim->name);
tournament.cpp:      sprintf(buf, "`@%s`& squishes `@%s`&, just like grape.`*\n\r", ch->name, victim->name);
tournament.cpp:  ch->pcdata->tournament.kills += 1;
tournament.cpp:  ch->hit = UMIN(ch->max_hit, ch->hit + (ch->max_hit / 4));
tournament.cpp:  ch->mana = UMIN(ch->max_mana, ch->mana + (ch->max_mana / 4));
tournament.cpp:	 URANGE(-5, ch->pcdata->tournament.rank - victim->pcdata->tournament.rank - 1, -1));
tournament.cpp:			(victim->pcdata->tournament.rank > ch->pcdata->tournament.rank ? 1 : 0)));    
tournament.cpp:  /*if ((ch->pcdata->tournament.reputation + points) <= -50)
tournament.cpp:    ch->pcdata->tournament.reputation = -50;
tournament.cpp:  ch->pcdata->tournament.reputation = URANGE(-32000, ch->pcdata->tournament.reputation + points, 32000);
tournament.cpp:  if ((ch->pcdata->tournament.rank < MAX_TOURNAMENT_RANK - 1) &&
tournament.cpp:     (ch->pcdata->tournament.reputation > tournament_ranks[ch->pcdata->tournament.rank + 1].reputation))
tournament.cpp:    ch->pcdata->tournament.rank += 1;
tournament.cpp:            tournament_ranks[ch->pcdata->tournament.rank].name);
tournament.cpp:            ch->name, 
tournament.cpp:            tournament_ranks[ch->pcdata->tournament.rank].name);
tournament.cpp:    if (ch->pcdata->tournament.last_rank != ch->pcdata->tournament.rank)
tournament.cpp:	 tournament_ranks[ch->pcdata->tournament.rank].prize);
tournament.cpp:      ch->questpoints += tournament_ranks[ch->pcdata->tournament.rank].prize;
tournament.cpp:      ch->pcdata->tournament.last_rank = ch->pcdata->tournament.rank;
tournament.cpp:  if ((ch->pcdata->tournament.rank < MAX_TOURNAMENT_RANK) &&
tournament.cpp:       ch->pcdata->tournament.rank > 0 &&
tournament.cpp:     (ch->pcdata->tournament.reputation < tournament_ranks[ch->pcdata->tournament.rank].reputation))
tournament.cpp:    ch->pcdata->tournament.rank -= 1;
tournament.cpp:            tournament_ranks[ch->pcdata->tournament.rank].name);
tournament.cpp:            ch->name, 
tournament.cpp:            tournament_ranks[ch->pcdata->tournament.rank].name);
update.cpp:    ch->pcdata->last_level =
update.cpp:        (ch->played + (int) (current_time - ch->logon)) / 3600;
update.cpp:             title_table[ch->cClass][ch->level][ch->sex ==
update.cpp:        number_range (class_table[ch->cClass].hp_min,
update.cpp:                      class_table[ch->cClass].hp_max);
update.cpp:    if (ch->clan == clan_lookup("Sedai") || ch->clan == clan_lookup("Rebel") )
update.cpp:                    class_table[ch->cClass].mana_min,
update.cpp:                    class_table[ch->cClass].mana_max);                   
update.cpp:    //if (!class_table[ch->cClass].fMana)
update.cpp:        ch->level += 1;
update.cpp:        ch->train += 1;
update.cpp:        ch->max_hit += add_hp;
update.cpp:        ch->max_mana += add_mana;
update.cpp:        ch->max_move += add_move;
update.cpp:        ch->practice += add_prac;
update.cpp:        ch->pcdata->perm_hit += add_hp;
update.cpp:        ch->pcdata->perm_mana += add_mana;
update.cpp:        ch->pcdata->perm_move += add_move;
update.cpp:	ch->level -= 1;
update.cpp:        ch->train -= 1;
update.cpp:        ch->max_hit -= add_hp;
update.cpp:        ch->max_mana -= add_mana;
update.cpp:	ch->max_move -= add_move;
update.cpp:	ch->practice -= add_prac;
update.cpp:	ch->pcdata->perm_hit -= add_hp;
update.cpp:	ch->pcdata->perm_mana -= add_mana;
update.cpp:	ch->pcdata->perm_move -= add_move;
update.cpp:    do_restore(creator, ch->name); 
update.cpp:    if (ch->level >= 75)
update.cpp:	ch->realexp += (gain);
update.cpp:    ch->exp = UMAX (exp_per_level (ch, ch->pcdata->points), ch->exp + gain);
update.cpp:    while (ch->level < MAX_NORMAL && ch->exp >=
update.cpp:           exp_per_level (ch, ch->pcdata->points) * (ch->level + 1))
update.cpp:	if (ch->level == 35 && IS_SET(ch->act, PLR_NOPK))
update.cpp:	  REMOVE_BIT(ch->act, PLR_NOPK);
update.cpp:	if (ch->level == 25 && IS_SET(ch->comm, COMM_NOVICE))
update.cpp:	  REMOVE_BIT(ch->comm, COMM_NOVICE);
update.cpp:        sprintf (buf, "%s gained level %d\n\r", ch->name, ch->level+1);
update.cpp:        sprintf (buf, "$N has attained level %d!\n\r", ch->level+1);
update.cpp:    if (ch->in_room == NULL)
update.cpp:        gain = 5 + ch->level;
update.cpp:        switch (ch->position)
update.cpp:        gain = UMAX (3, int(get_curr_stat (ch, STAT_CON) - 3 + ch->level / 1.5));
update.cpp:        if (ch->pcdata->pk_timer == 0 && ch->max_hit > 2000)
update.cpp:          gain += UMIN(((ch->max_hit - 2000) / 50), 35);
update.cpp:        gain += class_table[ch->cClass].hp_max - 5;
update.cpp:            if (ch->hit < ch->max_hit)
update.cpp:        switch (ch->position)
update.cpp: /*	if ( ch->in_room->vnum == ch->pcdata->rentroom  && ch->silver > 10)
update.cpp: 	if ( IS_SET(ch->act, PLR_TENNANT) && ch->silver > 10)
update.cpp:   		ch->silver -= 10;                  Room Rental  */
update.cpp:        if ( ch->clan == 0)
update.cpp:        if ( get_obj_list(ch, "burning fire", ch->in_room->contents) != NULL )
update.cpp:    gain = gain * ch->in_room->heal_rate / 100;
update.cpp:    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
update.cpp:        gain = gain * ch->on->value[3] / 100;
update.cpp:    if (IS_SET(ch->act, PLR_TOURNEY))
update.cpp:    return UMIN (gain, ch->max_hit - ch->hit);
update.cpp:    if (ch->in_room == NULL)
update.cpp:        gain = 5 + ch->level;
update.cpp:        switch (ch->position)
update.cpp:                + get_curr_stat (ch, STAT_INT) + ch->level) / 1.5);
update.cpp:        if (ch->pcdata->pk_timer == 0 && ch->max_mana > 1100)
update.cpp:          gain += UMIN(((ch->max_mana - 2000) / 50), 35);
update.cpp:            gain += number * gain / 100 + (ch->level / 2);
update.cpp:            if (ch->mana < ch->max_mana)
update.cpp:        //if (!class_table[ch->cClass].fMana)
update.cpp:        switch (ch->position)
update.cpp://		if (ch->pcdata->condition[COND_BLEEDING] != 0)
update.cpp:        if ( ch->clan == 0)
update.cpp:        if ( get_obj_list(ch, "burning fire", ch->in_room->contents) != NULL )
update.cpp:    gain = gain * ch->in_room->mana_rate / 100;
update.cpp:    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
update.cpp:        gain = gain * ch->on->value[4] / 100;
update.cpp:    if (IS_SET(ch->act, PLR_TOURNEY))
update.cpp:    return UMIN (gain, ch->max_mana - ch->mana);
update.cpp:    if (ch->in_room == NULL)
update.cpp:        gain = ch->level;
update.cpp:        gain = UMAX (15, ch->level);
update.cpp:        switch (ch->position)
update.cpp://		if (ch->pcdata->condition[COND_BLEEDING] != 0)
update.cpp:        if ( ch->clan == 0)
update.cpp:        if ( get_obj_list(ch, "burning fire", ch->in_room->contents) != NULL )
update.cpp:    gain = gain * ch->in_room->heal_rate / 100;
update.cpp:    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
update.cpp:        gain = gain * ch->on->value[3] / 100;
update.cpp:    if (IS_SET(ch->act, PLR_TOURNEY))
update.cpp:   return UMIN (gain, ch->max_move - ch->move);
update.cpp:    if ((value == 0 || IS_NPC (ch) || ch->level >= LEVEL_IMMORTAL) && iCond != COND_HORNY)
update.cpp:    condition = ch->pcdata->condition[iCond];
update.cpp:    if (ch->sex == 1 &&(ch->clan != clan_lookup("Whitetower")) && ch->clan != clan_lookup("Guide"))
update.cpp:      ch->pcdata->condition[iCond] = URANGE (0, condition + value, 60);
update.cpp:      ch->pcdata->condition[iCond] = URANGE (2, condition + value, 60);
update.cpp:    if (ch->pcdata->condition[iCond] == 0)
update.cpp:           if (ch->pcdata->aggro_timer > 1)
update.cpp:             ch->pcdata->aggro_timer--;
update.cpp:           if (ch->pcdata->aggro_timer == 1)
update.cpp:              ch->pcdata->aggro_timer--;
update.cpp:              if (IS_SET(ch->act2, PLR_MSP_MUSIC) && !IS_SET(ch->act2, PLR_FLED))
update.cpp:              if (IS_SET(ch->act2, PLR_MSP_PLAYING)) 
update.cpp:                REMOVE_BIT(ch->act2, PLR_MSP_PLAYING);
update.cpp:        ch_next = ch->next;
update.cpp:        if (!IS_NPC (ch) || ch->in_room == NULL
update.cpp:        if (ch->in_room->area->empty && !IS_SET (ch->act, ACT_UPDATE_ALWAYS))
update.cpp:        if (ch->spec_fun != 0 && (!ch->rescuer || (ch->rescuer && ch->fighting != ch->attacker) || (ch->spec_fun == spec_lookup("spec_rescue")) ))
update.cpp:            if ((*ch->spec_fun) (ch))
update.cpp:        if (ch->pIndexData->pShop != NULL)    /* give him some gold */
update.cpp:            if ((ch->gold * 100 + ch->silver) < ch->pIndexData->wealth)
update.cpp:                ch->gold +=
update.cpp:                    ch->pIndexData->wealth * number_range (1, 20) / 4000000;
update.cpp:                ch->silver +=
update.cpp:                    ch->pIndexData->wealth * number_range (1, 20) / 40000;
update.cpp:        if (ch->position == ch->pIndexData->default_pos)
update.cpp:            if (HAS_TRIGGER_MOB (ch, TRIG_DELAY) && ch->mprog_delay > 0)
update.cpp:                if (--ch->mprog_delay <= 0)
update.cpp:        if (ch->position != POS_STANDING)
update.cpp:        if (IS_SET (ch->act, ACT_SCAVENGER)
update.cpp:            && ch->in_room->contents != NULL && number_bits (6) == 0)
update.cpp:            for (obj = ch->in_room->contents; obj; obj = obj->next_content)
update.cpp:        if (!IS_SET (ch->act, ACT_SENTINEL)
update.cpp:            && !IS_SET(ch->act, ACT_MOUNT)
update.cpp:            && (pexit = ch->in_room->exit[door]) != NULL
update.cpp:            && (!IS_SET (ch->act, ACT_STAY_AREA)
update.cpp:                || pexit->u1.to_room->area == ch->in_room->area)
update.cpp:            && (!IS_SET (ch->act, ACT_OUTDOORS)
update.cpp:            && (!IS_SET (ch->act, ACT_INDOORS)
update.cpp:      if (ch->pcdata->pk_timer > 0)
update.cpp:        ch->pcdata->pk_timer--;
update.cpp:        if (ch->pcdata->pk_timer == 0)
update.cpp:	  ch->pcdata->initiator = 0;
update.cpp:      if (ch->pcdata->safe_timer > 0)
update.cpp:        ch->pcdata->safe_timer--;
update.cpp:      if (ch->pcdata->wait_timer > 0)
update.cpp:        ch->pcdata->wait_timer--;
update.cpp:      if (ch->timed_affect.seconds > 0)
update.cpp:        ch->timed_affect.seconds--;
update.cpp:	if (ch->timed_affect.seconds == 0)
update.cpp:          affect_strip(ch, ch->timed_affect.sn);
update.cpp:    	  af.level     = ch->level;
update.cpp:        ch_next = ch->next;
update.cpp:      if (ch->pcdata->xpmultiplier.time > -1 && ch->pcdata->xpmultiplier.on)
update.cpp:        ch->pcdata->xpmultiplier.time--;
update.cpp:        if (ch->pcdata->xpmultiplier.time < 3 && ch->pcdata->xpmultiplier.time > 0)
update.cpp:          if (ch->pcdata->xpmultiplier.factor > 0)
update.cpp:        if (ch->pcdata->xpmultiplier.time < 1)   
update.cpp:          ch->pcdata->xpmultiplier.on = FALSE;
update.cpp:          if (ch->pcdata->xpmultiplier.factor > 0) 
update.cpp:    if ((ch->penalty.murder > 0) && !IS_SET(ch->comm, COMM_AFK) && (ch->penalty.murder > 1 || ch->pcdata->pk_timer == 0))
update.cpp:        ch->penalty.murder--;
update.cpp:    if ((ch->penalty.thief > 0) && !IS_SET(ch->comm, COMM_AFK) && (ch->penalty.thief > 1 || ch->pcdata->pk_timer == 0))    
update.cpp:        ch->penalty.thief--;
update.cpp:    if ((ch->penalty.jail > 0) && !IS_SET(ch->comm, COMM_AFK))
update.cpp:        if(ch->penalty.jail == 1)
update.cpp:                if (IS_SET(ch->comm, COMM_NOCHANNELS))
update.cpp:                    REMOVE_BIT (ch->comm, COMM_NOCHANNELS);
update.cpp:                ch->penalty.jail--;
update.cpp:                ch->penalty.jail--;
update.cpp:    if (IS_NPC(ch) && (ch->pIndexData->load_time.start != 0 || 
update.cpp:             ch->pIndexData->load_time.end != 0))
update.cpp:      int start = ch->pIndexData->load_time.start;
update.cpp:      int end = ch->pIndexData->load_time.end;
update.cpp:           STR_REMOVE_BIT(ch->affected_by, AFF_SUPER_INVIS);
update.cpp:        else if (ch->hit == ch->max_hit && !ch->fighting)
update.cpp:          STR_SET_BIT(ch->affected_by, AFF_SUPER_INVIS);
update.cpp:           STR_REMOVE_BIT(ch->affected_by, AFF_SUPER_INVIS);
update.cpp:        else if (ch->hit == ch->max_hit && !ch->fighting)
update.cpp:          STR_SET_BIT(ch->affected_by, AFF_SUPER_INVIS);
update.cpp:    if (!IS_NPC(ch) && ch->pcdata->safe_timer == 0 &&
update.cpp:          ch->in_room && ch->in_room->vnum == ROOM_VNUM_MORGUE)
update.cpp:        if (ch->timer > 5 && !ch->desc)
update.cpp:            if (IS_SET(ch->act, PLR_QUESTOR))
update.cpp:              REMOVE_BIT(ch->act, PLR_QUESTOR);
update.cpp:              ch->questgiver = NULL;
update.cpp:              ch->countdown = 0;
update.cpp:              ch->questmob = 0;
update.cpp:              ch->questobj = 0;
update.cpp:              ch->questriddle = 0;
update.cpp:              ch->nextquest = 15;
update.cpp:            if (IS_SET(ch->act, PLR_TOURNEY) || IS_SET(ch->act2, PLR_TOURNAMENT_START))      
update.cpp:              if (IS_SET(ch->act, PLR_TOURNEY))
update.cpp:                REMOVE_BIT(ch->act, PLR_TOURNEY);
update.cpp:              if (IS_SET(ch->act2, PLR_TOURNAMENT_START))
update.cpp:                REMOVE_BIT(ch->act2, PLR_TOURNAMENT_START);
update.cpp:        if (ch->timer > 25 && !ch->desc)
update.cpp:	if (ch->interdimension > 0 && --(ch->interdimension) == 0)
update.cpp:        if (ch->position >= POS_STUNNED)
update.cpp:            if (IS_NPC (ch) && ch->zone != NULL
update.cpp:                && ch->zone != ch->in_room->area && ch->desc == NULL
update.cpp:                && ch->fighting == NULL && !IS_AFFECTED (ch, AFF_CHARM)
update.cpp:            if (ch->hit < ch->max_hit)
update.cpp:                ch->hit += hit_gain (ch);
update.cpp:                ch->hit = ch->max_hit;
update.cpp:            if (ch->mana < ch->max_mana)
update.cpp:                ch->mana += mana_gain (ch);
update.cpp:                ch->mana = ch->max_mana;
update.cpp:            if (ch->move < ch->max_move)
update.cpp:                ch->move += move_gain (ch);
update.cpp:                ch->move = ch->max_move;
update.cpp:        if (ch->position == POS_STUNNED)
update.cpp:                if (--obj->value[2] == 0 && ch->in_room != NULL && !IS_IMMORTAL(ch))
update.cpp:                    --ch->in_room->light;
update.cpp:                else if (obj->value[2] <= 5 && ch->in_room != NULL)
update.cpp:	    ch->timer++;
update.cpp:            if (ch->timer >= 35 && !IS_IMMORTAL(ch))
update.cpp:                if (ch->was_in_room == NULL && ch->in_room != NULL)
update.cpp:                    ch->was_in_room = ch->in_room;
update.cpp:                    if (ch->fighting != NULL)
update.cpp:                    if (ch->level > 1)
update.cpp:			else if (ch->timer >= 15 && !IS_IMMORTAL(ch))
update.cpp:				if (!IS_SET(ch->comm,COMM_AFK))
update.cpp:				  SET_BIT (ch->comm, COMM_AFK);         
update.cpp:            if (!IS_NPC(ch) && ch->timer > 99)
update.cpp:		ch->timer = 99;
update.cpp:            ch->pcdata->condition[COND_GOBLIND] = 0;
update.cpp:        for (paf = ch->affected; paf != NULL; paf = paf_next)
update.cpp:		   ch->fighting != NULL)
update.cpp:		   ch->fighting != NULL)
update.cpp:                   ch->name = ch->pcdata->disguise.orig_name;
update.cpp:                   ch->pcdata->title = ch->pcdata->disguise.orig_title;
update.cpp:                   ch->description = ch->pcdata->disguise.orig_desc;
update.cpp:                   ch->short_descr = ch->pcdata->disguise.orig_short;
update.cpp:                   ch->long_descr = ch->pcdata->disguise.orig_long;
update.cpp:                   STR_REMOVE_BIT(ch->affected_by, paf->bitvector); 
update.cpp:                STR_REMOVE_BIT(ch->affected_by, paf->bitvector); 
update.cpp:		  STR_REMOVE_BIT(ch->affected_by, AFF_SEVERED);
update.cpp:            if (ch->in_room == NULL)
update.cpp:            for (af = ch->affected; af != NULL; af = af->next)
update.cpp:                STR_REMOVE_BIT (ch->affected_by, AFF_PLAGUE);
update.cpp:            for (vch = ch->in_room->people; vch != NULL;
update.cpp:                 vch = vch->next_in_room)
update.cpp:            dam = UMIN (ch->level, af->level / 5 + 1);
update.cpp:            ch->mana -= dam;
update.cpp:            ch->move -= dam;
update.cpp:            poison = affect_find (ch->affected, gsn_poison);
update.cpp:            ravage = affect_find (ch->affected, gsn_ravage);
update.cpp:                ch->mana -= ravage->level / 3 + 15;
update.cpp:                ch->move -= ravage->level / 3 + 15;
update.cpp:            contact = affect_find (ch->affected, gsn_contact);
update.cpp:                ch->mana -= ch->level / 2 + 5;
update.cpp:                ch->move -= ch->level / 2 + 15;
update.cpp:                damage (ch, ch, ch->level / 2 + 5, gsn_contact, DAM_POISON, FALSE, FALSE);
update.cpp:        else if (ch->position == POS_INCAP && number_range (0, 1) == 0)
update.cpp:				&&  ch->pcdata->condition[COND_BLEEDING] > 0)  
update.cpp:        else if (ch->position == POS_MORTAL)
update.cpp:		&&  ch->pcdata->condition[COND_BLEEDING] > 0)  
update.cpp:        if (!IS_NPC(ch) && ch->pcdata->dream)
update.cpp:          if (ch->position == POS_SLEEPING)
update.cpp:            ch->pcdata->dream = FALSE;
update.cpp:            ch->pcdata->dream_to_room = ch->in_room;
update.cpp:        ch_next = ch->next;
update.cpp:        if (ch->desc != NULL && ch->desc->descriptor % 30 == save_number)
update.cpp:     ch_next = ch->next;  
update.cpp:          dam = number_range(int(ch->level * 1.95), int(ch->level * 2.9 + (number_percent() / 5)));
update.cpp:          if (ch->mana < 20)
update.cpp:          ch->mana -= 10;
update.cpp:          for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
update.cpp:          vch_next = vch->next_in_room;
update.cpp:        wch_next = wch->next;
update.cpp:            || wch->level >= LEVEL_IMMORTAL
update.cpp:            || wch->in_room == NULL || wch->in_room->area->empty) continue;
update.cpp:        for (ch = wch->in_room->people; ch != NULL; ch = ch_next)
update.cpp:            ch_next = ch->next_in_room;
update.cpp:                || !IS_SET (ch->act, ACT_AGGRESSIVE)
update.cpp:                || IS_SET (ch->in_room->room_flags, ROOM_SAFE)
update.cpp:                || ch->fighting != NULL || IS_AFFECTED (ch, AFF_CHARM)
update.cpp:                || (IS_SET (ch->act, ACT_WIMPY) && IS_AWAKE (wch))
update.cpp:                      && IS_SET(ch->act, ACT_WIMPY)
update.cpp:                      && ch->wait < PULSE_VIOLENCE / 2
update.cpp:                        && ch->fighting == NULL )
update.cpp:            for (vch = wch->in_room->people; vch != NULL; vch = vch_next)
update.cpp:                vch_next = vch->next_in_room;
update.cpp:                    && !IS_SET(vch->act, PLR_TOURNEY) 
update.cpp:                    && vch->level < LEVEL_IMMORTAL
update.cpp:                    && ch->level >= vch->level - 5
update.cpp:                    && (!IS_SET (ch->act, ACT_WIMPY) || !IS_AWAKE (vch))
update.cpp:        ch_next = ch->next;
update.cpp:            && ch->fighting == NULL
update.cpp:            && ch->hunting != NULL
update.cpp:            && !IS_SET(ch->act,ACT_NOHUNT) &&
update.cpp:               !ch->mount)
update.cpp:        if ((victim = ch->fighting) == NULL)
update.cpp:			&& ch->fighting != NULL
update.cpp:			&& ch->hunting == NULL
update.cpp:			&& !IS_SET(ch->act,ACT_NOHUNT))
update.cpp:			ch->hunting = victim;
update.cpp:    if (!ch || !ch->in_room)
update.cpp:       && IS_SET(ch->in_room->room_flags, ROOM_DEATHTRAP) )
update.cpp:	  if (ch->pcdata->pk_timer > 0)
update.cpp:          if (ch->hit > 20)
update.cpp:	        if (ch->position ==  POS_STANDING)	
update.cpp:                  ch->position = POS_RESTING;
update.cpp:                ch->hit = int(ch->hit * .90);
update.cpp:             ch->hit = 1;
update.cpp:        number_range (class_table[ch->cClass].hp_min,
update.cpp:                      class_table[ch->cClass].hp_max);
update.cpp:                    class_table[ch->cClass].mana_min,
update.cpp:                    class_table[ch->cClass].mana_max);                   
update.cpp:    //if (!class_table[ch->cClass].fMana)
update.cpp:		ch->rplevel += 1;
update.cpp:                if (ch->clan > 0)
update.cpp:                  member_rp(ch->name, ch->clan, 1);           
update.cpp:		ch->max_hit += add_hp;
update.cpp:		ch->max_mana += add_mana;
update.cpp:		ch->max_move += add_move;
update.cpp:		ch->practice += add_prac;
update.cpp:		ch->gold += 1000;
update.cpp:                ch->rp_points += 1; 
update.cpp:		ch->pcdata->perm_hit += add_hp;
update.cpp:		ch->pcdata->perm_mana += add_mana;
update.cpp:		ch->pcdata->perm_move += add_move;
update.cpp:		ch->rplevel -= 1;
update.cpp:                if (ch->clan > 0)
update.cpp:                  member_rp(ch->name, ch->clan, -1);           
update.cpp:		ch->max_hit -= add_hp;
update.cpp:		ch->max_mana -= add_mana;
update.cpp:		ch->max_move -= add_move;
update.cpp:		ch->practice -= add_prac;
update.cpp:		ch->pcdata->perm_hit -= add_hp;
update.cpp:		ch->pcdata->perm_mana -= add_mana;
update.cpp:		ch->pcdata->perm_move -= add_move;
update.cpp:    if(ch->level < 70)
update.cpp:    else if (ch->level == 71)
update.cpp:    else if (ch->level == 72)
update.cpp:    else if (ch->level == 73)
update.cpp:    else if (ch->level == 74)
update.cpp:	int rp_xp_per_lvl = 1000 + (ch->rplevel*100);/*If you change you must change in act_info.c -CAMM*/
update.cpp:    if (IS_NPC (ch) || ch->level >= MAX_RPLEVEL)
update.cpp:    ch->rpexp = ch->rpexp + gain;
update.cpp:    while (ch->rplevel < MAX_RPLEVEL && ch->rpexp >=
update.cpp:        ch->rpexp -= rp_xp_per_lvl;
update.cpp:        sprintf (buf, "%s gained role-playing level %d\n\r", ch->name, ch->rplevel);
update.cpp:        sprintf (buf, "$N has attained role-playing level %d!\n\r", ch->rplevel+1);
update.cpp:    if (IS_NPC(ch) || IS_IMMORTAL(ch) || ch->level < 11)
update.cpp:        if (ch->pcdata->condition[COND_BLEEDING] == 0)
update.cpp:            ch->pcdata->condition[COND_BLEEDING]=1;
update.cpp:    	if (ch->pcdata->condition[COND_BLEEDING] == 1)
update.cpp:    	    ch->pcdata->condition[COND_BLEEDING]=0;
update.cpp:    if (IS_IMMORTAL(ch) || ch->level < 11)
update.cpp:    	ch->pcdata->condition[COND_BLEEDING] = 0;
update.cpp:        if (ch->pcdata->condition[COND_BLEEDING] == 1 )
update.cpp:            obj_to_room (blood, ch->in_room);
update.cpp:	    ch->hit  -= number_range(1,5);
update.cpp:            ch->move -= number_range(1,5);
update.cpp:        if (ch->pcdata->condition[COND_BLEEDING] == 1  
update.cpp:    	if ( ch->pcdata->condition[COND_BLEEDING] == 1 )
update.cpp:	    obj_to_room (blood, ch->in_room);
update.cpp:            ch->hit  -= number_range(1,5);
update.cpp:            ch->move -= number_range(1,5);
update.cpp:        ch_next = ch->next;
update.cpp:        if (IS_NPC (ch) || ch->fighting != NULL || !is_affected(ch,sn) || (ch->in_room == NULL))
update.cpp:        for (af = ch->affected; af != NULL; af = af->next)
websvr.cpp:        cClass = class_table[wch->cClass].who_name;
websvr.cpp:        switch (wch->level)
websvr.cpp:         if (wch->level >= LEVEL_IMMORTAL && !IS_NULLSTR(wch->pretit))
websvr.cpp:           preTitleLen = colorstrlen(wch->pretit);
websvr.cpp:           sprintf(temp, "%*s%s%*s", front, "", wch->pretit, back, "");
websvr.cpp:    if (wch->level > 77 || IS_DRAGON(wch) || IS_FORSAKEN(wch))  
websvr.cpp:                 (wch->honor < 0) ? 0 : wch->honor,
websvr.cpp:                 str_cmp(clan_table[wch->clan].who_name, "None") ? clan_table[wch->clan].who_name : "",                 
websvr.cpp:                 IS_SET(wch->act, PLR_QUESTING) ? "`$(`&QUEST`$)`* " : "",
websvr.cpp:                 IS_SET(wch->act, PLR_TOURNEY) ? show_trank(wch) : "",
websvr.cpp:                 IS_SET(wch->act2, PLR_WAR) ? "`8(`&W`7A`&R`8)`* " : "",
websvr.cpp:                 IS_SET(wch->act, PLR_TAG) ? "`8(`!TAG`8)`7 " : "",
websvr.cpp:                 IS_SET(wch->act, PLR_IT) ? " `8(`$IT`8)`7 " : "",
websvr.cpp:                 wch->incog_level >= LEVEL_HERO ? "`7(`6I`7) " : "",
websvr.cpp:                 wch->invis_level >= LEVEL_HERO ? "`7(`5W`7) " : "",
websvr.cpp:                 IS_SET (wch->comm, COMM_AFK) ? "`7(`^AFK`7) " : "",
websvr.cpp:                 IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_name : wch->name,
websvr.cpp:                 wch->pcdata->title); 
websvr.cpp:                 wch->level,
websvr.cpp://                 wch->race < MAX_PC_RACE ? pc_race_table[wch->race].who_name
websvr.cpp://                 IS_SET(wch->act2, PLR_LOOTABLE) ? "`!" : "`&",
websvr.cpp:                 (wch->honor < 0) ? 0 : wch->honor,
websvr.cpp:                 str_cmp(clan_table[wch->clan].who_name, "None") ? clan_table[wch->clan].who_name: "",                 
websvr.cpp:                 IS_SET(wch->act, PLR_QUESTING) ? "`$(`&QUEST`$)`* " : "",
websvr.cpp:                 IS_SET(wch->act, PLR_TOURNEY) ? show_trank(wch) : "",
websvr.cpp:                 IS_SET(wch->act2, PLR_WAR) ? "`8(`&W`7A`&R`8)`* " : "",
websvr.cpp:                 IS_SET(wch->act, PLR_TAG) ? "`8(`!TAG`8)`7 " : "",
websvr.cpp:                 IS_SET(wch->act, PLR_IT) ? " `8(`$IT`8)`7 " : "",
websvr.cpp:                 wch->incog_level >= LEVEL_HERO ? "`7(`6I`7) " : "",
websvr.cpp:                 wch->invis_level >= LEVEL_HERO ? "`7(`5W`7)`7 " : "",
websvr.cpp:                 IS_SET (wch->comm, COMM_AFK) ? "`7(`^AFK`7) " : "",
websvr.cpp:                 IS_DISGUISED(wch) ? wch->pcdata->disguise.orig_name : wch->name,
websvr.cpp:                 wch->pcdata->title);
